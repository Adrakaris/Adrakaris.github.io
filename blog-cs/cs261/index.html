<!DOCTYPE html>
<html>
<head>
	<title>CS261</title>
	<meta charset="utf-8">
	<link rel="stylesheet" type="text/css" href="../../style/style.css" media="all">  <!--TODO: CHANGE HREF-->
	<link rel="stylesheet" type="text/css" href="../../style/prism.css" media="all">
	<meta name="viewport" content="width=device-width" initial-scale=1.0>  <!--TODO: CHANGE LINKS ON BOTTOM OF SHEET FOR COLLAPSIBLE-->
	<link rel="icon" type="image/png" href="../../style/images/DragonIcon.png">
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>

	<div class="hidden">
		<header>
			<div class="parallax parsmaller">
				<div  style="display: grid; grid-template-columns: 1fr 1fr 1fr 8fr 1fr; grid-column-gap: 10px; padding: 5px; ">
					<div class="column tinycolumn">
						<a href="../../" class="nav">Home</a>
					</div>
					<div class="column tinycolumn">
						<a href="../../blog.html" class="nav">Blog</a>
					</div>
					<div class="column tinycolumn">
						
						<a href="../../about.html" class="nav">About</a>
					</div>
					<div></div>
					<div class="column">
						<button class="nav dark-light">Dark Mode</button>
					</div>
				</div>
				<div class="cbox"> 		
					<h1>CS261</h1>
					<p class="subheading">Software Engineering (wah)</p>
				</div>
			</div>
		</header>

		<header>
			<div class="cbox">
				<h1>Contents</h1>
			</div>
		</header>

		<div class="cbox">
			<ol>
				<li><a href="#dev">Software Development Methodologies</a></li>
				<li><a href="#reqanal">Requirements Analysis</a></li>
				<li><a href="#teamorg">Team Organisation</a></li>
				<li><a href="#design">System Design</a></li>
				<li><a href="#proj-manage">Project Management</a></li>
				<LI><a href="#implementation">Implementation</a></LI>
			</ol>
		</div>

		
		<div class="colourband">
			<h2 id="dev">Software Development Methodologies</h2>
		</div>

		<div class="cbox">
			<h3>Introduction</h3>

			<ol>
				<li><a href="#dev-1">Plan-Driven</a></li>
				<li><a href="#dev-2">Software Spec</a></li>
				<li><a href="#dev-3">Agile</a></li>
			</ol>

			<ul>
				<li>
					Different Systems need different processes.
				</li>
				<li>
					All processes involve some sort of specification, design and implementation, testing, and evolution (maintaining)
				</li>
				<li>
					Two main types of development: plan driven and agile
				</li>
				<li>
					Plan driven: everything is planned and fixed in advance. Inflexible.
				</li>
				<li>
					Agile: Incremental planning, more adaptable to change.
				</li>
			</ul>

			<h3 id="dev-1">Plan-Driven</h3>

			<p>
				<b>Waterfall Model</b>
			</p>
			<ul>
				<li>
					Invented in 1970, strictest of all plan driven models. 
				</li>
				<li>
					If a change is required, the waterfall model must restart. Incredibly inflexible and in practice not completely followed. 
					<figure>
						<img src="https://www.umsl.edu/~hugheyd/is6840/images/Waterfall_model.png" alt="" style="max-width: 300px;" title="Uni of Missouri">
					</figure>
				</li>
				<li>
					<b>Requirements:</b> most customer focused, involves identification of resources, distribution of work.
				</li>
				<li>
					<b>Design:</b> design document generated, should be really detailed so implementation is not hard.
				</li>
				<li>
					<b>Implementation:</b> only when design doc is finished. Everything written should be unit tested.
				</li>
				<li>
					<b>Verification/Integration:</b> Most group focused - putting all parts of system together, making sure they work.
				</li>
				<li>
					<b>Maintenance:</b> Hand over program and documentation. Offer maintenance, which is also done via waterfall.
				</li>
				<li>
					Waterfall is good when requirements are understood and will not change. Few constraints on location and teams size (development distributed and isolated) and each component can be first tested in isolation.
				</li>
				<li>
					Waterfall is not good as the client has to wait a long time for results, and changes are difficult to accommodate, and there is a problem of software tech deprecation over the entire years-long development timespan.
				</li>
			</ul>

			<p><b>Inremental Development</b> </p>

			<ul>
				<li>
					A more flexible system than waterfall.
					<figure><img src="https://i.stack.imgur.com/BqktJ.jpg" alt="" title="stackoverflow" style="max-width: 420px;"></figure>
				</li>
				<li>
					Each iteration is still planned like waterfall, spec updated between iterations (not rewritten).
				</li>
				<li>
					(+) cost of accomodating change much reduced, and user gets software quicker, feedback is easier to get -- better (perceived) value for money
				</li>
				<li>
					(+) user inclustion in acceptance testing, can even install system before the final version.
				</li>
				<li>
					(-) <b>very</b> difficult to estimate overall cost of development of such a system.
				</li>
				<li>
					(-) difficult to maintain consistency between versions - poor design choices early on hamper later feature additions. Spaghetti code. 
				</li>
			</ul>

			<p><b>Reuse-Oriented Sofware Engineering</b></p>

			<ul>
				<li>
					Why reinvent the wheel? Instead, many devs rely on "off-the-shelf" / open source premade components, and just writes the glue code to tack them together. <b>Common off the shelf (COTS) systems</b>.
				</li>
				<li>
					Compromises on features with client has to be made, but tradeoff is that program is banged out in record time. 
				</li>
			</ul>

			<h3 id="dev-2">Software Spec</h3>

			<ul>
				<li>
					To understand and define what services are required
				</li>
				<li>
					To identify limits in feasibility - "requirements engineering", producing requirements document. 
				</li>
				<li>
					<figure><img src="./requirements-doc.png" alt="" style="max-width: 630px;"></figure>
				</li>
			</ul>

			<h3 id="dev-3">Agile</h3>

			<ul>
				<li >
					Agile development is about <i>rapid</i> development: interleave spec, design, and implementation, and develop the system as a series of evolving prototypes. 
				</li>
				<li>
					Focus on code over design, develop as you go. Aim for speed, and flexibility. 
				</li>
				<li>
					Often has the short stand up meeting concept. 
				</li>
				<li>
					Major principles of Agile are
					<ul>
						<li>Customer involvement - cannot respond rapidly to changes without rapid feedback</li>
						<li>Incremental delivery - have prototypes, and update spec for next iterations</li>
						<li>People not process - have highly skilled coders that know what they're doing. Share knowledge and improve processes</li>
						<li>Embrace change - open to additions, and design system to accommodate change (hard)</li>
						<li>Maintain simplicity - since there is a lack of good doucmentation, software must be simple and easy to understand for new members - "self commenting code" (lofty ideals)</li>
					</ul>
				</li>
				<li>
					Most companies spend more money on miantenance than actual development. Since agile prioritised development over documentation, this can be difficult to pick up and maintain later on. 
				</li>
				<li>
					Very flexible to requirements changes <b>provided</b> it's the original team doing it. Team losses hit harder in agile. 
				</li>
				<li>
					It is possible to mix plan-based and agile and pick and choose. 
				</li>
			</ul>

			<p><b>Extreme Programming</b></p>

			<ul>
				<li>
					Incremental delivery with fast iterations. Automated tests to verify builds. 
				</li>
				<li>
					Code refactored constantly to maintain simplicity. Strong customer involvement, deliveries every few weeks.
				</li>
				<li>
					<figure><img src="./extreme-programming.png" alt="" style="max-width: 420px;"></figure>
					
				</li>
				<li>
					Impractical if customer slow or hard to reach.
				</li>
				<li>
					Incremental planning: requirements on <b>"story cards"</b>, which are selected for inclusion based on priority. 
				</li>
				<li>
					Small releases: minimum functionality for release, with more stuff for future releases.
				</li>
				<li>
					Simple design: only enough design to meet customer requirements, maintaining expandability - this is HARD
				</li>
				<li>
					Test-driven development: write the tests for the feature before writing the feature to match the tests.
				</li>
				<li>
					Refactoring: constantly refactor to improve code
				</li>
				<li>
					Pair programming: work in pairs, one coding and the other checking and providing support. regularly swap.
				</li>
				<li>
					Collective ownership: more than 2 people responsible for any one part of the codebase. 
				</li>
				<li>
					Continuous integration: integrate as soon as feature done
				</li>
				<li>
					But also Sustainiable pace: avoid large amounts of overtime and overwork.
				</li>
				<li>
					Onsite customer: have a customer rep on site for minimal response delay.
				</li>
				<li>
					Extreme programming is very agile, but has the drawbacks of it too. Best suited for small, experienced teams.
				</li>
			</ul>

			<p><b>Scrum</b></p>

			<ul>
				<li>
					General method focused on iterative process, with three stages
					<ol>
						<li>Planning stage - general goals</li>
						<li>Sprint cycle - each cycle is an implementation, 2-4 weeks but it varies<figure><img src="./scrumcycle.png" alt="" style="max-width: 240px;"></figure></li>
						<li>Project closure</li>
					</ol>
					
				</li>
				<li>
					There are daily meetings for progress.
				</li>
				<li>
					Select the features needed with the customer, but build in isolation. The <b>scrum master</b> (i.e. team leader) interfaces between team and customer
				</li>
				<li>
					Work is reviewed and presented at end of sprint cycle. 
				</li>
			</ul>

		</div>

		<div class="colourband">
			<h2 id="reqanal">Requirements Analysis</h2>
		</div>

		<div class="cbox">
			<ul>
				<li>
					Requirements are descriptions of what program <b>should and shouldn't do</b>. This enables devs to fulfil customer needs, and provides a basis for tests, requirements, and analysis.
				</li>
				<li>
					2 parts: <b>what</b> is going to be built, and <b>how</b> is it going to be built. 
				</li>
				<li>
					Requirements bridge customer & developer, should be customer understandable, or at least
				</li>
				<li>
					Have <b>two</b> requiremetns docs, a "C-facing" (customer facing) and a "D-facing" (dev facing), with differing amounts of technical detail. C-facing is usually written first. Crucially, there are no differences in requirements between the two.
				</li>
				<li>
					Requirements should be specific and measureable. Not vague. Be aware of changing requirements. 
				</li>
				<li>
					<table>
						<tr>
							<th>C-facing reqs</th>
							<th>D-facing reqs</th>
						</tr>
						<tr>
							<td><ul><li>System from user view</li><li>how it works in natural language</li><li>diagrams are always nice</li><li>list of constraints in operation</li></ul></td>
							<td><ul><li>Detailed descriptions of functionality</li><li>Language, service, protocols, libraries, etc</li><li>Defines exactly waht must be implemented</li></ul></td>
						</tr>
					</table>
				</li>
				<li>
					The whole req doc must be: prioritised, consistent, modifiable, traceable (i.e. know where req came from, justification)
				</li>
				<li>
					Each requirement must be: correct, feasible, necessary, unambiguous, verifiable
				</li>
				<li>
					The <b>MoSCoW</b> order of priority is often used: <b>Must, Should, Could, Won't</b>, but there is an argument that if a requirement is "Won't", don't put it there in the first place?
				</li>
				<li>
					Requirements elicitation requires interaction with stakeholders, and gather information about the project. Think through the conficts of interest. Then, get clarifications, go through 'em with a fine-toothed comb, and finally write down the document after finalising.
				</li>
			</ul>
		</div>

		<div class="colourband">
			<h2 id="teamorg">Team Organisation</h2>
		</div>

		<div class="cbox">
			<ul>
				<li>
					The <b>project manager</b> makes sure everything is running smoothly and on time. 
					<ul>
						<li>
							They are arguably the most stressful role, and is often the least technical and most people-oriented role.
						</li>
						<li>
							They must track progress and help solve stuck situations, plan the project development.
						</li>
						<li>
							They must manage the team, chase people up about work, etc. 
						</li>
						<li>
							And consider risks (to development or to team) and mitigations -- risk assessments. Considering when to sacrifice features if necessary.
						</li>
					</ul>
				</li>
				<li>
					The <b>business analyst</b> looks at organisational context of the project. 
					<ul>
						<li>
							They identify stakeholders, activities, processes, etc
						</li>
						<li>
							And understand the stakeholders' requirements. They do the requirements elicitation and documentation. Make sure everything is traceable and justified. 
						</li>
					</ul>
				</li>
				<li>
					These guys must also: Review the test plan -- a good test plan can identify mistakes even before development, such as incompatibilities between modules. Bugs and defects should be triaged and prioritised.
				</li>
				<li>
					Supervise project installation, deal with the "day 1 live trauma", and hand over software, and perhaps manage maintenance and support. 
				</li>
				<li>
					Reflect over what did well, what did poorly when closing down project. Archive and seal documentation. 
				</li>
				<li>
					Reward and recognise people for their achievements. 
				</li>
				<li>
					Throughout, accountability for code is important. Use version control, <code>git blame</code> exists for a reason. Git is good.
				</li>
			</ul>
		</div>

		<div class="colourband">
			<h2 id="design">System Design</h2>
		</div>

		<div class="cbox">
			<h3>Contents</h3>

			<ol>
				<li><a href="#dev-1">System Modelling</a></li>
				<li><a href="#dev-2">UML in more detail</a></li>
			</ol>

			<h3 id="dev-1">System Modelling</h3>

			<ul>
				<li>
					System design is supplemented by mathematical/logical <b>system modelling</b> diagrams, which 
				</li>
				<li>
					clarify fuctionality, provide a <b>basis</b> for development, and inform design approaches and component level decisions.
				</li>
				<li>
					<b>UML</b> - Unified Modelling Language - is a set of formal representations which help with the 4 "perspectives":
					<ul>
						<li>
							<b>External</b> -- context of system, interaction systems
						</li>
						<li>
							<b>Interaction</b> -- how people interact with the software, what is accessed by who, what is internal
						</li>
						<li>
							<b>Structural</b> -- layout, core features, class organisatiom
						</li>
						<li>
							<b>Behavioural</b> -- dynamic behaviour, algorithms and processes reacting to external or internal interactions.
						</li>
					</ul>
				</li>
				<li>
					UML has two subsections (views): <b>static / structural;</b> and <b>behavioural</b>. 
				</li>
				<li>
					Within these views are different types of diagrams, like class diagrams, sequence diagrams, use case diagrams, activity ", state machines, sequence ".
				</li>
			</ul>

			<h3 id="dev-2">UML in more detail</h3>

			<p>
				<b>Class diagrams</b> (static): most common type of diagram, shows the entites within a system and their relations. Obviously most suited to OOP.
			</p>
			<ul>
				<li>
					Entities can be identified through 
					<ul>
						<li>A grammatical approach, where they are extracted from a description of requirements</li>
						<li>Tangible things in application domain</li>
						<li>Behavioural approach, thinking about how entities will interact</li>
						<li>Scenario-based, objects and methods from scenarios</li>
					</ul>
				</li>
				<li>
					<figure><img src="./classidagram.png" alt=""></figure>
				</li>
			</ul>

			<p>
				<b>Activity Diagrams</b> (behaviour): kinda like a flowchart really. Note that decision doesn't have anything written inside it.
			</p>
			<figure><img src="./activitydiagram.png" alt="" style="max-width: 630px;"></figure>

			<p>
				<b>Use case diagrams</b>: how different events interact with other events. 
			</p>
			<figure><img src="./usecasediagm.png" alt="" style="max-width: 630px;"></figure>

			<p>
				<b>Sequence Diagrams:</b> to show <i>temporal</i> interaction -- how a system's interactions go over time.
			</p>
			<figure><img src="./sequenceidamg.png" alt="" style="max-width: 630px;"></figure>
			<ul>
				<li>
					Participants are objects or entites. 
				</li>
				<li>
					Each diagram always starts with a <b>call out arrow</b>, showing external prompting. Messages passed are shown in arrows. Time is not to scale. 
				</li>
				<li>
					Labels take the form of <code>name:Object</code> for a named object, <code>:Object</code> for an anonymous object, and <code>name</code> for a named unknown class.
				</li>
				<li>
					If an object calls itself, we need to nest a bar inside a bar. Loops and ifs are done with labelled boxes.
					<figure><img src="./seqdiag2.png" alt="" style="max-width: 310px;"></figure>
				</li>
				<li>
					Don't model a whole system on them - they're ugly and ungainly, best used for subsystems.
				</li>
			</ul>
		</div>

		<div class="colourband">
			<h2 id="proj-manage">Project Management</h2>
		</div>

		<div class="cbox">

			<h3>Contents</h3>

			<ol>
				<li><a href="#pro-1">Why Projects Fail</a></li>
				<li><a href="#pro-2">Risk Management</a></li>
				<li><a href="#pro-3">Project Management</a></li>
			</ol>

			<h3 id="pro-1">Why Projects Fail</h3>

			<p>
				Very few projects succeed, why is this so? Well, there are a multitude of reasons, amongst them poor planning, requirements changing too much, high turnover, unrealistic deadlines, poor testing, and so on and so forth. 
			</p>
			<p>
				Project management is essential to making sure constraints are kept, to
				<ol>
					<li>Deliver software on time</li>
					<li>Keep costs within budget</li>
					<li>Deliver software that meets expectations</li>
					<li>Maintain morale and productivity of team</li>
				</ol>
			</p>
			<p>
				Team success depends on three generic factors:
				<ol>
					<li>People: a mix of people with different motivations and skillsets</li>
					<li>Organisation: individuals must be given opportunity to contribute</li>
					<li>Communication: technical and managerial communication is essential</li>
				</ol>
				And four people factors:
				<ol>
					<li>Consistency: not making people feel undervalued</li>
					<li>Respect: everyone has equal opportunity to contribute</li>
					<li>Inclusion: all views should be considered (regardless of heirarchy)</li>
					<li>Honesty: faking it will backfire unless you actually make it</li>
				</ol>
			</p>
			<p>
				People are motivated through satisfaction of their needs (something something heirarchy of needs).
			</p>
			<p>
				Heirarchy is still important. Should the PM be the Tech lead? Or should it be someone else? Who will interact with stakeholders? How do we integrate people who are not in the same location? How can knowledge be shared?
			</p>
			<p>
				Group organisation can be informal or heirarchical:
				<ul>
					<li><b>Informal:</b> No strict heirarchy, decisions made by consensus. Can be successful if griup is highly competent.</li>
					<li><b>Heirarchical:</b> Defined leaders and management levels. Can work well in breaking down and delegating subproblems. Best when responsibilities are clear.</li>
				</ul>
			</p>
			<p>
				A cohesive team can establish their own quality standards, and actually follow them. Individuals will learn from and support each other, and people tend to work better.
			</p>

			<h3 id="pro-2">Risk Management</h3>

			<h4>Identification</h4>

			<p>
				Risks can be grouped into what areas they affect. <b>Project risks</b> affect the schedule or resources of the entire project. <b>Product risks</b> affect the final quality of the product. <b>Business risks</b> affect the organisation. Some risks can fall into multiple categories.
			</p>
			<p>
				<b>Project Risks</b> include staff turnover, management change, hardware unavailability, requirements change, etc.
			</p>
			<p>
				<b>Prduct Risks</b> include tool/library underperformance, the aforementioned requirements change, specification delays, size/complexity underestimates, etc.
			</p>
			<p>
				<b>Business Risks</b> include technology changes and deprecation, product competition, etc.
			</p>
			<p>
				There can be even finer category groups: such as Technology Risks, People Risks, Organisational Risks, Tool Risks, Requirements Risks and Estimation Risks.
			</p>

			<h4>Analysis</h4>

			<p>
				Consider each risk and its severity, this can then be grouped and <b>prioritised</b>
			</p>
			<p>
				For example, you could have a rating Insignificant/Tolerable/Serious/Catastrophic. 
			</p>

			<h4>Contingency</h4>

			<p>
				Once you have a prioritised risk list, a contingency plan for each risk must be made. First is <b>avoidance</b>: aim to reduce the chance of the risk even becoming reality, then comes <b>minimisation:</b> reducing damage if it goes wrong, and finally <b>contingency plans:</b> what to do if risk does occur.
			</p>
			<p>
				This all goes into a risk assessment / risk register, which can be a docuemnt, or on a management platform, but somewhere accessible to management.
			</p>

			<h3 id="pro-3">Project Management</h3>

			<p>
				The planning documents of a project should communicate all ideas, contingencies, organisation, etc to both the developers and the stakeholder. 
			</p>
			<p>
				Planning has three stages: (1) Proposal / pitch / bidding phase, (2) startup phase, and (3) periodic planning.
			</p>
			<figure>
				<img src="./proj-plannign.png" alt="" style="max-width: 630px;">
			</figure>

			<p>
				Scheduling is done through <a href="https://simple.wikipedia.org/wiki/Gantt_chart">Gantt Charts</a>, and critical path analysis algorithms for scheduing which tasks go first. 
			</p>
			<p>
				Estimation of costs and schedule however is really very easier said than done, 
				<ul>
					<li>It often comes down to experience as to how to schedule a project correctly,</li>
					<li>Or using some sort of algorithm to guesstimate the schedule.</li>
				</ul>
			</p>
			<p>
				Success is measured against how well the project meets the spec and existing expectations.
			</p>

		</div>

		<div class="colourband">
			<h2 id="implementation">Implementation</h2>	
		</div>

		<div class="cbox">
			<h3>Contents</h3>

			<ol>
				<li><a href="#imp-1">Design Patterns</a></li>
				<li><a href="#imp-2">Creational Patterns</a></li>
				<li><a href="#imp-3">Structural Patterns</a></li>
				<li><a href="#imp-4">Behavioural Patterns</a></li>
			</ol>

			<h3 id="imp-1">Design Patterns</h3>

			<ul>
				<li>
					<b>Design Patterns</b> are solutions to common programming problems. They're modular blocks designed to make code more flexible, a design structure that achieves a purpose. You see them a lot in OOP, where most enterprise code is.
				</li>
				<li>
					Design patterns all have 4 aspects: a meaninngful name, a description of the problem to solve, the solution, and a statement of the drawbacks.
				</li>
				<li>
					They are generic blueprints, and it takes experience to know when to use them in the correct situations. 
				</li>
			</ul>

			<h3 id="imp-2">Creational Patterns</h3>
			<h4>Factories</h4>
			<ul>
				<li>
					Creational Pattrns help with reducing the tedium of creating objects. 
				</li>
				<li>
					Imagine a bicycle race: 
					<pre><code class="lang-java">class Race {
	public Race createRace() {
		Frame frame1 = new Frame();
		Wheel frontWheel1 = new Wheel();
		Wheel rearWheel1 = new Wheel();
		Bike bike1 = new Bike(frame1, frontWheel1, rearWheel1);
		// repeat for every single other bike in the race...
	}</code></pre>
				</li>
				<li>
					This is <i>bloody tedius</i>. Plus if we were to extend from race:
					<pre><code class="lang-java">class TourDeMartinique extends Race {
	public Race createRace() {
		// we need regulation bikes
		// so we have to go through the whole rigamarole again of bike creation...
		Frame frame1 = new RegulationFrameEx007();
		Wheel frontWheel1 = new RegulationWheel1800F();
		Wheel rearWheel1 = new RegulationWheel1800F();
		Bike bike1 = new Bike(frame1, frontWheel1, rearWheel1);
		// ...
	}</code></pre>
					it makes things even worse. Worse still, if we need to change something, then we would have to update the whole thing, which is error prone.
				</li>
				<li>
					Instead, let's have methods which create objects for us, so we can have object creation all in one place -- this is the <b>factory method</b>
					<pre><code class="lang-java">class TourDeMartinique extends Race {
	Frame createFrame() { return new RegulationFrameEx007(); }
	Wheel createWheel() { return new RegulationWheel1800F(); }
	Bike createBike(Frame frame, Wheel front, Wheel back) {
		return new Bike(frame, front, back);
	}
}</code></pre>
					especially helpful if these common method signatures are implemented in the Race class.
				</li>
				<li>
					We could even pull this into its own class - a <b>factory class</b>.
					<pre><code class="lang-java">class BicycleFactory {
	Frame createFrame() { ... }
	Wheel createWheel() { ... }
	Bike createBike(Frame frame, Wheel front, Wheel back) { ... }
	Bike createDefaultBike() { ... }
	// etc.
}</code></pre>
				</li>
				<li>
					It's a way to get around the limitations of statically typed OOP constructors.
				</li>
				<li>
					Advantages:
					<ul>
						<li>Cutting down on repeated code</li>
						<li>Adding new variations, scenarios is easier</li>
						<li>Making changes is easier</li>
						<li>Easier to test</li>
					</ul>
				</li>
				<li>
					Disadvantages:
					<ul>
						<li>Lots of boilerplate classes</li>
						<li>Factory is linked to its produced class, thus when we update that class, we must update all the factories -- still some sort of cascading update.</li>
					</ul>
				</li>
			</ul>

			<h4>Builders</h4>

			<ul>
				<li>
					When an object has many attributes, especially when you want to just forget about some of them, writing constructors is hard. We'd need to consider all the variations of what we want, what constructors we need, and if there are like two dozen different attributes, <i>wah</i>.
				</li>
				<li>
					<b>Builders</b> are the pattern to help with this issue. Builders abstract a constructor into a series of substeps, each of which "builds" an individual component, and the object is created with a final <code>build</code> call.
					<pre><code class="lang-java">abstract class HouseBuilder {
	abstract void buildWindows();
	abstract void buildDoors();
	abstract void buildWalls(); 
	abstract void buildRooms();
}</code></pre>
				</li>
				<li>
					Builders are not factories, they are more flexible, and designed for large classes with many optional parameters. Their goal is to avoid long tedius constructors.
				</li>
				<li>
					(Note: Lombok for java has the annotation <code class="lang-java">@Builder</code>)
				</li>
				<li>
					Advantages:
					<ul>
						<li>More control over construction</li>
						<li>Can reuse construction code for different instances</li>
						<li><b>Single responsibility principle</b> one bit of code responsible for one thing. One place deals with construction.</li>
					</ul>
				</li>
				<li>
					Disadvantages:
					<ul>
						<li>Like factories, needs large number of new classes and boilerplate</li>
						<li>Code becomes longer, construction still complex, just modular now!</li>
					</ul>
				</li>
			</ul>

			<h4>Prototypes</h4>

			<ul>
				<li>
					Another object construction method, where we create a <b>prototype object</b> and then <b>clone</b> it. e.g.
					<pre><code class="lang-java">class Bike {
	Object clone() { ... }
    // ...
}</code></pre>
<pre><code class="lang-java">class Race {
	Bike prototye;

	public Race(Bike prototype) {
		this.prototype = prototype;
	}

	public Race createRace() {
		Bike b1 = (Bike) prototype.clone();
		//...
	}
}</code></pre>
				</li>
				<li>
					Advantages:
					<ul>
						<li>Don't need to make another subclass just to create an object</li>
						<li>Remove heavy initialisation for cloning</li>
						<li>Produce complex objects easily</li>
						<li>Keep class heirarchy simple</li>
					</ul>
				</li>
				<li>
					Disadvantages:
					<ul>
						<li>Circular references are difficult</li>
						<li>Might still have to do heavy update code on cloned objects</li>
					</ul>
				</li>
			</ul>

			<h3 id="imp-3">Structural Patterns</h3>

			<h4>Proxy Pattern</h4>

			<ul>
				<li>
					The proxy pattern allows us to create <b>placeholders</b> for other objects. 
				</li>
				<li>
					Reference an entity without having to load the entire thing (such as in previews)
				</li>
				<li>
					Used for anything which needs a "load on demand"
				</li>
				<li>
					<button class="collapsible nul">Image Proxy Example... </button>
					<div class="ccontent cnul">
						<pre><code class="lang-java">public interface Graphic {
	void draw();
}

public class ImageProxy implements Graphic {
	private String fileName;
	private Image content;

	public ImageProxy(String fileName) {
		this.fileName = fileName;
		content = null;
	}

	public void draw() {
		// only load the content when it is needed 
		if (content == null) content = new Image(fileName);
		// the actual image class will have a draw function
		content.draw();
	}
}</code></pre>
					</div>
				</li>
				<li>
					There are many different types of proxy, like:
				</li>
				<li>
					<b>Virtual Proxy</b> (lazy initialisation): for something that is resource heavy, put off loading until last minute.
				</li>
				<li>
					<b>Protection Proxy</b>: provides access control to object.
				</li>
				<li>
					<b>Remote Proxy:</b> offers functionality which is off-site, and handles all networking.
				</li>
				<li>
					<b>Logging Proxy:</b> to keep track of accesses and requests on the side.
				</li>
				<li>
					<b>Caching Proxy:</b> save contents/results of object for a short time, useful if object is computationally or networkly intensive.
				</li>
				<li>
					<b>Smart Referencing:</b> essentially garbage collection.
				</li>
				<li>
					Advantages:
					<ul>
						<li>Can hide away parts of service object</li>
						<li>Allows to manage object life cycle</li>
						<li>Proxy provides availability even if object not available</li>
						<li>New proxies can be made without changing service</li>
					</ul>
				</li>
				<li>
					Disadvantages:
					<ul>
						<li>Added complexity</li>
						<li>Adds another step in getting response -- overhead concerns</li>
					</ul>
				</li>
			</ul>

			<h4>Decorator Pattern</h4>

			<ul>
				<li>
					Suppose we want to have an object that does multiple things. Say, we have a message bot, that needs to send to several different platforms at once. Well, given a base <code>Message</code> class, for each platform we would have to subcass: <code>FacebookMessage</code>, <code>TwitterMessage</code>, <code>DiscordMessage</code>, etc, etc.
				</li>
				<li>
					But what if we want to send to multiple at once? Then we'd need to do all the combinations and ... 
				</li>
				<li>
					Wah.
				</li>
				<li>
					<b>Decorators</b> are a way around this, by wrapping objects so they can have dynamic behaviour at runtime. They're the <code>@Data</code> type things you see in Java. 
				</li>
				<li>
					A wrapper is an outside "packaging class" that has all the functionality of the inner class, but will do some extra logic before calling original methods. 
				</li>
				<li>
					At runtime, we can now check what options the client has picked, and wrap our message object in all the necessary decorators.
				</li>
				<li>
					Decorators and Proxies are very similar in method, but are there for different things.
				</li>
				<li>
					Advantages:
					<ul>
						<li>
							Extend behaviour without adding several subclasses
						</li>
						<li>Responsibilities become dynamic at runtime</li>
						<li>Combinable, unlike subclasses</li>
						<li>Promotes single responsibility</li>
					</ul>
				</li>
				<li>
					Disadvantages:
					<ul>
						<li>Removing wrappers later is difficult</li>
						<li>Hard to implement in a way that isn't order dependent</li>
						<li>Initial code layout can look messy - having used Spring... <i>can</i> bloody confirm.</li>
					</ul>
				</li>
			</ul>

			<h4>Adaptor</h4>

			<ul>
				<li>
					As name implies, allows output from one object to be used by another. 
				</li>
				<li>
					If we update a class that is used everywhere, we would need to make sweeping changes across entire code base, which is really error prone and hard to do. Alternatively, stick an adaptor between the object and everything else.
				</li>
				<li>
					Advantages:
					<ul>
						<li>Promotes single responsibility</li>
						<li>New adaptors can be introduced without heavy refactoring</li>
					</ul>
				</li>
				<li>
					Disadvantages:
					<ul>
						<li>Increased code complexity</li>
						<li>Depending on size of codebase, converting original object might just be easier</li>
					</ul>
				</li>
			</ul>

			<h4>Flyweight</h4>

			<ul>
				<li>
					The above is all about wrapping objects to add more functionality.
				</li>
				<li>
					What if we don't want to do that, rather just rearrange the objects so they're nicer?
				</li>
				<li>
					The <b>flyweight</b> pattern is a design pattern that allows us to get more objects in memory. They work best when objects share common properties which are also huge in size.
				</li>
				<li>
					Essentially: find all the data that is the same over a bunch of objects, and just extract that into a static class.
				</li>
				<li>
					<button class="collapsible nul">Flyweight Example... </button>
					<div class="ccontent cnul">
						<p>
							Suppose we have this NPC:
						</p>
						<pre><code class="lang-java">class Orc {
    String name;
	int health;
	Weapon weapon;
	NPCAI style;
	Map texture;

	// methods...
}</code></pre>
						<p>
							But the texture map is huge, because this is a really detailed game. If every orc has its own copy, we can't store many of them. But this texture is common to all orcs (as well as a few other things), so might as well split this into
						</p>
						<pre><code class="lang-java">class OrcData {
	static NPCAI style;
	static Map texture;
	static Weapon weapon;
}

class Orc {
	String name;
	int health;
	OrcData data;
}</code></pre>
						<p>
							And so now we only store <b>one</b> copy of <code>OrcData</code>.
						</p>
					</div>
				</li>
				<li>
					Advantages: Saves memory, potentially drastically
				</li>
				<li>
					Disadvantages:
					<ul>
						<li>Some data may need to be recalculated every call -- saving memory for increased compute time</li>
						<li>Complex code</li>
					</ul>
				</li>
			</ul>

			<h3 id="imp-4">Behavioural Patterns</h3>

			<ul>
				<li>
					Concerned with how objects communicate. Majority of object's behaviour is communication.
				</li>
				<li>
					Object can eithe change its own internal state, or interact by passing data to another object. The latter is what we care about.
				</li>
			</ul>

			<h4>Iterator Patterns</h4>

			<ul>
				<li>
					I think we've all used these? All default java data structures implement <code>Iterator</code> so we can do <code class="lang-java">for (Object i : listOfObjects) { ... }</code>
				</li>
				<li>
					Advantages:
					<ul>
						<li>Single responsibility principle</li>
						<li>New iterators can be introduced without heavy redesigns</li>
						<li>Iterate multiple ways in parallel</li>
						<li>Can even pause iteration and carry on later</li>
					</ul>
				</li>
				<li>
					Disadvantages:
					<ul>
						<li>Not always necessary</li>
						<li>Less effective for highly specialised objects</li>
					</ul>
				</li>
			</ul>

			<h4>Observer patterns</h4>

			<ul>
				<li>
					Allows an object's dependents to be automatically notified of a change.
				</li>
				<li>
					This can work as a <b>push model</b> (sender sends) or a <b>pull model</b> (receiver periodically asks).
				</li>
				<li>
					Often referred to as Producer/Consumer or Publisher/Subscriber.
				</li>
				<li>
					On the producer side, subscribers should be able to be added and removed from notification lists. Can have a different notification method for each type of notification publisher sends. Then, when the event occurs, iterate through all subscribed and send.
				</li>
				<li>
					This way removes the need for subscribers to constantly check - busy waiting is bad and is a waste of resources.
				</li>
				<li>
					Subscriber lists must be <b>opt-in</b>.
				</li>
				<li>
					By maintaining lists we reduce the number of subscribers that need to receive data and do not bother the rest of the system unnecessarily.
				</li>
				<li>
					Advantages:
					<ul>
						<li>New subs can be added without needing to redesign publisher</li>
						<li>Relationships between objects can change at runtime</li>
					</ul>
				</li>
				<li>
					Disadvantages:
					<ul>
						<li>Subscribers notified in possibly random order</li>
					</ul>
				</li>
			</ul>

			<h4>Memento Pattern</h4>

			<ul>
				<li>
					Save and Restore objects without revealing details of implementation.
				</li>
			</ul>

		</div>
		

		<footer>
			<div class="cbox">
                <div class="columncontainer ctwo" id="fc2">
                </div>
                <script type="text/javascript" src="../../js/footerGen.js"></script>
            </div>
		</footer>

	</div>

	<script type="text/javascript" src="../../js/collapsible.js"></script>  <!--This stays at the end-->
	<script type="text/javascript" src="../../js/toggle-darklight.js"></script>
	<script type="text/javascript" src="../../js/prism.js"></script>
</body>
</html>