<!DOCTYPE html>
<html>
<head>
	<title>CS261</title>
	<meta charset="utf-8">
	<link rel="stylesheet" type="text/css" href="../../style/style.css" media="all">  <!--TODO: CHANGE HREF-->
	<link rel="stylesheet" type="text/css" href="../../style/prism.css" media="all">
	<meta name="viewport" content="width=device-width" initial-scale=1.0>  <!--TODO: CHANGE LINKS ON BOTTOM OF SHEET FOR COLLAPSIBLE-->
	<link rel="icon" type="image/png" href="../../style/images/DragonIcon.png">
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>

	<div class="hidden">
		<header>
			<div class="parallax parsmaller">
				<div  style="display: grid; grid-template-columns: 1fr 1fr 1fr 8fr 1fr; grid-column-gap: 10px; padding: 5px; ">
					<div class="column tinycolumn">
						<a href="../../" class="nav">Home</a>
					</div>
					<div class="column tinycolumn">
						<a href="../../blog.html" class="nav">Blog</a>
					</div>
					<div class="column tinycolumn">
						
						<a href="../../about.html" class="nav">About</a>
					</div>
					<div></div>
					<div class="column">
						<button class="nav dark-light">Dark Mode</button>
					</div>
				</div>
				<div class="cbox"> 		
					<h1>CS261</h1>
					<p class="subheading">Software Engineering (wah)</p>
				</div>
			</div>
		</header>

		<header>
			<div class="cbox">
				<h1>Contents</h1>
			</div>
		</header>

		<div class="cbox">
			<ol>
				<li><a href="#dev">Software Development Methodologies</a></li>
				<li><a href="#reqanal">Requirements Analysis</a></li>
				<li><a href="#teamorg">Team Organisation</a></li>
				<li><a href="#design">System Design</a></li>
				<li><a href="#proj-manage">Project Management</a></li>
				<LI><a href="#implementation">Implementation</a></LI>
				<li><a href="#hci">Human Computer Interaction</a></li>
				<li><a href="#dependability">Dependability</a></li>
			</ol>
		</div>

		
		<div class="colourband">
			<h2 id="dev">Software Development Methodologies</h2>
		</div>

		<div class="cbox">
			<h3>Introduction</h3>

			<ol>
				<li><a href="#dev-1">Plan-Driven</a></li>
				<li><a href="#dev-2">Software Spec</a></li>
				<li><a href="#dev-3">Agile</a></li>
			</ol>

			<ul>
				<li>
					Different Systems need different processes.
				</li>
				<li>
					All processes involve some sort of specification, design and implementation, testing, and evolution (maintaining)
				</li>
				<li>
					Two main types of development: plan driven and agile
				</li>
				<li>
					Plan driven: everything is planned and fixed in advance. Inflexible.
				</li>
				<li>
					Agile: Incremental planning, more adaptable to change.
				</li>
			</ul>

			<h3 id="dev-1">Plan-Driven</h3>

			<p>
				<b>Waterfall Model</b>
			</p>
			<ul>
				<li>
					Invented in 1970, strictest of all plan driven models. 
				</li>
				<li>
					If a change is required, the waterfall model must restart. Incredibly inflexible and in practice not completely followed. 
					<figure>
						<img src="https://www.umsl.edu/~hugheyd/is6840/images/Waterfall_model.png" alt="" style="max-width: 300px;" title="Uni of Missouri">
					</figure>
				</li>
				<li>
					<b>Requirements:</b> most customer focused, involves identification of resources, distribution of work.
				</li>
				<li>
					<b>Design:</b> design document generated, should be really detailed so implementation is not hard.
				</li>
				<li>
					<b>Implementation:</b> only when design doc is finished. Everything written should be unit tested.
				</li>
				<li>
					<b>Verification/Integration:</b> Most group focused - putting all parts of system together, making sure they work.
				</li>
				<li>
					<b>Maintenance:</b> Hand over program and documentation. Offer maintenance, which is also done via waterfall.
				</li>
				<li>
					Waterfall is good when requirements are understood and will not change. Few constraints on location and teams size (development distributed and isolated) and each component can be first tested in isolation.
				</li>
				<li>
					Waterfall is not good as the client has to wait a long time for results, and changes are difficult to accommodate, and there is a problem of software tech deprecation over the entire years-long development timespan.
				</li>
			</ul>

			<p><b>Inremental Development</b> </p>

			<ul>
				<li>
					A more flexible system than waterfall.
					<figure><img src="https://i.stack.imgur.com/BqktJ.jpg" alt="" title="stackoverflow" style="max-width: 420px;"></figure>
				</li>
				<li>
					Each iteration is still planned like waterfall, spec updated between iterations (not rewritten).
				</li>
				<li>
					(+) cost of accomodating change much reduced, and user gets software quicker, feedback is easier to get -- better (perceived) value for money
				</li>
				<li>
					(+) user inclustion in acceptance testing, can even install system before the final version.
				</li>
				<li>
					(-) <b>very</b> difficult to estimate overall cost of development of such a system.
				</li>
				<li>
					(-) difficult to maintain consistency between versions - poor design choices early on hamper later feature additions. Spaghetti code. 
				</li>
			</ul>

			<p><b>Reuse-Oriented Sofware Engineering</b></p>

			<ul>
				<li>
					Why reinvent the wheel? Instead, many devs rely on "off-the-shelf" / open source premade components, and just writes the glue code to tack them together. <b>Common off the shelf (COTS) systems</b>.
				</li>
				<li>
					Compromises on features with client has to be made, but tradeoff is that program is banged out in record time. 
				</li>
			</ul>

			<h3 id="dev-2">Software Spec</h3>

			<ul>
				<li>
					To understand and define what services are required
				</li>
				<li>
					To identify limits in feasibility - "requirements engineering", producing requirements document. 
				</li>
				<li>
					<figure><img src="./requirements-doc.png" alt="" style="max-width: 630px;"></figure>
				</li>
			</ul>

			<h3 id="dev-3">Agile</h3>

			<ul>
				<li >
					Agile development is about <i>rapid</i> development: interleave spec, design, and implementation, and develop the system as a series of evolving prototypes. 
				</li>
				<li>
					Focus on code over design, develop as you go. Aim for speed, and flexibility. 
				</li>
				<li>
					Often has the short stand up meeting concept. 
				</li>
				<li>
					Major principles of Agile are
					<ul>
						<li>Customer involvement - cannot respond rapidly to changes without rapid feedback</li>
						<li>Incremental delivery - have prototypes, and update spec for next iterations</li>
						<li>People not process - have highly skilled coders that know what they're doing. Share knowledge and improve processes</li>
						<li>Embrace change - open to additions, and design system to accommodate change (hard)</li>
						<li>Maintain simplicity - since there is a lack of good doucmentation, software must be simple and easy to understand for new members - "self commenting code" (lofty ideals)</li>
					</ul>
				</li>
				<li>
					Most companies spend more money on miantenance than actual development. Since agile prioritised development over documentation, this can be difficult to pick up and maintain later on. 
				</li>
				<li>
					Very flexible to requirements changes <b>provided</b> it's the original team doing it. Team losses hit harder in agile. 
				</li>
				<li>
					It is possible to mix plan-based and agile and pick and choose. 
				</li>
			</ul>

			<p><b>Extreme Programming</b></p>

			<ul>
				<li>
					Incremental delivery with fast iterations. Automated tests to verify builds. 
				</li>
				<li>
					Code refactored constantly to maintain simplicity. Strong customer involvement, deliveries every few weeks.
				</li>
				<li>
					<figure><img src="./extreme-programming.png" alt="" style="max-width: 420px;"></figure>
					
				</li>
				<li>
					Impractical if customer slow or hard to reach.
				</li>
				<li>
					Incremental planning: requirements on <b>"story cards"</b>, which are selected for inclusion based on priority. 
				</li>
				<li>
					Small releases: minimum functionality for release, with more stuff for future releases.
				</li>
				<li>
					Simple design: only enough design to meet customer requirements, maintaining expandability - this is HARD
				</li>
				<li>
					Test-driven development: write the tests for the feature before writing the feature to match the tests.
				</li>
				<li>
					Refactoring: constantly refactor to improve code
				</li>
				<li>
					Pair programming: work in pairs, one coding and the other checking and providing support. regularly swap.
				</li>
				<li>
					Collective ownership: more than 2 people responsible for any one part of the codebase. 
				</li>
				<li>
					Continuous integration: integrate as soon as feature done
				</li>
				<li>
					But also Sustainiable pace: avoid large amounts of overtime and overwork.
				</li>
				<li>
					Onsite customer: have a customer rep on site for minimal response delay.
				</li>
				<li>
					Extreme programming is very agile, but has the drawbacks of it too. Best suited for small, experienced teams.
				</li>
			</ul>

			<p><b>Scrum</b></p>

			<ul>
				<li>
					General method focused on iterative process, with three stages
					<ol>
						<li>Planning stage - general goals</li>
						<li>Sprint cycle - each cycle is an implementation, 2-4 weeks but it varies<figure><img src="./scrumcycle.png" alt="" style="max-width: 240px;"></figure></li>
						<li>Project closure</li>
					</ol>
					
				</li>
				<li>
					There are daily meetings for progress.
				</li>
				<li>
					Select the features needed with the customer, but build in isolation. The <b>scrum master</b> (i.e. team leader) interfaces between team and customer
				</li>
				<li>
					Work is reviewed and presented at end of sprint cycle. 
				</li>
			</ul>

		</div>

		<div class="colourband">
			<h2 id="reqanal">Requirements Analysis</h2>
		</div>

		<div class="cbox">
			<ul>
				<li>
					Requirements are descriptions of what program <b>should and shouldn't do</b>. This enables devs to fulfil customer needs, and provides a basis for tests, requirements, and analysis.
				</li>
				<li>
					2 parts: <b>what</b> is going to be built, and <b>how</b> is it going to be built. 
				</li>
				<li>
					Requirements bridge customer & developer, should be customer understandable, or at least
				</li>
				<li>
					Have <b>two</b> requiremetns docs, a "C-facing" (customer facing) and a "D-facing" (dev facing), with differing amounts of technical detail. C-facing is usually written first. Crucially, there are no differences in requirements between the two.
				</li>
				<li>
					Requirements should be specific and measureable. Not vague. Be aware of changing requirements. 
				</li>
				<li>
					<table>
						<tr>
							<th>C-facing reqs</th>
							<th>D-facing reqs</th>
						</tr>
						<tr>
							<td><ul><li>System from user view</li><li>how it works in natural language</li><li>diagrams are always nice</li><li>list of constraints in operation</li></ul></td>
							<td><ul><li>Detailed descriptions of functionality</li><li>Language, service, protocols, libraries, etc</li><li>Defines exactly waht must be implemented</li></ul></td>
						</tr>
					</table>
				</li>
				<li>
					The whole req doc must be: prioritised, consistent, modifiable, traceable (i.e. know where req came from, justification)
				</li>
				<li>
					Each requirement must be: correct, feasible, necessary, unambiguous, verifiable
				</li>
				<li>
					The <b>MoSCoW</b> order of priority is often used: <b>Must, Should, Could, Won't</b>, but there is an argument that if a requirement is "Won't", don't put it there in the first place?
				</li>
				<li>
					Requirements elicitation requires interaction with stakeholders, and gather information about the project. Think through the conficts of interest. Then, get clarifications, go through 'em with a fine-toothed comb, and finally write down the document after finalising.
				</li>
			</ul>
		</div>

		<div class="colourband">
			<h2 id="teamorg">Team Organisation</h2>
		</div>

		<div class="cbox">
			<ul>
				<li>
					The <b>project manager</b> makes sure everything is running smoothly and on time. 
					<ul>
						<li>
							They are arguably the most stressful role, and is often the least technical and most people-oriented role.
						</li>
						<li>
							They must track progress and help solve stuck situations, plan the project development.
						</li>
						<li>
							They must manage the team, chase people up about work, etc. 
						</li>
						<li>
							And consider risks (to development or to team) and mitigations -- risk assessments. Considering when to sacrifice features if necessary.
						</li>
					</ul>
				</li>
				<li>
					The <b>business analyst</b> looks at organisational context of the project. 
					<ul>
						<li>
							They identify stakeholders, activities, processes, etc
						</li>
						<li>
							And understand the stakeholders' requirements. They do the requirements elicitation and documentation. Make sure everything is traceable and justified. 
						</li>
					</ul>
				</li>
				<li>
					These guys must also: Review the test plan -- a good test plan can identify mistakes even before development, such as incompatibilities between modules. Bugs and defects should be triaged and prioritised.
				</li>
				<li>
					Supervise project installation, deal with the "day 1 live trauma", and hand over software, and perhaps manage maintenance and support. 
				</li>
				<li>
					Reflect over what did well, what did poorly when closing down project. Archive and seal documentation. 
				</li>
				<li>
					Reward and recognise people for their achievements. 
				</li>
				<li>
					Throughout, accountability for code is important. Use version control, <code>git blame</code> exists for a reason. Git is good.
				</li>
			</ul>
		</div>

		<div class="colourband">
			<h2 id="design">System Design</h2>
		</div>

		<div class="cbox">
			<h3>Contents</h3>

			<ol>
				<li><a href="#dev-1">System Modelling</a></li>
				<li><a href="#dev-2">UML in more detail</a></li>
			</ol>

			<h3 id="dev-1">System Modelling</h3>

			<ul>
				<li>
					System design is supplemented by mathematical/logical <b>system modelling</b> diagrams, which 
				</li>
				<li>
					clarify fuctionality, provide a <b>basis</b> for development, and inform design approaches and component level decisions.
				</li>
				<li>
					<b>UML</b> - Unified Modelling Language - is a set of formal representations which help with the 4 "perspectives":
					<ul>
						<li>
							<b>External</b> -- context of system, interaction systems
						</li>
						<li>
							<b>Interaction</b> -- how people interact with the software, what is accessed by who, what is internal
						</li>
						<li>
							<b>Structural</b> -- layout, core features, class organisatiom
						</li>
						<li>
							<b>Behavioural</b> -- dynamic behaviour, algorithms and processes reacting to external or internal interactions.
						</li>
					</ul>
				</li>
				<li>
					UML has two subsections (views): <b>static / structural;</b> and <b>behavioural</b>. 
				</li>
				<li>
					Within these views are different types of diagrams, like class diagrams, sequence diagrams, use case diagrams, activity ", state machines, sequence ".
				</li>
			</ul>

			<h3 id="dev-2">UML in more detail</h3>

			<p>
				<b>Class diagrams</b> (static): most common type of diagram, shows the entites within a system and their relations. Obviously most suited to OOP.
			</p>
			<ul>
				<li>
					Entities can be identified through 
					<ul>
						<li>A grammatical approach, where they are extracted from a description of requirements</li>
						<li>Tangible things in application domain</li>
						<li>Behavioural approach, thinking about how entities will interact</li>
						<li>Scenario-based, objects and methods from scenarios</li>
					</ul>
				</li>
				<li>
					<figure><img src="./classidagram.png" alt=""></figure>
				</li>
			</ul>

			<p>
				<b>Activity Diagrams</b> (behaviour): kinda like a flowchart really. Note that decision doesn't have anything written inside it.
			</p>
			<figure><img src="./activitydiagram.png" alt="" style="max-width: 630px;"></figure>

			<p>
				<b>Use case diagrams</b>: how different events interact with other events. 
			</p>
			<figure><img src="./usecasediagm.png" alt="" style="max-width: 630px;"></figure>

			<p>
				<b>Sequence Diagrams:</b> to show <i>temporal</i> interaction -- how a system's interactions go over time.
			</p>
			<figure><img src="./sequenceidamg.png" alt="" style="max-width: 630px;"></figure>
			<ul>
				<li>
					Participants are objects or entites. 
				</li>
				<li>
					Each diagram always starts with a <b>call out arrow</b>, showing external prompting. Messages passed are shown in arrows. Time is not to scale. 
				</li>
				<li>
					Labels take the form of <code>name:Object</code> for a named object, <code>:Object</code> for an anonymous object, and <code>name</code> for a named unknown class.
				</li>
				<li>
					If an object calls itself, we need to nest a bar inside a bar. Loops and ifs are done with labelled boxes.
					<figure><img src="./seqdiag2.png" alt="" style="max-width: 310px;"></figure>
				</li>
				<li>
					Don't model a whole system on them - they're ugly and ungainly, best used for subsystems.
				</li>
			</ul>
		</div>

		<div class="colourband">
			<h2 id="proj-manage">Project Management</h2>
		</div>

		<div class="cbox">

			<h3>Contents</h3>

			<ol>
				<li><a href="#pro-1">Why Projects Fail</a></li>
				<li><a href="#pro-2">Risk Management</a></li>
				<li><a href="#pro-3">Project Management</a></li>
			</ol>

			<h3 id="pro-1">Why Projects Fail</h3>

			<p>
				Very few projects succeed, why is this so? Well, there are a multitude of reasons, amongst them poor planning, requirements changing too much, high turnover, unrealistic deadlines, poor testing, and so on and so forth. 
			</p>
			<p>
				Project management is essential to making sure constraints are kept, to
				<ol>
					<li>Deliver software on time</li>
					<li>Keep costs within budget</li>
					<li>Deliver software that meets expectations</li>
					<li>Maintain morale and productivity of team</li>
				</ol>
			</p>
			<p>
				Team success depends on three generic factors:
				<ol>
					<li>People: a mix of people with different motivations and skillsets</li>
					<li>Organisation: individuals must be given opportunity to contribute</li>
					<li>Communication: technical and managerial communication is essential</li>
				</ol>
				And four people factors:
				<ol>
					<li>Consistency: not making people feel undervalued</li>
					<li>Respect: everyone has equal opportunity to contribute</li>
					<li>Inclusion: all views should be considered (regardless of heirarchy)</li>
					<li>Honesty: faking it will backfire unless you actually make it</li>
				</ol>
			</p>
			<p>
				People are motivated through satisfaction of their needs (something something heirarchy of needs).
			</p>
			<p>
				Heirarchy is still important. Should the PM be the Tech lead? Or should it be someone else? Who will interact with stakeholders? How do we integrate people who are not in the same location? How can knowledge be shared?
			</p>
			<p>
				Group organisation can be informal or heirarchical:
				<ul>
					<li><b>Informal:</b> No strict heirarchy, decisions made by consensus. Can be successful if griup is highly competent.</li>
					<li><b>Heirarchical:</b> Defined leaders and management levels. Can work well in breaking down and delegating subproblems. Best when responsibilities are clear.</li>
				</ul>
			</p>
			<p>
				A cohesive team can establish their own quality standards, and actually follow them. Individuals will learn from and support each other, and people tend to work better.
			</p>

			<h3 id="pro-2">Risk Management</h3>

			<h4>Identification</h4>

			<p>
				Risks can be grouped into what areas they affect. <b>Project risks</b> affect the schedule or resources of the entire project. <b>Product risks</b> affect the final quality of the product. <b>Business risks</b> affect the organisation. Some risks can fall into multiple categories.
			</p>
			<p>
				<b>Project Risks</b> include staff turnover, management change, hardware unavailability, requirements change, etc.
			</p>
			<p>
				<b>Prduct Risks</b> include tool/library underperformance, the aforementioned requirements change, specification delays, size/complexity underestimates, etc.
			</p>
			<p>
				<b>Business Risks</b> include technology changes and deprecation, product competition, etc.
			</p>
			<p>
				There can be even finer category groups: such as Technology Risks, People Risks, Organisational Risks, Tool Risks, Requirements Risks and Estimation Risks.
			</p>

			<h4>Analysis</h4>

			<p>
				Consider each risk and its severity, this can then be grouped and <b>prioritised</b>
			</p>
			<p>
				For example, you could have a rating Insignificant/Tolerable/Serious/Catastrophic. 
			</p>

			<h4>Contingency</h4>

			<p>
				Once you have a prioritised risk list, a contingency plan for each risk must be made. First is <b>avoidance</b>: aim to reduce the chance of the risk even becoming reality, then comes <b>minimisation:</b> reducing damage if it goes wrong, and finally <b>contingency plans:</b> what to do if risk does occur.
			</p>
			<p>
				This all goes into a risk assessment / risk register, which can be a docuemnt, or on a management platform, but somewhere accessible to management.
			</p>

			<h3 id="pro-3">Project Management</h3>

			<p>
				The planning documents of a project should communicate all ideas, contingencies, organisation, etc to both the developers and the stakeholder. 
			</p>
			<p>
				Planning has three stages: (1) Proposal / pitch / bidding phase, (2) startup phase, and (3) periodic planning.
			</p>
			<figure>
				<img src="./proj-plannign.png" alt="" style="max-width: 630px;">
			</figure>

			<p>
				Scheduling is done through <a href="https://simple.wikipedia.org/wiki/Gantt_chart">Gantt Charts</a>, and critical path analysis algorithms for scheduing which tasks go first. 
			</p>
			<p>
				Estimation of costs and schedule however is really very easier said than done, 
				<ul>
					<li>It often comes down to experience as to how to schedule a project correctly,</li>
					<li>Or using some sort of algorithm to guesstimate the schedule.</li>
				</ul>
			</p>
			<p>
				Success is measured against how well the project meets the spec and existing expectations.
			</p>

		</div>

		<div class="colourband">
			<h2 id="implementation">Implementation</h2>	
		</div>

		<div class="cbox">
			<h3>Contents</h3>

			<ol>
				<li><a href="#imp-1">Design Patterns</a></li>
				<li><a href="#imp-2">Creational Patterns</a></li>
				<li><a href="#imp-3">Structural Patterns</a></li>
				<li><a href="#imp-4">Behavioural Patterns</a></li>
				<li><a href="#imp-5">SOLID</a></li>
			</ol>

			<h3 id="imp-1">Design Patterns</h3>

			<ul>
				<li>
					<b>Design Patterns</b> are solutions to common programming problems. They're modular blocks designed to make code more flexible, a design structure that achieves a purpose. You see them a lot in OOP, where most enterprise code is.
				</li>
				<li>
					Design patterns all have 4 aspects: a meaninngful name, a description of the problem to solve, the solution, and a statement of the drawbacks.
				</li>
				<li>
					They are generic blueprints, and it takes experience to know when to use them in the correct situations. 
				</li>
			</ul>

			<h3 id="imp-2">Creational Patterns</h3>
			<h4>Factories</h4>
			<ul>
				<li>
					Creational Pattrns help with reducing the tedium of creating objects. 
				</li>
				<li>
					Imagine a bicycle race: 
					<pre><code class="lang-java">class Race {
	public Race createRace() {
		Frame frame1 = new Frame();
		Wheel frontWheel1 = new Wheel();
		Wheel rearWheel1 = new Wheel();
		Bike bike1 = new Bike(frame1, frontWheel1, rearWheel1);
		// repeat for every single other bike in the race...
	}</code></pre>
				</li>
				<li>
					This is <i>bloody tedius</i>. Plus if we were to extend from race:
					<pre><code class="lang-java">class TourDeMartinique extends Race {
	public Race createRace() {
		// we need regulation bikes
		// so we have to go through the whole rigamarole again of bike creation...
		Frame frame1 = new RegulationFrameEx007();
		Wheel frontWheel1 = new RegulationWheel1800F();
		Wheel rearWheel1 = new RegulationWheel1800F();
		Bike bike1 = new Bike(frame1, frontWheel1, rearWheel1);
		// ...
	}</code></pre>
					it makes things even worse. Worse still, if we need to change something, then we would have to update the whole thing, which is error prone.
				</li>
				<li>
					Instead, let's have methods which create objects for us, so we can have object creation all in one place -- this is the <b>factory method</b>
					<pre><code class="lang-java">class TourDeMartinique extends Race {
	Frame createFrame() { return new RegulationFrameEx007(); }
	Wheel createWheel() { return new RegulationWheel1800F(); }
	Bike createBike(Frame frame, Wheel front, Wheel back) {
		return new Bike(frame, front, back);
	}
}</code></pre>
					especially helpful if these common method signatures are implemented in the Race class.
				</li>
				<li>
					We could even pull this into its own class - a <b>factory class</b>.
					<pre><code class="lang-java">class BicycleFactory {
	Frame createFrame() { ... }
	Wheel createWheel() { ... }
	Bike createBike(Frame frame, Wheel front, Wheel back) { ... }
	Bike createDefaultBike() { ... }
	// etc.
}</code></pre>
				</li>
				<li>
					It's a way to get around the limitations of statically typed OOP constructors.
				</li>
				<li>
					Advantages:
					<ul>
						<li>Cutting down on repeated code</li>
						<li>Adding new variations, scenarios is easier</li>
						<li>Making changes is easier</li>
						<li>Easier to test</li>
					</ul>
				</li>
				<li>
					Disadvantages:
					<ul>
						<li>Lots of boilerplate classes</li>
						<li>Factory is linked to its produced class, thus when we update that class, we must update all the factories -- still some sort of cascading update.</li>
					</ul>
				</li>
			</ul>

			<h4>Builders</h4>

			<ul>
				<li>
					When an object has many attributes, especially when you want to just forget about some of them, writing constructors is hard. We'd need to consider all the variations of what we want, what constructors we need, and if there are like two dozen different attributes, <i>wah</i>.
				</li>
				<li>
					<b>Builders</b> are the pattern to help with this issue. Builders abstract a constructor into a series of substeps, each of which "builds" an individual component, and the object is created with a final <code>build</code> call.
					<pre><code class="lang-java">abstract class HouseBuilder {
	abstract void buildWindows();
	abstract void buildDoors();
	abstract void buildWalls(); 
	abstract void buildRooms();
}</code></pre>
				</li>
				<li>
					Builders are not factories, they are more flexible, and designed for large classes with many optional parameters. Their goal is to avoid long tedius constructors.
				</li>
				<li>
					(Note: Lombok for java has the annotation <code class="lang-java">@Builder</code>)
				</li>
				<li>
					Advantages:
					<ul>
						<li>More control over construction</li>
						<li>Can reuse construction code for different instances</li>
						<li><b>Single responsibility principle</b> one bit of code responsible for one thing. One place deals with construction.</li>
					</ul>
				</li>
				<li>
					Disadvantages:
					<ul>
						<li>Like factories, needs large number of new classes and boilerplate</li>
						<li>Code becomes longer, construction still complex, just modular now!</li>
					</ul>
				</li>
			</ul>

			<h4>Prototypes</h4>

			<ul>
				<li>
					Another object construction method, where we create a <b>prototype object</b> and then <b>clone</b> it. e.g.
					<pre><code class="lang-java">class Bike {
	Object clone() { ... }
    // ...
}</code></pre>
<pre><code class="lang-java">class Race {
	Bike prototye;

	public Race(Bike prototype) {
		this.prototype = prototype;
	}

	public Race createRace() {
		Bike b1 = (Bike) prototype.clone();
		//...
	}
}</code></pre>
				</li>
				<li>
					Advantages:
					<ul>
						<li>Don't need to make another subclass just to create an object</li>
						<li>Remove heavy initialisation for cloning</li>
						<li>Produce complex objects easily</li>
						<li>Keep class heirarchy simple</li>
					</ul>
				</li>
				<li>
					Disadvantages:
					<ul>
						<li>Circular references are difficult</li>
						<li>Might still have to do heavy update code on cloned objects</li>
					</ul>
				</li>
			</ul>

			<h3 id="imp-3">Structural Patterns</h3>

			<h4>Proxy Pattern</h4>

			<ul>
				<li>
					The proxy pattern allows us to create <b>placeholders</b> for other objects. 
				</li>
				<li>
					Reference an entity without having to load the entire thing (such as in previews)
				</li>
				<li>
					Used for anything which needs a "load on demand"
				</li>
				<li>
					<button class="collapsible nul">Image Proxy Example... </button>
					<div class="ccontent cnul">
						<pre><code class="lang-java">public interface Graphic {
	void draw();
}

public class ImageProxy implements Graphic {
	private String fileName;
	private Image content;

	public ImageProxy(String fileName) {
		this.fileName = fileName;
		content = null;
	}

	public void draw() {
		// only load the content when it is needed 
		if (content == null) content = new Image(fileName);
		// the actual image class will have a draw function
		content.draw();
	}
}</code></pre>
					</div>
				</li>
				<li>
					There are many different types of proxy, like:
				</li>
				<li>
					<b>Virtual Proxy</b> (lazy initialisation): for something that is resource heavy, put off loading until last minute.
				</li>
				<li>
					<b>Protection Proxy</b>: provides access control to object.
				</li>
				<li>
					<b>Remote Proxy:</b> offers functionality which is off-site, and handles all networking.
				</li>
				<li>
					<b>Logging Proxy:</b> to keep track of accesses and requests on the side.
				</li>
				<li>
					<b>Caching Proxy:</b> save contents/results of object for a short time, useful if object is computationally or networkly intensive.
				</li>
				<li>
					<b>Smart Referencing:</b> essentially garbage collection.
				</li>
				<li>
					Advantages:
					<ul>
						<li>Can hide away parts of service object</li>
						<li>Allows to manage object life cycle</li>
						<li>Proxy provides availability even if object not available</li>
						<li>New proxies can be made without changing service</li>
					</ul>
				</li>
				<li>
					Disadvantages:
					<ul>
						<li>Added complexity</li>
						<li>Adds another step in getting response -- overhead concerns</li>
					</ul>
				</li>
			</ul>

			<h4>Decorator Pattern</h4>

			<ul>
				<li>
					Suppose we want to have an object that does multiple things. Say, we have a message bot, that needs to send to several different platforms at once. Well, given a base <code>Message</code> class, for each platform we would have to subcass: <code>FacebookMessage</code>, <code>TwitterMessage</code>, <code>DiscordMessage</code>, etc, etc.
				</li>
				<li>
					But what if we want to send to multiple at once? Then we'd need to do all the combinations and ... 
				</li>
				<li>
					Wah.
				</li>
				<li>
					<b>Decorators</b> are a way around this, by wrapping objects so they can have dynamic behaviour at runtime. They're the <code>@Data</code> type things you see in Java. 
				</li>
				<li>
					A wrapper is an outside "packaging class" that has all the functionality of the inner class, but will do some extra logic before calling original methods. 
				</li>
				<li>
					At runtime, we can now check what options the client has picked, and wrap our message object in all the necessary decorators.
				</li>
				<li>
					Decorators and Proxies are very similar in method, but are there for different things.
				</li>
				<li>
					Advantages:
					<ul>
						<li>
							Extend behaviour without adding several subclasses
						</li>
						<li>Responsibilities become dynamic at runtime</li>
						<li>Combinable, unlike subclasses</li>
						<li>Promotes single responsibility</li>
					</ul>
				</li>
				<li>
					Disadvantages:
					<ul>
						<li>Removing wrappers later is difficult</li>
						<li>Hard to implement in a way that isn't order dependent</li>
						<li>Initial code layout can look messy - having used Spring... <i>can</i> bloody confirm.</li>
					</ul>
				</li>
			</ul>

			<h4>Adaptor</h4>

			<ul>
				<li>
					As name implies, allows output from one object to be used by another. 
				</li>
				<li>
					If we update a class that is used everywhere, we would need to make sweeping changes across entire code base, which is really error prone and hard to do. Alternatively, stick an adaptor between the object and everything else.
				</li>
				<li>
					Advantages:
					<ul>
						<li>Promotes single responsibility</li>
						<li>New adaptors can be introduced without heavy refactoring</li>
					</ul>
				</li>
				<li>
					Disadvantages:
					<ul>
						<li>Increased code complexity</li>
						<li>Depending on size of codebase, converting original object might just be easier</li>
					</ul>
				</li>
			</ul>

			<h4>Flyweight</h4>

			<ul>
				<li>
					The above is all about wrapping objects to add more functionality.
				</li>
				<li>
					What if we don't want to do that, rather just rearrange the objects so they're nicer?
				</li>
				<li>
					The <b>flyweight</b> pattern is a design pattern that allows us to get more objects in memory. They work best when objects share common properties which are also huge in size.
				</li>
				<li>
					Essentially: find all the data that is the same over a bunch of objects, and just extract that into a static class.
				</li>
				<li>
					<button class="collapsible nul">Flyweight Example... </button>
					<div class="ccontent cnul">
						<p>
							Suppose we have this NPC:
						</p>
						<pre><code class="lang-java">class Orc {
    String name;
	int health;
	Weapon weapon;
	NPCAI style;
	Map texture;

	// methods...
}</code></pre>
						<p>
							But the texture map is huge, because this is a really detailed game. If every orc has its own copy, we can't store many of them. But this texture is common to all orcs (as well as a few other things), so might as well split this into
						</p>
						<pre><code class="lang-java">class OrcData {
	static NPCAI style;
	static Map texture;
	static Weapon weapon;
}

class Orc {
	String name;
	int health;
	OrcData data;
}</code></pre>
						<p>
							And so now we only store <b>one</b> copy of <code>OrcData</code>.
						</p>
					</div>
				</li>
				<li>
					Advantages: Saves memory, potentially drastically
				</li>
				<li>
					Disadvantages:
					<ul>
						<li>Some data may need to be recalculated every call -- saving memory for increased compute time</li>
						<li>Complex code</li>
					</ul>
				</li>
			</ul>

			<h3 id="imp-4">Behavioural Patterns</h3>

			<ul>
				<li>
					Concerned with how objects communicate. Majority of object's behaviour is communication.
				</li>
				<li>
					Object can eithe change its own internal state, or interact by passing data to another object. The latter is what we care about.
				</li>
			</ul>

			<h4>Iterator Patterns</h4>

			<ul>
				<li>
					I think we've all used these? All default java data structures implement <code>Iterator</code> so we can do <code class="lang-java">for (Object i : listOfObjects) { ... }</code>
				</li>
				<li>
					Advantages:
					<ul>
						<li>Single responsibility principle</li>
						<li>New iterators can be introduced without heavy redesigns</li>
						<li>Iterate multiple ways in parallel</li>
						<li>Can even pause iteration and carry on later</li>
					</ul>
				</li>
				<li>
					Disadvantages:
					<ul>
						<li>Not always necessary</li>
						<li>Less effective for highly specialised objects</li>
					</ul>
				</li>
			</ul>

			<h4>Observer patterns</h4>

			<ul>
				<li>
					Allows an object's dependents to be automatically notified of a change.
				</li>
				<li>
					This can work as a <b>push model</b> (sender sends) or a <b>pull model</b> (receiver periodically asks).
				</li>
				<li>
					Often referred to as Producer/Consumer or Publisher/Subscriber.
				</li>
				<li>
					On the producer side, subscribers should be able to be added and removed from notification lists. Can have a different notification method for each type of notification publisher sends. Then, when the event occurs, iterate through all subscribed and send.
				</li>
				<li>
					This way removes the need for subscribers to constantly check - busy waiting is bad and is a waste of resources.
				</li>
				<li>
					Subscriber lists must be <b>opt-in</b>.
				</li>
				<li>
					By maintaining lists we reduce the number of subscribers that need to receive data and do not bother the rest of the system unnecessarily.
				</li>
				<li>
					Advantages:
					<ul>
						<li>New subs can be added without needing to redesign publisher</li>
						<li>Relationships between objects can change at runtime</li>
					</ul>
				</li>
				<li>
					Disadvantages:
					<ul>
						<li>Subscribers notified in possibly random order</li>
					</ul>
				</li>
			</ul>

			<h4>Memento Pattern</h4>

			<ul>
				<li>
					Save and Restore objects without revealing details of implementation.
				</li>
				<li>
					Especially useful in the event we need undos.
				</li>
				<li>
					The idea is the object can implement a method that makes a <b>snapshot</b> of itself, which is a limited interface that can then be stored in a <b>caretaker</b> class. This way, we don't violate encapsulation and expose all the private innards of an object.
				</li>
				<li>
					<button class="collapsible nul">Memento Example... </button>
					<div class="ccontent cnul">
						<p>The example given is an art program</p>
						<pre><code class="lang-java">public class Canvas {
	private int[][] colours;

	public Canvas(int x, int y) {
		colours = new int[x][y];
	}

	public void setPixel(int x, int y, int col) {
		colours[x][y] = col;
	}

	public Snapshot makeSnapshot() {
		return new Snapshot(this, colours);
	}
}</code></pre>
<pre><code class="lang-java">public class Snapshot {
	private Canvas canvas;
	private int[][] colours;

	public Snapshot(Canvas canvas, int[][] colours) {
		this.canvas = canvas;  // maintain refererence to existing canvas object
		this.colours = colours;
	}

	public void restore() {
		for (int i = 0; i < colours.length; i++) {
			for (int j = 0; j < colours[0].length; j++) {
				canvas.setPixel(i, j, colours[i][j]);
			}
		}
	}
}
</code></pre>
<pre><code class="lang-java">public class Caretaker {
	List&lt;Snapshot&gt; history;
	
	public Caretaker() {
		history = new ArrayList&lt;Snapshot&gt;();
	}

	public void addEntry(Snapshot s) {
		history.add(s);
	}

	public void restore() {
		Snapshot s = history.get(history.size()-1);
		s.restore();
	}
}</code></pre>
					</div>
				</li>

				<li>
					Advantages:
					<ul>
						<li>Making backups without violating encapsulation</li>
						<li>By extracting out maintenance and restoration, we keep original object as simple as possible</li>
					</ul>
				</li>

				<li>
					Disadvantages:
					<ul>
						<li>Heavy memory cost, managing mementos</li>
						<li>Need caretakers to track life cycles, more classes</li>
						<li>Dynamic langauges can't actually guarantee state is preserved. </li>
					</ul>
				</li>
			</ul>

			<h4>Strategy Pattern</h4>

			<ul>
				<li>
					To select the method to complete a task dynamically at runtime. 
				</li>
				<li>
					Say we have an object completing a problem, and we want it to choose on its own how to apprach said problem. 
				</li>
				<li>
					We have several new classes called <b>strategies</b>, each of which is a different solving approach. The original object selects from and uses these classes, and becomes a <b>context</b> object.
				</li>
				<li>
					Advantages:
					<ul>
						<li>Can swap implementation at runtime</li>
						<li>separating implementation details of an algorithm from the code that is just running it</li>
						<li>Simplifies class heirarchy -- composition replacing inheritance</li>
					</ul>
				</li>
				<li>
					Disadvantages:
					<ul>
						<li>Unnecessary when there's only few choices</li>
						<li>Requires clients to understand differences between strategies</li>
						<li>Anonymous functions are making this obsolete</li>
					</ul>
				</li>
			</ul>

			<h3 id="imp-5">SOLID</h3>


			<ul>
				<li>
					These patterns help achieve SOLID principles of good code design, those being
				</li>
				<li>
					<b>Single Responsibility:</b> each class does one thing
				</li>
				<li>
					<b>Open/Closed:</b> open to extension closed to modification - once we finish a class, don't modify it again - extend it
				</li>
				<li>
					<b>Liskov Substitution:</b> an object that uses a parent class can use its child classes without knowing -- child class can pretend to be parent class and serve all functionality of parent class
				</li>
				<li>
					<b>Interface segregation:</b> many specific interfaces better than one generic interface -- no code should depend on methods it doesn't use
				</li>
				<li>
					<b>Dependency Inversion:</b> ensure high level classes do not rely on functions from low level classes
				</li>
			</ul>

		</div>

		<div class="colourband">
			<h2 id="hci">Human Computer Interaction</h2>
		</div>

		<div class="cbox">

			<h3>Introduction</h3>

			<ol>
				<li><a href="#hci-1">Attention</a></li>
				<li><a href="#hci-2">Memory</a></li>
				<li><a href="#hci-3">Cognition</a></li>
				<li><a href="#hci-4">Affordances</a></li>
			</ol>

			<hr>

			<ul>
				<li>
					Essentially talking about the interface between the user and the system. The success of a product is determined by who uses it, and so making a program usable is preferable.
				</li>
				<li>
					We have <a href="https://www.nngroup.com/articles/ten-usability-heuristics/">Nielsen's usability principles</a>.
				</li>
				<li>
					As technology improves, interactions become more natural and intutitive - imagine DOS vs a Windows 7 GUI. Humans have natural ways of interaction, and trending towards that natural way is a good thing. 
				</li>
			</ul>

			<h3 id="hci-1">Attention</h3>

			<ul>
				<li>
					<i>Attention</i> is the process of selectively concentrating on certain things whilst ignoring others. 
				</li>
				<li>
					Attention can be forced, divided, or can be gained involuntarily/unconsciously. 
				</li>
				<li>
					There are 4 types:
					<ul>
						<li>Selective Attention - when we tune out things to focus on specific things</li>
						<li>Sustained Attention - the basis for attention span, how long we can focus on one task</li>
						<li>Divided Attention - Can focus on multiple things at once, but this gets harder as tasks get more complex</li>
						<li>Executive Attention - more organised version of sustained attention - keep track of steps and have clear goals</li>
					</ul>
				</li>
				<li>
					We want to design a system to draw attention to what is important. 
				</li>
				<li>
					We also want suitable metaphors so that even on new systems users intuitively know what certain things do - dragging a file to a bin icon will put it in the recycling bin. 
				</li>
				<li>
					Need to consider the context of the application, and how that relates to attention span.  
				</li>
				<li>
					If we want people to constant use our app and <strike>make ad revenue</strike>, then we need to sustain their attention (TikTok, granted most social media. If people are going to be using the app in a risky situation, then plan for divided attention (like a GPS system). If the app is used for tasks which take time, show progress.
				</li>
				<li>
					People's attention span are shrinking, but we still need to keep people focused. Thus,
					<ul>
						<li>Keep user's goals in mind -- don't clog the interface</li>
						<li>Switch up visuals / presentation often</li>
						<li>Make it intuitive, then less focus needed</li>
						<li>Use attention grabbing techniques sparingly (ha)</li>
					</ul>
				</li>
			</ul>

			<h3 id="hci-2">Memory</h3>

			<ul>
				<li>
					Not computer memory -- user memory. That thing that's like a sieve. 
				</li>
				<li>
					Memory has three main components - <i>sensory stores</i> hold information before it enters working memory, <i>working memory</i> is short term memory, and <i>long term memory</i>. 
				</li>
				<li>
					Short term memory is a temporary scratchpad that decays very quickly. Can only really hold around 4/5 things at once. Works best in chunking information.
				</li>
				<li>
					Long term memory has <i>episodic memory</i>: knowledge of events and experiences, chronologically; and <i>semantic memory</i>: knowledge of facts, concepts and skills. Often derives from the former. Long term memory also decay, but slower.
				</li>
				<li>
					<b>Design for short term memory</b> - if memory load is light, interactions can be quicker and smoother.
				</li>
				<li>
					No need for a user to make mistakes and stumble their way through a user interface until they finally internalise it. 
				</li>
				<li>
					Can use colour cues to differentiate items, and the lack of space in short term memory is another reason to keep UI sparse.
				</li>
				<li>
					Eventually interaction will enter long term memory. Keeping your interface similar between products helps in existing users' ease of navigation. 
				</li>
				<li>
					<b>Emotions stimulate memory</b>, generating emotions helps memory. However, there is a downside, since generating negative emotions (like the windows 10 settings application) is a good way to make a user hate your UI even more.
				</li>
				<li>
					Users also remember better what they have done themselves -- passiveness -> forgetfulness.
				</li>
				<li>
					Cannot fully rely on short term, some things require long term, and commiting to long term memory requires explicit effort, which we want to minimise. Using familiar images, consistent design and conventions helps making things easier. 
				</li>
				<li>
					This relates to <b>icon design</b>, where we want to use existing known icons for things (like a bell or envelope for notifications). Icons can be designed in 4 ways - <i>resemblance</i>; <i>exemplar</i> (using an example, like knife and fork for restaurant); <i>symbolic</i> (abstraction, a glass with a crack is fragile); or <i>arbitrary</i> (like the radioactive symbol).
				</li>
			</ul>

			<h3 id="hci-3">Cognition</h3>

			<h4>Norman's Action Cycle</h4>

			<ul>
				<li>
					Cognition includes understanding, remembering, reasoning, attending, ideas, and skills. 
				</li>
				<li>
					Psychologist Donald Norman created a <i>human action cycle</i> to describe actions people take when interacting with systems. We can use it to evaluate how good our UI is.
				</li>
				<li>
					<figure>
						<img src="http://petekinser.com/wp-content/uploads/2011/04/Norman-Action-Cycle.png" alt="" title="(Pete Kinser)" style="max-width: 200px;">
					</figure>
					<ul>
						<li>
							Form a goal - user first decides what they want to do 
						</li>
						<li>
							Intention to act - user makes intention explicit
						</li>
						<li>
							Plannign to act - user chooses action from list of possible actions
						</li>
						<li>
							Execution - user does the interaction
						</li>
						<li>
							Feedback - user receives feedback from the world / system
						</li>
						<li>
							Interpret feedback - user interprets the feedback based on what they expected to happen
						</li>
						<li>
							Evaluate - user determines if they have been successful and are now closer to their goal
						</li>
					</ul>
				</li>
				<li>
					Using the cycle to evaluate focuses on two aspects: the <b>Gulf of Evaluation</b> and the <b>Gulf of Execution</b>. 
				</li>
				<li>
					The former is the gap which must be corssed to interpret a UI. If outcomes are not expected, then the UI may be difficult to interpret. 
				</li>
				<li>
					The latter is the gap between wanting to complete an action and doing that action. Effectively how long / many steps it takes for the user to complete their actions, which should be small for common actions. Powerusers can make use of macros or shortcuts or something.
				</li>
				<li>
					From the action cycle we can also get 4 principles of design:
					<ul>
						<li>
							<b>Provide visibility</b> -- ensure user can easily understand current state of operations
						</li>
						<li>
							<b>Provide a good conceptual model</b> -- ensure outcomes and results are consistently presented 
						</li>
						<li>
							<b>Provide good mappings</b> -- ensure easy to determine what the outcome of any action will be 
						</li>
						<li>
							<b>Provide feedback</b> -- ensure user gets constant and consistent feedback on results
						</li>
					</ul>
				</li>
			</ul>

			<h4>Gestalt Principles</h4>

			<ul>
				<li>
					Some more psychologists blah blah blah. Patterns and rules on how humans will perceive sensory information.
				</li>
				<li>
					1: <b>Figure Ground Principle</b>: People segment their vision into "figure" and "ground" (i.e. fore and background). The figure gets the focus and is perceived as in front.
				</li>
				<li>
					2: <b>Similarity Principle</b>: Form informs function. If two things look similar, they'll probably behave similar. Can make use of colours and shapes in UI. 
				</li>
				<li>
					3: <b>Proximity Princple</b>: If objects are grouped together, they're probably related. Proximity overrides similarity. 
				</li>
				<li>
					4: <b>Common Region Principle</b>: Following from proximity, we group objects together in the same closed region -- what borders do. A UI will have several boxes and menus.
				</li>
				<li>
					5: <b>Continuity Principle</b>: If a series of objects are in a line or a curve, we think they are related. Curves and lines are better because we pattern match them quickly. 
				</li>
				<li>
					6: <b>Closure Principle</b>: If we see a complex arrangement of shapes, likely to form them into a single pattern and fill in the blanks. 
				</li>
				<li>
					7: <b>Focal Point Principle</b>: When we look at an image, we are drawn to the thing that stands out the most. Think about the big, bold, green-on-white <span style="background-color: green; color: white; font-weight: bolder;">ACCEPT COOKIES</span> and then the small, inconspicuous <span class="grey">reject non-essential cookies</span> on those popups.
				</li>
			</ul>

			<h3 id="hci-4">Affordances</h3>

			<ul>
				<li>
					Perception is where information is detected rather than constructed. <b>Affordances</b> are what an object allows us to do. A door affords opening it. 
				</li>
				<li>
					We must make affordances as clear to the user as possible, to make more intuitive. We show affordances via <b>signifiers</b>
				</li>
				<li>
					Affordances can be perceptible, or invisible (not shown, but is known), but signifiers <b>must be perceptible</b> -- a plate on a door indicating push (and also used wrong, like a handle on a push door, which is a false signifier) 
				</li>
				<li>
					Many affordances and signifiers exist by convention, such as a floppy disc being used for the save icon. 
				</li>
			</ul>
			<p>
				We can use metrics to evaluate a UI - such as the ratio of success to failure, time to complete a task, number of errors a user makes, or the number of times a user expresses frustration (windows 10 settings app) or satisfaction.
			</p>
		</div>

		<div class="colourband">
			<h2 id="dependability">Dependability</h2>
		</div>

		<div class="cbox">
			<h3>Introduction</h3>
			<ol>
				<li><a href="#dep-1">Dependency and Failure</a></li>
				<li><a href="#dep-2">Dependable Processes</a></li>
			</ol>

			<blockquote>Dependability is the trustworthiness of a computer system such that reliance can be justifiably placed on the service it delivers.</blockquote>
			<p>
				That was -- that was more of a word salad than I expected. <q>Dependability is the trustworthiness of a computer system and the services it provides</q> might be better?
			</p>

			<h3 id="dep-1">Dependency and Failure</h3>

			<ul>
				<li>
					Computer systems become more crucial, thus they need to be more reliable/dependable.
				</li>
				<li>
					System failures affect more people than a few missing features. Unreliable systems are avoided by users. System failure can also have massive cost to whatever the system was supposed to be doing (data, money, lives, money, security, and most importantly money)
				</li>
				<li>
					<b>Reliability</b> is a measure of how likely a system will work over a set period of time. 
				</li>
				<li>
					<b>Perceived Reliability</b> is how it seems to the user. May differ from real reliability since problems more likely with less used functions. 
				</li>
				<li>
					We can measure reliability via 
					<ul>
						<li>
							<i>Probability of failure on demand:</i> failure on request of service
						</li>
						<li>
							<i>Rate of failure occurence:</i> failures per time period
						</li>
						<li>
							<i>Mean time to failure</i> or how long it can keep running, on average
						</li>
						<li>
							<i>Availability:</i> if I request something, chances it's down?
						</li>
					</ul>
				</li>
				<li>
					Dependability consists of: Availability, Reliability, Safety, Confidentiality, Integrity, and Maintainability. 
				</li>
				<li>
					Attributes can be reduced or broken down into others. Not all attributes of dependency is relevant to all systems -- security is less of an issue for a pacemaker than reliability.
				</li>
				<li>
					Other system properties related to dependability are
					<ul>
						<li>
							<i>Repairability:</i> how easy is system to repair if it breaks. Are broken components accessible/modifiable easily?
						</li>
						<li>
							<i>Maintainability:</i> Is it economical to add new requirements and updates -- without breaking a lot of stuff. 
						</li>
						<li>
							<i>Error tolerance:</i> Designing system to accommodate user errors
						</li>
					</ul>
				</li>
				<li>
					The <b>fault</b> is the cause of the <b>error</b>, which is the effect, which may cause <b>failure</b>, when that error propagates past what the system/module can handle. 
				</li>
				<li>
					One module's failure can be the <i>fault</i> of another module, and so on and so forth until it exceeds the system boundary, and the whole system fails. 
				</li>
				<li>
					System failure can be caused by many things, notably <b>hardware failure</b>, <b>software failure</b> (due to design/impl errors), or <b>operational failure</b> (where the human operator makes mistakes)
				</li>
				<li>
					To provide dependability, we can 
					<ul>
						<li>
							Develop carefully to prevent faults -- <b>fault avoidance</b>
						</li>
						<li>
							Verification and testing to discover and remove faults before push -- <b>fault detection and correction</b>
						</li>
						<li>
							Desigining systems so that faults are handled and the system does not fail -- <b>fault tolerance</b>
						</li>
					</ul>
					Cost of fixing faults increases exponentioally. If its more cost-effective to release software with faults and fix them later, then it will be done.
				</li>
				<li>
					A system needs to recover, or continue operating in the case of a failure of a component:
					<ul>
						<li>
							<b>Graceful degredation</b> enables the system to still operate (perhaps in reduced capacity) when 
						</li>
						<li>
							<b>Redundancy</b> is where spare capacity is included in a system in case part of the system fails
						</li>
						<li>
							<b>Diversity</b> making redundnant systems have different implementations, so they're less likely to fail similarly. 
						</li>
					</ul>
				</li>
				<li>
					Software itself is intangible, and fairly cheap to fix. The only problem being when its effects ripple out into the real world. 
				</li>
				<li>
					Ideally we want to contain failure and not let it propagate -- this is difficult for the developers though. 
				</li>
				<li>
					Failures often come from adding new system requirements. 
				</li>
			</ul>

			<h3 id="dep-2">Dependable Processes</h3>

			<ul>
				<li>
					Dependable processes are designed to produce dependable software. 
				</li>
				<li>
					These processes are 
					<ul>
						<li>
							<b>Documentable:</b> defined process model that sets out what documentation is needed
						</li>
						<li>
							<b>Standardised:</b> processes applicable for many different systems, and should have standards applicable to all of them.
						</li>
						<li>
							<b>Auditable:</b> understandable by people other than the users, so verification can be done 
						</li>
						<li>
							<b>Diverse:</b> include redundant and diverse validation/verification 
						</li>
						<li>
							<b>Robust:</b> should be able to recover from failures of individual models. 
						</li>
					</ul>
				</li>
				<li>
					Dependable processes may not be enough to guarantee dependability. If so, system environments need to be designed dependably. 
				</li>
				<li>
					<b>Protection systems</b> are special systems parallel to other (usually control) systems. They exist to monitor the control system, and to move it to a safe state on fault. 
					<figure>
						<img src="./protection-systems.png" alt="" style="max-width: 630px;">
					</figure>
				</li>
				<li>
					<b>Self monitoring architectures</b> are systems designed to monitor its own operation. 
					<figure>
						<img src="./self-monitoring-system.png" alt="" style="max-width: 500px;">
					</figure>
					Each channel should have different hardware and software.
				</li>
				<li>
					<b>N-version programming</b> have multiple software unites (perhaps made by different teams), where each version is executed separately, and then outputs are compared. This has a high cost, and is used where other systems are impractical.
				</li>
				<li>
					All rely on <b>diversity</b>. If we give the same spec to different isolated teams, their implementations may be different, with different bugs and points of failure, reducing chance of overall failure from all systems. 
				</li>
				<li>
					Achieving complete diversity is impossible though, as programmers still work similarly at the basic level.
				</li>
			</ul>

		</div>
		

		<footer>
			<div class="cbox">
                <div class="columncontainer ctwo" id="fc2">
                </div>
                <script type="text/javascript" src="../../js/footerGen.js"></script>
            </div>
		</footer>

	</div>

	<script type="text/javascript" src="../../js/collapsible.js"></script>  <!--This stays at the end-->
	<script type="text/javascript" src="../../js/toggle-darklight.js"></script>
	<script type="text/javascript" src="../../js/prism.js"></script>
</body>
</html>