<!DOCTYPE html>
<html>
<head>
	<title>CS261</title>
	<meta charset="utf-8">
	<link rel="stylesheet" type="text/css" href="../../style/style.css" media="all">  <!--TODO: CHANGE HREF-->
	<link rel="stylesheet" type="text/css" href="../../style/prism.css" media="all">
	<meta name="viewport" content="width=device-width" initial-scale=1.0>  <!--TODO: CHANGE LINKS ON BOTTOM OF SHEET FOR COLLAPSIBLE-->
	<link rel="icon" type="image/png" href="../../style/images/DragonIcon.png">
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>

	<div class="hidden">
		<header>
			<div class="parallax parsmaller">
				<div  style="display: grid; grid-template-columns: 1fr 1fr 1fr 8fr 1fr; grid-column-gap: 10px; padding: 5px; ">
					<div class="column tinycolumn">
						<a href="../../" class="nav">Home</a>
					</div>
					<div class="column tinycolumn">
						<a href="../../blog.html" class="nav">Blog</a>
					</div>
					<div class="column tinycolumn">
						
						<a href="../../about.html" class="nav">About</a>
					</div>
					<div></div>
					<div class="column">
						<button class="nav dark-light">Dark Mode</button>
					</div>
				</div>
				<div class="cbox"> 		
					<h1>CS261</h1>
					<p class="subheading">Software Engineering (wah)</p>
				</div>
			</div>
		</header>

		<header>
			<div class="cbox">
				<h1>Contents</h1>
			</div>
		</header>

		<div class="cbox">
			<ol>
				<li><a href="#dev">Software Development Methodologies</a></li>
				<li><a href="#reqanal">Requirements Analysis</a></li>
				<li><a href="#teamorg">Team Organisation</a></li>
				<li><a href="#design">System Design</a></li>
				<li><a href="#proj-manage">Project Management</a></li>
			</ol>
		</div>

		
		<div class="colourband">
			<h2 id="dev">Software Development Methodologies</h2>
		</div>

		<div class="cbox">
			<h3>Introduction</h3>

			<ol>
				<li><a href="#dev-1">Plan-Driven</a></li>
				<li><a href="#dev-2">Software Spec</a></li>
				<li><a href="#dev-3">Agile</a></li>
			</ol>

			<ul>
				<li>
					Different Systems need different processes.
				</li>
				<li>
					All processes involve some sort of specification, design and implementation, testing, and evolution (maintaining)
				</li>
				<li>
					Two main types of development: plan driven and agile
				</li>
				<li>
					Plan driven: everything is planned and fixed in advance. Inflexible.
				</li>
				<li>
					Agile: Incremental planning, more adaptable to change.
				</li>
			</ul>

			<h3 id="dev-1">Plan-Driven</h3>

			<p>
				<b>Waterfall Model</b>
			</p>
			<ul>
				<li>
					Invented in 1970, strictest of all plan driven models. 
				</li>
				<li>
					If a change is required, the waterfall model must restart. Incredibly inflexible and in practice not completely followed. 
					<figure>
						<img src="https://www.umsl.edu/~hugheyd/is6840/images/Waterfall_model.png" alt="" style="max-width: 300px;" title="Uni of Missouri">
					</figure>
				</li>
				<li>
					<b>Requirements:</b> most customer focused, involves identification of resources, distribution of work.
				</li>
				<li>
					<b>Design:</b> design document generated, should be really detailed so implementation is not hard.
				</li>
				<li>
					<b>Implementation:</b> only when design doc is finished. Everything written should be unit tested.
				</li>
				<li>
					<b>Verification/Integration:</b> Most group focused - putting all parts of system together, making sure they work.
				</li>
				<li>
					<b>Maintenance:</b> Hand over program and documentation. Offer maintenance, which is also done via waterfall.
				</li>
				<li>
					Waterfall is good when requirements are understood and will not change. Few constraints on location and teams size (development distributed and isolated) and each component can be first tested in isolation.
				</li>
				<li>
					Waterfall is not good as the client has to wait a long time for results, and changes are difficult to accommodate, and there is a problem of software tech deprecation over the entire years-long development timespan.
				</li>
			</ul>

			<p><b>Inremental Development</b> </p>

			<ul>
				<li>
					A more flexible system than waterfall.
					<figure><img src="https://i.stack.imgur.com/BqktJ.jpg" alt="" title="stackoverflow" style="max-width: 420px;"></figure>
				</li>
				<li>
					Each iteration is still planned like waterfall, spec updated between iterations (not rewritten).
				</li>
				<li>
					(+) cost of accomodating change much reduced, and user gets software quicker, feedback is easier to get -- better (perceived) value for money
				</li>
				<li>
					(+) user inclustion in acceptance testing, can even install system before the final version.
				</li>
				<li>
					(-) <b>very</b> difficult to estimate overall cost of development of such a system.
				</li>
				<li>
					(-) difficult to maintain consistency between versions - poor design choices early on hamper later feature additions. Spaghetti code. 
				</li>
			</ul>

			<p><b>Reuse-Oriented Sofware Engineering</b></p>

			<ul>
				<li>
					Why reinvent the wheel? Instead, many devs rely on "off-the-shelf" / open source premade components, and just writes the glue code to tack them together. <b>Common off the shelf (COTS) systems</b>.
				</li>
				<li>
					Compromises on features with client has to be made, but tradeoff is that program is banged out in record time. 
				</li>
			</ul>

			<h3 id="dev-2">Software Spec</h3>

			<ul>
				<li>
					To understand and define what services are required
				</li>
				<li>
					To identify limits in feasibility - "requirements engineering", producing requirements document. 
				</li>
				<li>
					<figure><img src="./requirements-doc.png" alt="" style="max-width: 630px;"></figure>
				</li>
			</ul>

			<h3 id="dev-3">Agile</h3>

			<ul>
				<li >
					Agile development is about <i>rapid</i> development: interleave spec, design, and implementation, and develop the system as a series of evolving prototypes. 
				</li>
				<li>
					Focus on code over design, develop as you go. Aim for speed, and flexibility. 
				</li>
				<li>
					Often has the short stand up meeting concept. 
				</li>
				<li>
					Major principles of Agile are
					<ul>
						<li>Customer involvement - cannot respond rapidly to changes without rapid feedback</li>
						<li>Incremental delivery - have prototypes, and update spec for next iterations</li>
						<li>People not process - have highly skilled coders that know what they're doing. Share knowledge and improve processes</li>
						<li>Embrace change - open to additions, and design system to accommodate change (hard)</li>
						<li>Maintain simplicity - since there is a lack of good doucmentation, software must be simple and easy to understand for new members - "self commenting code" (lofty ideals)</li>
					</ul>
				</li>
				<li>
					Most companies spend more money on miantenance than actual development. Since agile prioritised development over documentation, this can be difficult to pick up and maintain later on. 
				</li>
				<li>
					Very flexible to requirements changes <b>provided</b> it's the original team doing it. Team losses hit harder in agile. 
				</li>
				<li>
					It is possible to mix plan-based and agile and pick and choose. 
				</li>
			</ul>

			<p><b>Extreme Programming</b></p>

			<ul>
				<li>
					Incremental delivery with fast iterations. Automated tests to verify builds. 
				</li>
				<li>
					Code refactored constantly to maintain simplicity. Strong customer involvement, deliveries every few weeks.
				</li>
				<li>
					<figure><img src="./extreme-programming.png" alt="" style="max-width: 420px;"></figure>
					
				</li>
				<li>
					Impractical if customer slow or hard to reach.
				</li>
				<li>
					Incremental planning: requirements on <b>"story cards"</b>, which are selected for inclusion based on priority. 
				</li>
				<li>
					Small releases: minimum functionality for release, with more stuff for future releases.
				</li>
				<li>
					Simple design: only enough design to meet customer requirements, maintaining expandability - this is HARD
				</li>
				<li>
					Test-driven development: write the tests for the feature before writing the feature to match the tests.
				</li>
				<li>
					Refactoring: constantly refactor to improve code
				</li>
				<li>
					Pair programming: work in pairs, one coding and the other checking and providing support. regularly swap.
				</li>
				<li>
					Collective ownership: more than 2 people responsible for any one part of the codebase. 
				</li>
				<li>
					Continuous integration: integrate as soon as feature done
				</li>
				<li>
					But also Sustainiable pace: avoid large amounts of overtime and overwork.
				</li>
				<li>
					Onsite customer: have a customer rep on site for minimal response delay.
				</li>
				<li>
					Extreme programming is very agile, but has the drawbacks of it too. Best suited for small, experienced teams.
				</li>
			</ul>

			<p><b>Scrum</b></p>

			<ul>
				<li>
					General method focused on iterative process, with three stages
					<ol>
						<li>Planning stage - general goals</li>
						<li>Sprint cycle - each cycle is an implementation, 2-4 weeks but it varies<figure><img src="./scrumcycle.png" alt="" style="max-width: 240px;"></figure></li>
						<li>Project closure</li>
					</ol>
					
				</li>
				<li>
					There are daily meetings for progress.
				</li>
				<li>
					Select the features needed with the customer, but build in isolation. The <b>scrum master</b> (i.e. team leader) interfaces between team and customer
				</li>
				<li>
					Work is reviewed and presented at end of sprint cycle. 
				</li>
			</ul>

		</div>

		<div class="colourband">
			<h2 id="reqanal">Requirements Analysis</h2>
		</div>

		<div class="cbox">
			<ul>
				<li>
					Requirements are descriptions of what program <b>should and shouldn't do</b>. This enables devs to fulfil customer needs, and provides a basis for tests, requirements, and analysis.
				</li>
				<li>
					2 parts: <b>what</b> is going to be built, and <b>how</b> is it going to be built. 
				</li>
				<li>
					Requirements bridge customer & developer, should be customer understandable, or at least
				</li>
				<li>
					Have <b>two</b> requiremetns docs, a "C-facing" (customer facing) and a "D-facing" (dev facing), with differing amounts of technical detail. C-facing is usually written first. Crucially, there are no differences in requirements between the two.
				</li>
				<li>
					Requirements should be specific and measureable. Not vague. Be aware of changing requirements. 
				</li>
				<li>
					<table>
						<tr>
							<th>C-facing reqs</th>
							<th>D-facing reqs</th>
						</tr>
						<tr>
							<td><ul><li>System from user view</li><li>how it works in natural language</li><li>diagrams are always nice</li><li>list of constraints in operation</li></ul></td>
							<td><ul><li>Detailed descriptions of functionality</li><li>Language, service, protocols, libraries, etc</li><li>Defines exactly waht must be implemented</li></ul></td>
						</tr>
					</table>
				</li>
				<li>
					The whole req doc must be: prioritised, consistent, modifiable, traceable (i.e. know where req came from, justification)
				</li>
				<li>
					Each requirement must be: correct, feasible, necessary, unambiguous, verifiable
				</li>
				<li>
					The <b>MoSCoW</b> order of priority is often used: <b>Must, Should, Could, Won't</b>, but there is an argument that if a requirement is "Won't", don't put it there in the first place?
				</li>
				<li>
					Requirements elicitation requires interaction with stakeholders, and gather information about the project. Think through the conficts of interest. Then, get clarifications, go through 'em with a fine-toothed comb, and finally write down the document after finalising.
				</li>
			</ul>
		</div>

		<div class="colourband">
			<h2 id="teamorg">Team Organisation</h2>
		</div>

		<div class="cbox">
			<ul>
				<li>
					The <b>project manager</b> makes sure everything is running smoothly and on time. 
					<ul>
						<li>
							They are arguably the most stressful role, and is often the least technical and most people-oriented role.
						</li>
						<li>
							They must track progress and help solve stuck situations, plan the project development.
						</li>
						<li>
							They must manage the team, chase people up about work, etc. 
						</li>
						<li>
							And consider risks (to development or to team) and mitigations -- risk assessments. Considering when to sacrifice features if necessary.
						</li>
					</ul>
				</li>
				<li>
					The <b>business analyst</b> looks at organisational context of the project. 
					<ul>
						<li>
							They identify stakeholders, activities, processes, etc
						</li>
						<li>
							And understand the stakeholders' requirements. They do the requirements elicitation and documentation. Make sure everything is traceable and justified. 
						</li>
					</ul>
				</li>
				<li>
					These guys must also: Review the test plan -- a good test plan can identify mistakes even before development, such as incompatibilities between modules. Bugs and defects should be triaged and prioritised.
				</li>
				<li>
					Supervise project installation, deal with the "day 1 live trauma", and hand over software, and perhaps manage maintenance and support. 
				</li>
				<li>
					Reflect over what did well, what did poorly when closing down project. Archive and seal documentation. 
				</li>
				<li>
					Reward and recognise people for their achievements. 
				</li>
				<li>
					Throughout, accountability for code is important. Use version control, <code>git blame</code> exists for a reason. Git is good.
				</li>
			</ul>
		</div>

		<div class="colourband">
			<h2 id="design">System Design</h2>
		</div>

		<div class="cbox">
			<h3>Contents</h3>

			<ol>
				<li><a href="#dev-1">System Modelling</a></li>
				<li><a href="#dev-2">UML in more detail</a></li>
			</ol>

			<h3 id="dev-1">System Modelling</h3>

			<ul>
				<li>
					System design is supplemented by mathematical/logical <b>system modelling</b> diagrams, which 
				</li>
				<li>
					clarify fuctionality, provide a <b>basis</b> for development, and inform design approaches and component level decisions.
				</li>
				<li>
					<b>UML</b> - Unified Modelling Language - is a set of formal representations which help with the 4 "perspectives":
					<ul>
						<li>
							<b>External</b> -- context of system, interaction systems
						</li>
						<li>
							<b>Interaction</b> -- how people interact with the software, what is accessed by who, what is internal
						</li>
						<li>
							<b>Structural</b> -- layout, core features, class organisatiom
						</li>
						<li>
							<b>Behavioural</b> -- dynamic behaviour, algorithms and processes reacting to external or internal interactions.
						</li>
					</ul>
				</li>
				<li>
					UML has two subsections (views): <b>static / structural;</b> and <b>behavioural</b>. 
				</li>
				<li>
					Within these views are different types of diagrams, like class diagrams, sequence diagrams, use case diagrams, activity ", state machines, sequence ".
				</li>
			</ul>

			<h3 id="dev-2">UML in more detail</h3>

			<p>
				<b>Class diagrams</b> (static): most common type of diagram, shows the entites within a system and their relations. Obviously most suited to OOP.
			</p>
			<ul>
				<li>
					Entities can be identified through 
					<ul>
						<li>A grammatical approach, where they are extracted from a description of requirements</li>
						<li>Tangible things in application domain</li>
						<li>Behavioural approach, thinking about how entities will interact</li>
						<li>Scenario-based, objects and methods from scenarios</li>
					</ul>
				</li>
				<li>
					<figure><img src="./classidagram.png" alt=""></figure>
				</li>
			</ul>

			<p>
				<b>Activity Diagrams</b> (behaviour): kinda like a flowchart really. Note that decision doesn't have anything written inside it.
			</p>
			<figure><img src="./activitydiagram.png" alt="" style="max-width: 630px;"></figure>

			<p>
				<b>Use case diagrams</b>: how different events interact with other events. 
			</p>
			<figure><img src="./usecasediagm.png" alt="" style="max-width: 630px;"></figure>

			<p>
				<b>Sequence Diagrams:</b> to show <i>temporal</i> interaction -- how a system's interactions go over time.
			</p>
			<figure><img src="./sequenceidamg.png" alt="" style="max-width: 630px;"></figure>
			<ul>
				<li>
					Participants are objects or entites. 
				</li>
				<li>
					Each diagram always starts with a <b>call out arrow</b>, showing external prompting. Messages passed are shown in arrows. Time is not to scale. 
				</li>
				<li>
					Labels take the form of <code>name:Object</code> for a named object, <code>:Object</code> for an anonymous object, and <code>name</code> for a named unknown class.
				</li>
				<li>
					If an object calls itself, we need to nest a bar inside a bar. Loops and ifs are done with labelled boxes.
					<figure><img src="./seqdiag2.png" alt="" style="max-width: 310px;"></figure>
				</li>
				<li>
					Don't model a whole system on them - they're ugly and ungainly, best used for subsystems.
				</li>
			</ul>
		</div>

		<div class="colourband">
			<h2 id="proj-manage">Project Management</h2>
		</div>

		<div class="cbox">

			<h3>Contents</h3>

			<ol>
				<li><a href="#pro-1">Why Projects Fail</a></li>
				<li><a href="#pro-2">Risk Management</a></li>
				<li><a href="#pro-3">Project Management</a></li>
			</ol>

			<h3 id="pro-1">Why Projects Fail</h3>

			<p>
				Very few projects succeed, why is this so? Well, there are a multitude of reasons, amongst them poor planning, requirements changing too much, high turnover, unrealistic deadlines, poor testing, and so on and so forth. 
			</p>
			<p>
				Project management is essential to making sure constraints are kept, to
				<ol>
					<li>Deliver software on time</li>
					<li>Keep costs within budget</li>
					<li>Deliver software that meets expectations</li>
					<li>Maintain morale and productivity of team</li>
				</ol>
			</p>
			<p>
				Team success depends on three generic factors:
				<ol>
					<li>People: a mix of people with different motivations and skillsets</li>
					<li>Organisation: individuals must be given opportunity to contribute</li>
					<li>Communication: technical and managerial communication is essential</li>
				</ol>
				And four people factors:
				<ol>
					<li>Consistency: not making people feel undervalued</li>
					<li>Respect: everyone has equal opportunity to contribute</li>
					<li>Inclusion: all views should be considered (regardless of heirarchy)</li>
					<li>Honesty: faking it will backfire unless you actually make it</li>
				</ol>
			</p>
			<p>
				People are motivated through satisfaction of their needs (something something heirarchy of needs).
			</p>
			<p>
				Heirarchy is still important. Should the PM be the Tech lead? Or should it be someone else? Who will interact with stakeholders? How do we integrate people who are not in the same location? How can knowledge be shared?
			</p>
			<p>
				Group organisation can be informal or heirarchical:
				<ul>
					<li><b>Informal:</b> No strict heirarchy, decisions made by consensus. Can be successful if griup is highly competent.</li>
					<li><b>Heirarchical:</b> Defined leaders and management levels. Can work well in breaking down and delegating subproblems. Best when responsibilities are clear.</li>
				</ul>
			</p>
			<p>
				A cohesive team can establish their own quality standards, and actually follow them. Individuals will learn from and support each other, and people tend to work better.
			</p>

			<h3 id="pro-2">Risk Management</h3>

			<h4>Identification</h4>

			<p>
				Risks can be grouped into what areas they affect. <b>Project risks</b> affect the schedule or resources of the entire project. <b>Product risks</b> affect the final quality of the product. <b>Business risks</b> affect the organisation. Some risks can fall into multiple categories.
			</p>
			<p>
				<b>Project Risks</b> include staff turnover, management change, hardware unavailability, requirements change, etc.
			</p>
			<p>
				<b>Prduct Risks</b> include tool/library underperformance, the aforementioned requirements change, specification delays, size/complexity underestimates, etc.
			</p>
			<p>
				<b>Business Risks</b> include technology changes and deprecation, product competition, etc.
			</p>
			<p>
				There can be even finer category groups: such as Technology Risks, People Risks, Organisational Risks, Tool Risks, Requirements Risks and Estimation Risks.
			</p>

			<h4>Analysis</h4>

			<p>
				Consider each risk and its severity, this can then be grouped and <b>prioritised</b>
			</p>
			<p>
				For example, you could have a rating Insignificant/Tolerable/Serious/Catastrophic. 
			</p>

			<h4>Contingency</h4>

			<p>
				Once you have a prioritised risk list, a contingency plan for each risk must be made. First is <b>avoidance</b>: aim to reduce the chance of the risk even becoming reality, then comes <b>minimisation:</b> reducing damage if it goes wrong, and finally <b>contingency plans:</b> what to do if risk does occur.
			</p>
			<p>
				This all goes into a risk assessment / risk register, which can be a docuemnt, or on a management platform, but somewhere accessible to management.
			</p>

			<h3 id="pro-3">Project Management</h3>

			<p>
				The planning documents of a project should communicate all ideas, contingencies, organisation, etc to both the developers and the stakeholder. 
			</p>
			<p>
				Planning has three stages: (1) Proposal / pitch / bidding phase, (2) startup phase, and (3) periodic planning.
			</p>
			<figure>
				<img src="./proj-plannign.png" alt="" style="max-width: 630px;">
			</figure>

			<p>
				Scheduling is done through <a href="https://simple.wikipedia.org/wiki/Gantt_chart">Gantt Charts</a>, and critical path analysis algorithms for scheduing which tasks go first. 
			</p>
			<p>
				Estimation of costs and schedule however is really very easier said than done, 
				<ul>
					<li>It often comes down to experience as to how to schedule a project correctly,</li>
					<li>Or using some sort of algorithm to guesstimate the schedule.</li>
				</ul>
			</p>
			<p>
				Success is measured against how well the project meets the spec and existing expectations.
			</p>

		</div>
		

		<footer>
			<div class="cbox">
                <div class="columncontainer ctwo" id="fc2">
                </div>
                <script type="text/javascript" src="../../js/footerGen.js"></script>
            </div>
		</footer>

	</div>

	<script type="text/javascript" src="../../js/collapsible.js"></script>  <!--This stays at the end-->
	<script type="text/javascript" src="../../js/toggle-darklight.js"></script>
	<script type="text/javascript" src="../../js/prism.js"></script>
</body>
</html>