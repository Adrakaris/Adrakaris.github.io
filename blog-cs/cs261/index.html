<!DOCTYPE html>
<html>
<head>
	<title>CS261</title>
	<meta charset="utf-8">
	<link rel="stylesheet" type="text/css" href="../../style/style.css" media="all">  <!--TODO: CHANGE HREF-->
	<link rel="stylesheet" type="text/css" href="../../style/prism.css" media="all">
	<meta name="viewport" content="width=device-width" initial-scale=1.0>  <!--TODO: CHANGE LINKS ON BOTTOM OF SHEET FOR COLLAPSIBLE-->
	<link rel="icon" type="image/png" href="../../style/images/DragonIcon.png">
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>

	<div class="hidden">
		<header>
			<div class="parallax parsmaller">
				<div  style="display: grid; grid-template-columns: 1fr 1fr 1fr 8fr 1fr; grid-column-gap: 10px; padding: 5px; ">
					<div class="column tinycolumn">
						<a href="../../" class="nav">Home</a>
					</div>
					<div class="column tinycolumn">
						<a href="../../blog.html" class="nav">Blog</a>
					</div>
					<div class="column tinycolumn">
						
						<a href="../../about.html" class="nav">About</a>
					</div>
					<div></div>
					<div class="column">
						<button class="nav dark-light">Dark Mode</button>
					</div>
				</div>
				<div class="cbox"> 		
					<h1>CS261</h1>
					<p class="subheading">Software Engineering (wah)</p>
				</div>
			</div>
		</header>

		<header>
			<div class="cbox">
				<h1>Contents</h1>
			</div>
		</header>

		<div class="cbox">
			<ol>
				<li><a href="#dev">Software Development Methodologies</a></li>
				<li><a href="#reqanal">Requirements Analysis</a></li>
				<li><a href="#teamorg">Team Organisation</a></li>
				<li><a href="#design">System Design</a></li>
			</ol>
		</div>

		
		<div class="colourband">
			<h2 id="dev">Software Development Methodologies</h2>
		</div>

		<div class="cbox">
			<h3>Introduction</h3>

			<ol>
				<li><a href="#dev-1">Plan-Driven</a></li>
				<li><a href="#dev-2">Software Spec</a></li>
				<li><a href="#dev-3">Agile</a></li>
			</ol>

			<ul>
				<li>
					Different Systems need different processes.
				</li>
				<li>
					All processes involve some sort of specification, design and implementation, testing, and evolution (maintaining)
				</li>
				<li>
					Two main types of development: plan driven and agile
				</li>
				<li>
					Plan driven: everything is planned and fixed in advance. Inflexible.
				</li>
				<li>
					Agile: Incremental planning, more adaptable to change.
				</li>
			</ul>

			<h3 id="dev-1">Plan-Driven</h3>

			<p>
				<b>Waterfall Model</b>
			</p>
			<ul>
				<li>
					Invented in 1970, strictest of all plan driven models. 
				</li>
				<li>
					If a change is required, the waterfall model must restart. Incredibly inflexible and in practice not completely followed. 
					<figure>
						<img src="https://www.umsl.edu/~hugheyd/is6840/images/Waterfall_model.png" alt="" style="max-width: 300px;" title="Uni of Missouri">
					</figure>
				</li>
				<li>
					<b>Requirements:</b> most customer focused, involves identification of resources, distribution of work.
				</li>
				<li>
					<b>Design:</b> design document generated, should be really detailed so implementation is not hard.
				</li>
				<li>
					<b>Implementation:</b> only when design doc is finished. Everything written should be unit tested.
				</li>
				<li>
					<b>Verification/Integration:</b> Most group focused - putting all parts of system together, making sure they work.
				</li>
				<li>
					<b>Maintenance:</b> Hand over program and documentation. Offer maintenance, which is also done via waterfall.
				</li>
				<li>
					Waterfall is good when requirements are understood and will not change. Few constraints on location and teams size (development distributed and isolated) and each component can be first tested in isolation.
				</li>
				<li>
					Waterfall is not good as the client has to wait a long time for results, and changes are difficult to accommodate, and there is a problem of software tech deprecation over the entire years-long development timespan.
				</li>
			</ul>

			<p><b>Inremental Development</b> </p>

			<ul>
				<li>
					A more flexible system than waterfall.
					<figure><img src="https://i.stack.imgur.com/BqktJ.jpg" alt="" title="stackoverflow" style="max-width: 420px;"></figure>
				</li>
				<li>
					Each iteration is still planned like waterfall, spec updated between iterations (not rewritten).
				</li>
				<li>
					(+) cost of accomodating change much reduced, and user gets software quicker, feedback is easier to get -- better (perceived) value for money
				</li>
				<li>
					(+) user inclustion in acceptance testing, can even install system before the final version.
				</li>
				<li>
					(-) <b>very</b> difficult to estimate overall cost of development of such a system.
				</li>
				<li>
					(-) difficult to maintain consistency between versions - poor design choices early on hamper later feature additions. Spaghetti code. 
				</li>
			</ul>

			<p><b>Reuse-Oriented Sofware Engineering</b></p>

			<ul>
				<li>
					Why reinvent the wheel? Instead, many devs rely on "off-the-shelf" / open source premade components, and just writes the glue code to tack them together. <b>Common off the shelf (COTS) systems</b>.
				</li>
				<li>
					Compromises on features with client has to be made, but tradeoff is that program is banged out in record time. 
				</li>
			</ul>

			<h3 id="dev-2">Software Spec</h3>

			<ul>
				<li>
					To understand and define what services are required
				</li>
				<li>
					To identify limits in feasibility - "requirements engineering", producing requirements document. 
				</li>
				<li>
					<figure><img src="./requirements-doc.png" alt="" style="max-width: 630px;"></figure>
				</li>
			</ul>

			<h3 id="dev-3">Agile</h3>

			<ul>
				<li >
					Agile development is about <i>rapid</i> development: interleave spec, design, and implementation, and develop the system as a series of evolving prototypes. 
				</li>
				<li>
					Focus on code over design, develop as you go. Aim for speed, and flexibility. 
				</li>
				<li>
					Often has the short stand up meeting concept. 
				</li>
				<li>
					Major principles of Agile are
					<ul>
						<li>Customer involvement - cannot respond rapidly to changes without rapid feedback</li>
						<li>Incremental delivery - have prototypes, and update spec for next iterations</li>
						<li>People not process - have highly skilled coders that know what they're doing. Share knowledge and improve processes</li>
						<li>Embrace change - open to additions, and design system to accommodate change (hard)</li>
						<li>Maintain simplicity - since there is a lack of good doucmentation, software must be simple and easy to understand for new members - "self commenting code" (lofty ideals)</li>
					</ul>
				</li>
				<li>
					Most companies spend more money on miantenance than actual development. Since agile prioritised development over documentation, this can be difficult to pick up and maintain later on. 
				</li>
				<li>
					Very flexible to requirements changes <b>provided</b> it's the original team doing it. Team losses hit harder in agile. 
				</li>
				<li>
					It is possible to mix plan-based and agile and pick and choose. 
				</li>
			</ul>

			<p><b>Extreme Programming</b></p>

			<ul>
				<li>
					Incremental delivery with fast iterations. Automated tests to verify builds. 
				</li>
				<li>
					Code refactored constantly to maintain simplicity. Strong customer involvement, deliveries every few weeks.
				</li>
				<li>
					<figure><img src="./extreme-programming.png" alt="" style="max-width: 420px;"></figure>
					
				</li>
				<li>
					Impractical if customer slow or hard to reach.
				</li>
				<li>
					Incremental planning: requirements on <b>"story cards"</b>, which are selected for inclusion based on priority. 
				</li>
				<li>
					Small releases: minimum functionality for release, with more stuff for future releases.
				</li>
				<li>
					Simple design: only enough design to meet customer requirements, maintaining expandability - this is HARD
				</li>
				<li>
					Test-driven development: write the tests for the feature before writing the feature to match the tests.
				</li>
				<li>
					Refactoring: constantly refactor to improve code
				</li>
				<li>
					Pair programming: work in pairs, one coding and the other checking and providing support. regularly swap.
				</li>
				<li>
					Collective ownership: more than 2 people responsible for any one part of the codebase. 
				</li>
				<li>
					Continuous integration: integrate as soon as feature done
				</li>
				<li>
					But also Sustainiable pace: avoid large amounts of overtime and overwork.
				</li>
				<li>
					Onsite customer: have a customer rep on site for minimal response delay.
				</li>
				<li>
					Extreme programming is very agile, but has the drawbacks of it too. Best suited for small, experienced teams.
				</li>
			</ul>

			<p><b>Scrum</b></p>

			<ul>
				<li>
					General method focused on iterative process, with three stages
					<ol>
						<li>Planning stage - general goals</li>
						<li>Sprint cycle - each cycle is an implementation, 2-4 weeks but it varies<figure><img src="./scrumcycle.png" alt="" style="max-width: 240px;"></figure></li>
						<li>Project closure</li>
					</ol>
					
				</li>
				<li>
					There are daily meetings for progress.
				</li>
				<li>
					Select the features needed with the customer, but build in isolation. The <b>scrum master</b> (i.e. team leader) interfaces between team and customer
				</li>
				<li>
					Work is reviewed and presented at end of sprint cycle. 
				</li>
			</ul>

		</div>

		<div class="colourband">
			<h2 id="reqanal">Requirements Analysis</h2>
		</div>

		<div class="cbox">
			<ul>
				<li>
					Requirements are descriptions of what program <b>should and shouldn't do</b>. This enables devs to fulfil customer needs, and provides a basis for tests, requirements, and analysis.
				</li>
				<li>
					2 parts: <b>what</b> is going to be built, and <b>how</b> is it going to be built. 
				</li>
				<li>
					Requirements bridge customer & developer, should be customer understandable, or at least
				</li>
				<li>
					Have <b>two</b> requiremetns docs, a "C-facing" (customer facing) and a "D-facing" (dev facing), with differing amounts of technical detail. C-facing is usually written first. Crucially, there are no differences in requirements between the two.
				</li>
				<li>
					Requirements should be specific and measureable. Not vague. Be aware of changing requirements. 
				</li>
				<li>
					<table>
						<tr>
							<th>C-facing reqs</th>
							<th>D-facing reqs</th>
						</tr>
						<tr>
							<td><ul><li>System from user view</li><li>how it works in natural language</li><li>diagrams are always nice</li><li>list of constraints in operation</li></ul></td>
							<td><ul><li>Detailed descriptions of functionality</li><li>Language, service, protocols, libraries, etc</li><li>Defines exactly waht must be implemented</li></ul></td>
						</tr>
					</table>
				</li>
				<li>
					The whole req doc must be: prioritised, consistent, modifiable, traceable (i.e. know where req came from, justification)
				</li>
				<li>
					Each requirement must be: correct, feasible, necessary, unambiguous, verifiable
				</li>
				<li>
					The <b>MoSCoW</b> order of priority is often used: <b>Must, Should, Could, Won't</b>, but there is an argument that if a requirement is "Won't", don't put it there in the first place?
				</li>
				<li>
					Requirements elicitation requires interaction with stakeholders, and gather information about the project. Think through the conficts of interest. Then, get clarifications, go through 'em with a fine-toothed comb, and finally write down the document after finalising.
				</li>
			</ul>
		</div>

		<div class="colourband">
			<h2 id="teamorg">Team Organisation</h2>
		</div>

		<div class="cbox">
			<ul>
				<li>
					The <b>project manager</b> makes sure everything is running smoothly and on time. 
					<ul>
						<li>
							They are arguably the most stressful role, and is often the least technical and most people-oriented role.
						</li>
						<li>
							They must track progress and help solve stuck situations, plan the project development.
						</li>
						<li>
							They must manage the team, chase people up about work, etc. 
						</li>
						<li>
							And consider risks (to development or to team) and mitigations -- risk assessments. Considering when to sacrifice features if necessary.
						</li>
					</ul>
				</li>
				<li>
					The <b>business analyst</b> looks at organisational context of the project. 
					<ul>
						<li>
							They identify stakeholders, activities, processes, etc
						</li>
						<li>
							And understand the stakeholders' requirements. They do the requirements elicitation and documentation. Make sure everything is traceable and justified. 
						</li>
					</ul>
				</li>
				<li>
					These guys must also: Review the test plan -- a good test plan can identify mistakes even before development, such as incompatibilities between modules. Bugs and defects should be triaged and prioritised.
				</li>
				<li>
					Supervise project installation, deal with the "day 1 live trauma", and hand over software, and perhaps manage maintenance and support. 
				</li>
				<li>
					Reflect over what did well, what did poorly when closing down project. Archive and seal documentation. 
				</li>
				<li>
					Reward and recognise people for their achievements. 
				</li>
				<li>
					Throughout, accountability for code is important. Use version control, <code>git blame</code> exists for a reason. Git is good.
				</li>
			</ul>
		</div>

		<div class="colourband">
			<h2 id="design">System Design</h2>
		</div>

		<div class="cbox">
			<h3>Contents</h3>

			<ol>
				<li><a href="#dev-1">System Modelling</a></li>
				<li><a href="#dev-2">UML in more detail</a></li>
			</ol>

			<h3 id="dev-1">System Modelling</h3>

			<ul>
				<li>
					System design is supplemented by mathematical/logical <b>system modelling</b> diagrams, which 
				</li>
				<li>
					clarify fuctionality, provide a <b>basis</b> for development, and inform design approaches and component level decisions.
				</li>
				<li>
					<b>UML</b> - Unified Modelling Language - is a set of formal representations which help with the 4 "perspectives":
					<ul>
						<li>
							<b>External</b> -- context of system, interaction systems
						</li>
						<li>
							<b>Interaction</b> -- how people interact with the software, what is accessed by who, what is internal
						</li>
						<li>
							<b>Structural</b> -- layout, core features, class organisatiom
						</li>
						<li>
							<b>Behavioural</b> -- dynamic behaviour, algorithms and processes reacting to external or internal interactions.
						</li>
					</ul>
				</li>
				<li>
					UML has two subsections (views): <b>static / structural;</b> and <b>behavioural</b>. 
				</li>
				<li>
					Within these views are different types of diagrams, like class diagrams, sequence diagrams, use case diagrams, activity ", state machines, sequence ".
				</li>
			</ul>

			<h3 id="dev-2">UML in more detail</h3>

			<p>
				<b>Class diagrams</b> (static): most common type of diagram, shows the entites within a system and their relations. Obviously most suited to OOP.
			</p>
			<ul>
				<li>
					Entities can be identified through 
					<ul>
						<li>A grammatical approach, where they are extracted from a description of requirements</li>
						<li>Tangible things in application domain</li>
						<li>Behavioural approach, thinking about how entities will interact</li>
						<li>Scenario-based, objects and methods from scenarios</li>
					</ul>
				</li>
				<li>
					<figure><img src="./classidagram.png" alt=""></figure>
				</li>
			</ul>

			<p>
				<b>Activity Diagrams</b> (behaviour): kinda like a flowchart really. Note that decision doesn't have anything written inside it.
			</p>
			<figure><img src="./activitydiagram.png" alt="" style="max-width: 630px;"></figure>

			<p>
				<b>Use case diagrams</b>: how different events interact with other events. 
			</p>
			<figure><img src="./usecasediagm.png" alt="" style="max-width: 630px;"></figure>

			<p>
				<b>Sequence Diagrams:</b> to show <i>temporal</i> interaction -- how a system's interactions go over time.
			</p>
			<figure><img src="./sequenceidamg.png" alt="" style="max-width: 630px;"></figure>
			<ul>
				<li>
					Participants are objects or entites. 
				</li>
				<li>
					Each diagram always starts with a <b>call out arrow</b>, showing external prompting. Messages passed are shown in arrows. Time is not to scale. 
				</li>
				<li>
					Labels take the form of <code>name:Object</code> for a named object, <code>:Object</code> for an anonymous object, and <code>name</code> for a named unknown class.
				</li>
				<li>
					If an object calls itself, we need to nest a bar inside a bar. Loops and ifs are done with labelled boxes.
					<figure><img src="./seqdiag2.png" alt="" style="max-width: 310px;"></figure>
				</li>
				<li>
					Don't model a whole system on them - they're ugly and ungainly, best used for subsystems.
				</li>
			</ul>
		</div>
		

		<footer>
			<div class="cbox">
                <div class="columncontainer ctwo" id="fc2">
                </div>
                <script type="text/javascript" src="../../js/footerGen.js"></script>
            </div>
		</footer>

	</div>

	<script type="text/javascript" src="../../js/collapsible.js"></script>  <!--This stays at the end-->
	<script type="text/javascript" src="../../js/toggle-darklight.js"></script>
	<script type="text/javascript" src="../../js/prism.js"></script>
</body>
</html>