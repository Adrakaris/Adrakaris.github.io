<!DOCTYPE html>
<html>
<head>
	<title>CS419</title>
	<meta charset="utf-8">
	<link rel="stylesheet" type="text/css" href="../../style/style.css" media="all">  <!--TODO: CHANGE HREF-->
	<link rel="stylesheet" type="text/css" href="../../style/prism.css" media="all">
	<meta name="viewport" content="width=device-width" initial-scale=1.0>  <!--TODO: CHANGE LINKS ON BOTTOM OF SHEET FOR COLLAPSIBLE-->
	<link rel="icon" type="image/png" href="../../style/images/DragonIcon.png">
	
	
	<script async id="MathJax-script" type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
	<script defer type="text/javascript" src="../../js/toggle-darklight.js"></script>
	<script defer type="text/javascript" src="../../js/collapsible.js"></script>  <!--This stays at the end-->
	<script defer type="text/javascript" src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
	<script defer type="text/javascript" src="../../js/arrange.js"></script>
	<script defer type="text/javascript" src="../../js/prism.js"></script>
</head>
<body>

<div class="hidden">
	<header>
		<div class="parallax parsmaller">
			<div  style="display: grid; grid-template-columns: 1fr 1fr 1fr 7fr 1fr 1fr; grid-column-gap: 10px; padding: 5px; ">
				<div class="column tinycolumn">
					<a href="../../" class="nav">Home</a>
				</div>
				<div class="column tinycolumn">
					<a href="../../blog.html" class="nav">Blog</a>
				</div>
				<div class="column tinycolumn">
					
					<a href="../../about.html" class="nav">About</a>
				</div>
				<div></div>
				<div class="column tinycolumn">
					<a href="https://ko-fi.com/yijunhu" class="nav">Donate</a>
				</div>
				<div class="column">
					<button class="nav dark-light">Dark Mode</button>
				</div>
			</div>
			<div class="cbox"> 		
				<h1>CS419</h1>
				<p class="subheading">Quantum Computing</p>
			</div>
		</div>
	</header>

<header>
	<div class="cbox">
		<h1>Introduction</h1>
	</div>
</header>


<div class="cbox">

<div class="md-conv">

For this module, I am trying to write notes along with the lectures. Thus content headings may be a little late coming.

Lots of this is just linear algebra with funny notation.

> Commentary is shown in block quotes.

Enjoy the MathJax loading. (I did try out katex but it just isn't wanting to work)

## Contents 

1. [Quantum Computing Fundamentals](#qc-fundy)
2. [Quantum Mechanical Principles](#qmps)
3. [Quantum Information](#qinfo)
4. [Quantum Information Transfer](#qit)
4. [Quantum Cryptography](#qcyp)
4. [Quantum Money](#qm)
4. [Computation and Complexity Theory](#complexity)
6. [Quantum Fourier Transforms](#qft)
6. [Quantum Search](#search)
</div>

<div>
\(
	\newcommand{\k}[1]{\left\lvert #1 \right\rangle}
	\newcommand{\e}[1]{\left\lvert #1 \right\rangle}
	\newcommand{\b}[1]{\left\langle #1 \right\rvert}
	\newcommand{\ip}[2]{\left\langle #1 \vert #2 \right\rangle}
	\newcommand{\bb}{\mathbb}
	\newcommand{\rm}{\textrm}
	\newcommand{\0}{\e{0}}
	\newcommand{\1}{\e{1}}
	\newcommand{\p}{\e{+}}
	\newcommand{\m}{\e{-}}
	\newcommand{\t}{^\top}
	\newcommand{\abs}[1]{\left\lvert #1 \right \rvert}
	\DeclareMathOperator{\tens}{\otimes}
	\DeclareMathOperator{\lra}{\longrightarrow}
	\DeclareMathOperator{\lla}{\longleftarrow}
	\DeclareMathOperator{\span}{span}
	\DeclareMathOperator{\dim}{dim}
	\DeclareMathOperator{\poly}{poly}
	\DeclareMathOperator{\Tr}{Tr}
	\DeclareMathOperator{\per}{per}
	\DeclareMathOperator{\space}{\mathcal{P}}
\)
</div>

</div>


<div class="colourband">
	<h2 id="qc-fundy">Quantum Computing Fundamentals</h2>
</div>

<div class="cbox">
<div class="md-conv" id="fund-dirac">
### Fundamentals and Dirac Notation 

Let $V$ be a finite dimensional vector space, where the vector coefficients are **complex**.


<b-blue>

***Def.*** We write a vector in $V$ as $\k{v} \in V$. This is called a **ket** vector and is a *column* vector.

</b-blue>


Generally we work in 2D vector spaces: $V_2$, with some chosen ortho-normal basis $\\{\k{0}, \k{1}\\}$

***Example.*** Some vector $\k{v}$ can be written as a decomposition of bases:
$$ \k{v} = a \k{0} + b \k{1} = \begin{bmatrix}
	a \\\\ b
\end{bmatrix} \pod{a, b \in \bb{C}} $$ 

<b-blue>

***Def.*** The **conjugate transpose** of vector $\k{v}$ is $\k{v}^\dagger$, and is made by transposing the vector and replacing its coefficients with their complex conjugates. This is a **bra** vector and is a row vector, and we reverse the direction of the brackets.

\begin{align}
	\b{v} = \k{v}^\dagger &= a^* \b{0} + b^* \b{1} \\\\
	&= \begin{bmatrix}
		a^*  & b^*
	\end{bmatrix}
\end{align}

</b-blue>

Let vector $\k{w} = c\k{0} + d \k{1}$.

<b-blue>


The **inner product** of $\k{v}$ and $\k{w}$ is written 
$$ \ip{v}{w} = \k{v}^\dagger \k{w} = \begin{bmatrix}
	a^* & b^*
\end{bmatrix} \begin{bmatrix}
	c \\\\ d
\end{bmatrix}
$$

</b-blue>

We can say that 
- $\ip{0}{1} = 0$ since the bases are ortho-normal,
- $\ip{i}{j} = \delta_{ij}$ for some $\k{i}, \k{j}$


> This is Dirac's "bra-ket" notation, which is just "bracket" without the c.

<b-blue>

***Def.*** The **Tensor product** of vectors (in a fixed basis) is defined as follows:

- Let vector spaces $V$ of dimension $m$, with basis $\k{e_1} \dots \k{e_m}$
- $W$ of dimension $n$ with basis $\k{f_1} \dots \k{f_n}$ 

The **tensor product space** $V \tens W$ has basis
$$ \\{ \k{e_i} \tens \k{e_j} : i = 1\cdots m , j = 1 \cdots n \\}  $$ 

i.e. there are $m \times n$ bases.


A general vector $\k{\xi} \in V \tens W$ is defined 
$$ \k{\xi} = \sum_{i, j} c_{ij} \k{e_i} \tens \k{e_j} $$ 

For coefficients $c_{ij}$ 


Let $\k{\alpha} \in V = \sum_{i=1}^m a_i \k{e_i}$, and $\k{\beta} \in W = \sum_{j=1}^n b_j \k{f_j} $.  Then the **tensor product** of two vectors is defined as:

\begin{align}
	 \k{\alpha} \tens \k{\beta} &= \sum_{i=1}^m a_i \k{e_i} \tens \sum_{j=1}^n b_j \k{f_j} \\\\
	 &= \sum_{\forall i, j} a_i b_j \k{e_i} \tens \k{e_j}
\end{align}

</b-blue>

> Whilst this is a rather... recursive definition, when we reach the fundamental bases (i.e. just have numbers) we can just perform the below operation.

***Example.*** Let:

$$\begin{matrix}
	\k{a} = \begin{bmatrix}
		0.1 \\\\ -0.7
	\end{bmatrix} & \k{b} = \begin{bmatrix}
		0.3 \\\\ 0.5
	\end{bmatrix}
\end{matrix}$$

Then 

$$ 
\k{a} \tens \k{b} = \begin{bmatrix}
	0.1 \\\\ -0.7 
\end{bmatrix} \tens \begin{bmatrix}
	0.3 \\\\ 0.5
\end{bmatrix} = \begin{bmatrix}
	0.1 \times 0.3 \\\\
	0.1 \times 0.5 \\\\
	-0.7 \times 0.3 \\\\
	-0.7 \times 0.5
\end{bmatrix}
$$

I.e. everything times everything.

Thus for fundamental bases $V_2 \sim \left\\{ \k{0} = \begin{bmatrix}
	1\\\\0
\end{bmatrix}, \k{1} = \begin{bmatrix}
	0\\\\1
\end{bmatrix} \right\\}$, we can get 

$$ 
\k{0} \tens \k{0} = \begin{bmatrix}
	1\\\\0
\end{bmatrix} \tens \begin{bmatrix}
	1\\\\0
\end{bmatrix} = \begin{bmatrix}
	1\\\\0\\\\0\\\\0
\end{bmatrix}
$$ 

And we can get all our other new bases the same way.

### Product and Entangled States

<b-blue>

***Def.*** Any vector $\k{\xi} \in V \tens W$ of the form $\k{\xi} = \k{a}\_{\in V} \tens \k{b}\_{\in W}$ is called a **product vector**.

</b-blue>
<p></p>
<b-blue>

Any vector which is *not* a product vector is an **entangled vector**.

</b-blue>
<p></p>
<b-blue>

***Def.*** The **k-fold tensor product***, denoted $\tens^k V\_2$ or $V^{\tens k}$ is the vector space 

$$ V_2 \tens V_2 \tens \cdots \tens V_2 \pod{k \textrm{ times}}$$

With $2^k$ bases, with each basis being denoted as a k-length bit string. 

Each basis is $\k{i_1} \tens \cdots \tens \k{i_k}$, but because $\tens$ is a bit of a pain it is often written as $\k{i_1}\k{i_2} \cdots \k{i_k}$ or just $\k{i_1i_2 \dots i_k}$.

</b-blue>

***Example.*** Let $\k{v} = 1\k{00} + 1\k{11}$. We claim that this is entangled.

To verify if it is entangled or not, we must demonstrate that it is or is not a product state. I.e. suppose 
$$ \k{v} = (a\k{0} + b\k{1}) \tens (c\k{0} + d\k{1}) $$ 
This resolves to 
$$ ac\k{00} + ad \k{01} + bc \k{10} + bd \k{11} $$ 
We get that $ac = bd = 0$ and $ad = bc = 1$, which is not possible to solve. Thus $\k{v}$ is entangled.


Generally for an arbitrary $\e{v} \in V_2 \tens V_2 = a_{00} \e{00} + a_{01} \e{01} + a_{10} \e{10} + a_{11} \e{11}$, 

$$ \e{v} \rm{ entangled } \iff \det(A) \neq 0 $$ 

Where 

$$ A = \begin{bmatrix}
	a_{00} & a_{01} \\\\ a_{10} & a_{11}
\end{bmatrix} $$

But this is *not true* in higher dimensions.

For general dimensions 

$$ \sum_{i=1}^m \sum_{i=1}^n A_{ij} \e{i} \e{j} \rm{ product vector } \iff \rm{ mat } A \rm{ is rank 1} $$

> Rank is a linear algebra term -- it is the number of columns (or rows, whichever is **smaller** that are linearly independent)

----- 

The inner product on general spaces $V \tens W$ is "induced by inner products on V and W applied slotwise". 

This is to say for product states $\e{a_1}\e{b_1}$ and $\e{a_2}\e{b_2}$, the inner product is 
$$ (\b{b_1}\b{a_1})(\k{a_2}\k{b_2}) \equiv \ip{a_1}{a_2} \ip{b_1}{b_2}.$$

----- 

When vectors come from the same subspaces tensored together, it is important to label which vector belongs to which space.

Tensor product is a commutative operation, so for subspaces $A, B$, we could have $\e{\alpha}_A \e{\beta}_B$ having the bra form $\b{\alpha}_A \b{\beta}_B = \b{\beta}_B \b{\alpha}_A$

</div>
</div>

<div class="colourband">
	<h2 id="qmps">Quantum Mechanical Principles</h2>
</div>

<div class="cbox">
<div class="md-conv">

### Principle 1 - On Physical States 

<b-blue>

The states of any isolated physical system $S$ are represented by unit vectors in complete vector space $V$, with an inner product $\ip{v}{v} = 1$

$\lra$ Any state is describable by unit vectors.

</b-blue>

***Ex.*** Take the simplest non trivial case of 1 qbit in 2-dimensional $V$.

Take bases $\e{0}, \e{1}$. The general state $\e{\psi} = a\e{0} + b\e{1}$.

$\lra \e\psi$ is a superposition of states $\e{0}, \e{1}$ with **amplitudes** $a, b \in \bb{C}$.
<!-- 我操竟能这样子 -->
<b-blue>

***Def.*** A **Qubit** is a quantum system with a 2D state space *and* a chosen ortho-normal basis labelled $\0, \1$. 

These are also called the $z-$, computational, or standard basis.

</b-blue>
<p></p>
<b-blue>

***Def.*** The **conjugate basis** for a qbit in the orth-norm basis $\0, \1$ is defined as 

\begin{align}
	\e+ &= \frac{1}{\sqrt{2}} (\0 + \1) \\\\
	\e- &= \frac{1}{\sqrt{2}} (\0 - \1)
\end{align}

This is rotated 45&deg; from the standard basis.

</b-blue>

</div>

<div class="md-conv">

### Princple 2 - Composite Systems

<b-blue>

Let system $S_1$ have state space $V_A$, $S_2$ have state space $V_B$;

Then the **joint system** $S_1 S_2$ has state space $V_A \tens V_B$.

</b-blue>

***Ex.*** Take $n$ qbits. Their state space is $\tens^n V_2$, with dimension $2^n$.

The standard basis is $2^n$ vectors of $n$ length bit strings $\e{i_1 \cdots i_n}$.

The $n$-bit state is a product state *if* 
- it is a tensor product of $n$ 1-qbit states $$ \e\psi = \e v_1 \e v_2 \cdots \e v_n $$ 
- Otherwise, $\e\psi$ is entangled.


In quantum computing as the number of qbits grow, the state description grows **exponentially**. 

However, for *product* states, the description only grows **linearly**. This describes a classical computing system.

#### Dirac and Linear Maps

Consider linear maps on $V_2$ 

> A linear map, or linear mapping on a 2D space is just a 2D transformation matrix.

Let $\e v = a\0 + b\1$ and $\e w = c\0 + d\1$, the *ket-bra product* gives 
$$ M = \e v \b w = \begin{bmatrix}
	a \\\\ b 
\end{bmatrix} \begin{bmatrix}
	c* & d* 
\end{bmatrix}$$ 
$$ = \begin{bmatrix}
	ac* & ad* \\\\ bc* & bd* 
\end{bmatrix} $$ 

This is a **linear map** on $V_2$ that projects a state down. That is to say,

For any vector $\e x = \begin{bmatrix}
	x_0 \\\\ x_1
\end{bmatrix} $,
$$ M \e x = (\e v \b w) \e x = \e v \ip w x $$

It turns into a scaled $\e v$. These are called **rank 1 mappings**.

Given 
\begin{matrix}
	\e 0 \b 0 = \begin{bmatrix}
		1&0 \\\\ 0&0
	\end{bmatrix} &
	\e 0 \b 1 = \begin{bmatrix}
		0&1 \\\\ 0&0
	\end{bmatrix} \\\\ 
	\e 1 \b 0 =\begin{bmatrix}
		0&0 \\\\ 1&0
	\end{bmatrix} &
	\e 1 \b 1 =\begin{bmatrix}
		0&0 \\\\ 0&1
	\end{bmatrix}
\end{matrix}

We can make any mapping $A$ as a weighted sum of these four. 

> Hopefully that's trivial.

<b-blue>

A **projection operator** is a special case of $M$ (above), with $\e v =\e w$ in any dimensions. And since vectors are normalised, $\ip v v = 1$.

$\Pi_v = \e v \b v$ is an operator projecting onto a 1D subspace spanned by $\e v$. It has these properties:

- $\Pi_v \Pi_v = \e v \b v \e v \b v = \Pi_v$ only.
- $\Pi_v \e v = \e v \b v \e v = \e v$. 
- $\Pi_v \e w = 0$ when $\e w$ is orthogonal to $\e v \pod{\e w \perp \e v} $

</b-blue>


Generally for any d-dimensional subspace E of an n-D space V, where E has basis $\\{ \e e_1 \cdots \e e_d \\}$, 

$$ \Pi_E = \e {e_1} \b {e_1} + \cdots + \e {e_d} \b {e_d} $$ 

is an operator projecting from $V \lra E$.


If $A = \begin{bmatrix}
	a & b \\\\ c & d
\end{bmatrix}, B = \begin{bmatrix}
	p & q \\\\ r & s
\end{bmatrix}$ are linear operators on $V_2$, 

Then $A \tens B : V_2 \tens V_2 \lra V_2 \tens V_2$ is defined by the action on the separate bases:
$$ \e i \e j \mapsto (A\e i)(B\e j)$$ 

This is also true for any general joint vectors.

To actually work out this matrix though, we would get a 4x4 matrix where each of the four quadrants is defined
$$ A \tens B = \begin{bmatrix}
	aB & bB \\\\ cB & dB
\end{bmatrix}. $$ 



</div>

<div class="md-conv">

### Principle 3 - Physical Evolution of Systems


<b-blue>

Any physical finite time evolution of a quantum system is represented by **unitary** linear operators on a vector space of states.

</b-blue>
<p></p>
<b-blue>

***Def.*** **Unitary matrices**: $U$ is unitary 

- **iff** $U^{-1} = U^\dagger$ (conjugate transpose);
- **iff** $U$ maps any orth-norm basis to any other orth-norm set of vectors.
- **iff** its columns or rows form an orth-norm set of vectors.

</b-blue>
<p></p>
<b-blue>

***Def.*** **Partial inner product:** On vectors in $V \tens W$:
- Take any ket $\e v \in V$, this defines a linear map $V \tens W \lra W$, which is the **partial inner product with $\e v$**.
- Which is defined on basis vectors $\e {e_i} \e {f_j} \in V \tens W$, and maps $$ \e {e_i} \e {f_j} \mapsto \ip v {e_i} \e f_j $$

If $V = W$, then we must specify *which* space is being used.

</b-blue>

***Example.*** Consider a state of 2 qbits 

$$ \e\psi = a\e{00} + b\e{01} + c\e{10} + d\e{11} \in V_A \tens V_B $$ 

Where $V = V_A = V_B$ and the first bit belongs to A, the second to B. 

We can form a partial inner product with $\0$ on either space:

\begin{align}
	_A\ip 0 \psi &= a \ip 0 0 _A \0_B + b\ip 0 0 _A \1_B + c \ip 0 1 _A \0_B + d \ip 0 1 _A \1_B \\\\
	&= a \0_B + b \1_B
\end{align}

Note that there is also the identity operator $I : A \tens I = I \tens A = A$ which is just the identity matrix.

</div>

<div class="md-conv">

### Principle 4 - Quantum Measurements and the Born Rule

> Getting information out of quantum states.
>
> Quantum measurements are invasive -- mmt changes state. 
> So even if a state has exponential info, we can only retrieve a small part of it **probabilistically**.
>
> And by doing so, change the system also.


Given a single instance $\e\psi$ of a quantum state in n-dimensional state space $V$.

<b-blue>

***Def.* The basic born rule:** (or a complete projective mmt / von neumann mmt)

- Let $B = \\{\e e_1 \cdots \e e_n\\}$ be a orth-norm basis of V. A state $\e\psi$ can be described a weighted sum of amplitude-bases:
$$ \e\psi = \sum_{i=1}^n a_i \e e_i $$ 

- Taking a measurement of this, we can get n possible outcomes $j = 1..n$, where the probability 
$$P(j) = \abs{\ip {e_j}{\psi}} ^2 = \abs{a_j}^2$$ 

- If outcome $j$ is seen, after mmt **the state is no longer $\e\psi$** but is **collapsed** to $\e{\psi_j} = \e {e_j}$.

</b-blue>

> A complete measurement is just a projection.

Thus repeated measurements on $\e{\psi_j}$ will only give outcomes $j$ forever with certainty.

The straight lines represent mod, and a probability is just the mod squared length of the **projection** of $\e\psi$ onto the given basis $\e {e_j}$. 

After projection, the state is **re-normalised** to have the squared mod sum of amplitudes equal 1 again.

<b-blue>

***Def.* Incomplete projective measurements:** 
- Let $\\{E_1 \cdots E_d \\}$ be a *decomposition* of $V$ into $d$ **mutually orthogonal** subspaces. 
- That is to say, $V = E_1 \oplus \cdots \oplus E_d$ where $\oplus$ is the "direct sum operator"
- Let $\Pi_i$ be a projection operator onto $E_i$.
- An incomplete mmt of $\e\psi$ w.r.t. the decomposition  $\\{E_1 \cdots E_d \\}$ has 
	- d possible outcomes $j = 1..d$
	- Where the probability ("Tr" is trace)
	$$P(j) = \ip{\psi}{\Pi_j^\dagger \Pi_j \vert \psi} = \ip{\psi}{\Pi_j \vert \psi} = \rm{Tr}(\Pi_j \e\psi \b\psi)$$ 
	- Where the post-mmt state is a collapsed normalised vector 
	$$ \e{\psi_j} = \frac{\Pi_j \e\psi}{\sqrt{P(j)}}$$ 

</b-blue>

> No, I don't know what a "direct sum" is either, nor a "Trace"

***Example.*** Parity measurements on two qbit states. 

The **parity** of a bit string $b_1b_2$ is just the mod-2 sum $b_1 \oplus b_2$. Alternatively, it's 1 if there are an odd number of 1s.

Make an orth-norm decomposition of the state $V$ as 
- $E_0 = \span(\e{00}, \e{11})$ :- parity zero
- $E_1 = \span(\e{01}, \e{10})$ :- parity one 

Let $\e\psi = a\e{00} + b\e{01} + c\e{10} + d\e{11}$ 
- The prob of measuring zero $P(0) = \abs{a}^2 + \abs{d}^2$
- The post-measure state $\e{\psi_0} = \frac{a\e{00} + d\e{11}}{\sqrt{\abs{a}^2 + \abs{d}^2}}$

----- 

*Addendum.* define measurement of quantum observables. 

<s-side>

***Def.*** A **quantum observable** $\Omega$ is
- a *hermitian* operator (matrix) on $V$ (meaning $\Omega$ has real eigenvalues $\lambda_{1..d}$) 
- which breaks into orthogonal $\Lambda_j : \dim(\Lambda_j) =$ the multiplicity of $\lambda_j$ (how many times that eig-val appears)
</s-side>
<s-side>

***Def.*** The measurement of such quantum observables is an incomplete mmnt which is relative to this orthogonal decomposition, and labelled by $\lambda_j$. 

</s-side>

The $\lambda_j$ values are the physical properties, and the average value of $\Omega = \sum_{j} \lambda_j P(j)$.

------

<b-blue>

***Def.* the Extended Born Rule**: 
- A special case of incomplete mmnts,
- measuring a component part of a complete system, to only partially destroy it.

Suppose $\e\psi$ is a state of system $S_1 S_2$, which is in a space $V \tens W$. 

Let bases
- $B_V = \\{\e{e_1} \cdots \e{e_n} \\}$ on V;
- $B_W = \\{\e{f_1} \cdots \e{f_m} \\}$ on W.

Then $\e\psi$ can be uniquely expanded as 
$$ \sum_{\forall i,j} c_{ij} \e{e_i} \e{f_j} $$ 

We now label the subspaces (so psi becomes $\e\psi_{VW}$), and we can expand this state as 
$$ \sum_{i=1}^n \e{e_i}_V \e{\xi_i}_W $$ 
Where $\e{\xi_i}$ is some arbitrary vector in the space W, which is generally **not** normalised nor orthogonal. (in reality $\e{\xi\_i}_W =\\, _V\ip{e\_i}{\psi}\_{VW}$)

Since $\e\psi_{VW}$ is normalised, we know that $\sum_{i=1}^n \ip{\xi_i}{\xi_i} = 1 = \ip\psi\psi$, and so we can perform a mmnt on $\e\psi$ relative to basis $B_V$ 
- A *complete measurement on $V$ but not $V \tens W$*

We have:
- outcomes $i = 1..n$, 
- corresponding orthogonal subspaces of $V \tens W$:
$$E_i = \span\\{ \e{e_i} \tens \e\xi : \xi \in W \\}$$ 
or by abusing notation $\e{e_i} \tens W$;
- which have projectors $\Pi_i = \e{e_i}\b{e_i} \tens I_W$ (identity), which we get with probability $P(i) = \ip {\xi_i}{\xi_i}$ 
- And post measurement state 
$$ \e{\psi_i} = \frac{\e{e\_i}_V \e{\xi\_i}_W}{ \sqrt{\ip{\xi\_i}{\xi\_i}} }. $$

</b-blue>

Some remarks:
- Orthogonal states are perfectly distinguishable, but non-orthogonal states are **not** completely distinguishable even if physically different.
- If $\e\psi$ has dimension $n$, any measurement on it has at most $n$ outcomes
- **But** if we adjoin it with a known quantum state, an **ancilla** $\e A$ of dimension m, that is independent of $\e\psi$, then we can measure them jointly ($\e\psi \e A$) to get $m\cdot n$ outcomes.

</div>

<div class="md-conv">
### Basic Unitary Operators for Qubits

#### Single Qubits 

We have unitary operators for single qbits.

***Hadamard Gate.***
$$ H = \frac{1 }{\sqrt{2} } \begin{bmatrix}
	1 & 1 \\\\ 1 & -1
\end{bmatrix} $$ 

This is a gate with the following properties:
- $HH = I$. 
- $H \0 = \frac{1 }{\sqrt{2} }(\0 + \1) = \e+$
- $H \1 = \frac{1 }{\sqrt{2} }(\0 - \1) = \e-$

> This is just a rotation of 45&deg; to the +/- bases.

***Pauli Gates.***
\begin{matrix}
	I = \begin{bmatrix}
		1 & 0 \\\\ 0 & 1
	\end{bmatrix} &
	\sigma_x = \begin{bmatrix}
		0 & 1 \\\\ 1 & 0
	\end{bmatrix} & 
	\sigma_y = \begin{bmatrix}
		0 & -i \\\\ i & 0
	\end{bmatrix} & 
	\sigma_z = \begin{bmatrix}
		1 & 0 \\\\ 0 & -1 
	\end{bmatrix}
\end{matrix}

These are all unitary hermitian operators, with the following properties:
- Multiplicative properties: $\sigma_x^2 + \sigma_y^2 + \sigma_z^2 = I$ 
	- This also implies the eigenvalues are $\pm 1$.
- Anti-commute properties: $\sigma_x\sigma_y = -\sigma_y\sigma_x = i\sigma_z$ 
	- These can be swapped with any combination of $x,y,z$ as long as they are in that order.

Pauli gates also have real versions:
\begin{matrix}
	X = \sigma_x & 
	Y = i\sigma_y = \begin{bmatrix}
		0 & 1 \\\\ -1 & 0
	\end{bmatrix} & 
	Z = \sigma_z
\end{matrix}

Such that 
- $X\0 = \1$, and $X\1 = \0$ -- *quantum NOT gate* 
	- i.e. $X\e k = \e{k \oplus 1} \pod{k=0,1}$ 
	- X's eigenbases are $\e+, \e-$ 
- $Z\0 = \0$, and $Z\1 = -\1$
	- i.e. $Z\e{k} = (-1)^k \e{k}$ 
	- Z's eigenbases are $\0, \1$

***Phase Gate.*** 
$$ P(\theta) = \begin{bmatrix}
	1 & 0 \\\\ 0 & e^{i\theta}	
\end{bmatrix}$$ 

Where $\theta$ is the angle of rotation. 

#### Double Qubits 

***Controlled X-gate.*** Also called CNOT, CX, controlled-NOT, etc. 

Where 
$$ CX \e j \e k = \e j \e{j \oplus k} = \e j X^j \e k$$ 
- That is, if $\e j$ is zero, do not apply the gate, and if $\e j$ is one, then apply $X\e k$. 
- $CX \0 \e\alpha = \0\e\alpha$ whilst $CX \1 \e\alpha = \1 X\e\alpha$. 

CX operates over two bits, thus the CX matrix is a 4x4 that:
$$ 
CX = \left[ \begin{array}{c:c} 
I & \mathbf{0} \\\\ \hdashline
\mathbf{0} & X 
\end{array} \right] = \begin{bmatrix}
	1&0&0&0\\\\0&1&0&0 \\\\ 0&0&0&1 \\\\ 0&0&1&0
\end{bmatrix}
$$

Note that the **order is important** to CX, and so often it is labelled with `12` or `21` with `1` being the control bit, and `2` being the applied bit. So
- $CX_{12} \0_1 \1_2 = \0_1 \1_2$ 
- $CX_{21} \0_1 \1_2 = X\0_1 \1_2 = \1_1 \1_2$

***Controlled Z-Gate.*** 
$$
CZ_{12} \e j \e k = \e{j} Z^j \e k = (-1)^{jk} \e j \e k
$$ 
CZ is **symmetric**: so the order actually doesn't matter, and 
$$ 
CZ = \left[ \begin{array}{c:c} 
I & \mathbf{0} \\\\ \hdashline
\mathbf{0} & Z 
\end{array} \right]
$$

***General Controlled Gate $CU$.*** Has the form 
$$ 
CU = \left[ \begin{array}{c:c} 
I & \mathbf{0} \\\\ \hdashline
\mathbf{0} & U 
\end{array} \right]
$$ 

</div>



</div>

<div class="colourband">
	<h2 id="qinfo">Quantum Information</h2>
</div>

<div class="cbox">
<div class="md-conv">

### Quantum States as Information Carriers

A qbit is the simplest system that can reliably encode a classical bit.

Information is proportional to the number of distinguishable states of a physical system.
- Classically, any two different states are distinguishable (trivially)
- Quantumly, states are **distinguishable** $\iff$ they are **orthogonal**
	- So if you take $\0$ and $\e+$, and a black box that outputs any one of the two, it is **impossible** to certainly identify which one it is.

Given some quantum information $\e\psi$, we can do 3 basic things:

1. **Ancilla.** Take a fixed known quant-state $\e A$ and adjoin it to our state to get a bigger one: $\e{\tilde{\psi}} = \e\psi \e A$.
2. **Unitary.** Apply a unitary operator $U$ 
3. **Measure.** Take a measurement on all or part of $\e\psi$, thus 
	- Can record result 
	- And based on outcomes choose further steps 
	- Output is generally probabilistic. 

And **any combination of the 3**.


### The No Cloning Theorem

> Quantum information cannot be copied or cloned.

Copying classical information is trivial. To relate it to operators, we can just use a CNOT operator. 

More generally, any copying process has the form
- $(b) (0) (M)$ an information register (with $b$), a blank register (with 0), and an internal machine state $M$ which is in the **Ready** state 
- And goes to $(b) (b) (M_2)$ with the blank register having the copy, and the machine state being $M_b$ post copy (since it can change during copy.)

$$ (b) (0) (M) \lra_{CNOT} (b)(b)(M)$$ 

Quantumly:
- Given some information $\e\psi_A$,
- Copying is a *quantum evolution* process of subsystems $A, B, M$. We want 
$$ \e\psi_A \0_B \e{M\_0}\_M \lra\_? \e\psi\_A \e\psi\_B \e{M\_\psi}_M $$
- Where B is the blank register space, and M is any extra space needed, which is initially in ready state $M_0$ independent of $\e\psi_A$. 

<b-blue>

***Theorem.*** **No cloning theorem** (Unitary version)

Let $S$ be any known set of quantum states of system $A$, that contains at least one pair $\e\xi, \e\eta : \e\xi \neq \e\eta$ and they are orthogonal. 

Then there exist **no unitary process** that achieves cloning of all states in $S$. 

</b-blue>

Remarks:
- If $\e\xi = \e\eta$, then there is only one state and it clones fine 
- If $\e\xi \perp \e\eta$, then they can also clone fine (can rotate to $\0, \1$ and apply CX)
	- So $CX \e k \0 = \e k \e k : k = 0,1$, 
	- but $CX(a\0 + b\1)\0 = a\e{00} + \e{11} \neq (a\0 + b\1)(a\0 + b\1)$. 
- No unitary process means no combination of operations above. 

<s-side>

***Proof.*** Let $\e\xi, \e\eta$ be two different non-orth states. Then we require the cloning process to 
$$ \e\xi\_A \0_B \e{M\_0}\_M \lra\_U \e\xi_A \e\xi_B \e{M\_\xi}_M $$ 
$$ \e\eta\_A \0_B \e{M\_0}\_M \lra\_U \e\eta_A \e\eta_B \e{M\_\eta}_M $$ 

***Note.** Unitary processes preserve inner products.*

Therefore
\begin{align}
	\ip\xi\eta \ip00 \ip{M_0}{M_0} &= \ip\xi\eta \ip\xi\eta \ip{M_\xi}{M_\eta}\\\\
	\implies \ip\xi\eta &= \ip\xi\eta \ip\xi\eta \ip{M_\xi}{M_\eta}
\end{align}
Since anything inner prod itself = 1 (in normalised vectors).

Since $\e\xi \neq \e\eta$, we know $0 &lt; \ip\xi\eta &lt; 1$, and $0 \leq \ip{M_\xi}{M_\eta} \leq 1$ (we don't really care what the machine state is)

Thus 
$$ 1 = \ip\xi\eta \ip{M_\xi} {M_\eta}  $$
Which is a contradiction since neither of the two terms on the right can ever multiply to 1. $\Box$

</s-side>

> However we *can* copy information with a good probability.

### Indistinguishability of Non-Orthogonal States

- *Given.* an unknown state $\e\psi$ of any dimension,
- *Promise.* $\e\psi$ is either $\e{\alpha_0}$ or $\e{\alpha_1}$, which are distinct known states 
- *Problem.* must determine which state $\e\psi$ is 

We know we cannot do this with certainty if $\ip{\alpha_0}{\alpha_1} \neq 0$.

***State Estimation Process.*** 
Given a state $\e\psi$, we can (1) adjoin an ancilla $\e A$, (2) do a unitary, or (3) perform a measurement.

By adjoining $\e A$ we can change the problem to discriminating against $\e{\alpha_0}\e A$ against $\e{\alpha_1}\e A$, **but** the inner product remains the same.

*The process.* Let us have a state estimation process $M_1$. We do a unitary U, followed by measurements $\Pi_0, \Pi_1$, i.e. a "rotated measurement", where the new projectors are:
$$
\tilde\Pi_i = U^\dagger \Pi_i U \pod{i=0,1}
$$
For any $\e\xi: P_{M_1}(i) = (\b{\xi}U^\dagger) \Pi_i (U\e\xi)) = \langle \xi | U^\dagger \Pi_i  U | \xi \rangle$, which becomes $\ip{\xi}{\tilde\Pi_i | \xi}$, so our rotated mnt is just a single mnt in reality.

Some measurements are better than others at giving a correct measurement -- introduce a *figure of merit*, a **success probability** $P_s$.

We assume no prior information about the state -- prior probabilities are $\frac{1}{2}$, so
$$
P_s = \frac{1}{2}P(0|\alpha_0) + \frac{1}{2}P(1|\alpha_1)
$$
Which by the born rule becomes
$$
P_s = \frac{1}{2} (\ip{\alpha_0}{\Pi_0|\alpha_0}+\ip{\alpha_1}{\Pi_1|\alpha_1})
$$
which since $\Pi_1 = I - \Pi_0$ we can write in terms of successful and mistaken inference of alpha-0:
$$
\begin{align*}
P_s &=  \frac{1}{2} + \frac{1}{2}(\ip{\alpha_0}{\Pi_0|\alpha_0} - \ip{\alpha_1}{\Pi_0|\alpha_1})\\\\
&= \frac{1}{2} + \frac{1}{2}\Tr(\Pi_0)(\e{\alpha_0}\b{\alpha_0} - \e{\alpha_1}\b{\alpha_1}) \pod{\dagger}
\end{align*}
$$
> Tr is the trace, the sum of diagonal elements.

And we want to find an optimal Pi-zero projector. Let $D = \e{\alpha_0}\b{\alpha_0} - \e{\alpha_1}\b{\alpha_1}$, we know D is hermitian, thus its eigenvalues are real. Therefore it has a complete eigenbasis of orthonormal states. 

Let $\e\beta : \e\beta \perp \e{\alpha_0}, \e{\alpha_1}$, and so
$$
D\e\beta = \e{\alpha_0}\ip{\alpha_0}\beta - \e{\alpha_1}\ip{\alpha_1}\beta = 0
$$
so D only has 2 nonzero eigenvalues. 

The trace of D is zero (the reason is left as an excersise), and so the sum of the eigenvalues is also zero. Let the eigenvalues be $\delta, -\delta$, with eigenstates $\e p, \e m$, and so $D = \delta\e p - \delta\e m$. 

We want to determine delta in terms of the alphas, so we work in subspaces of the two alphas. We need a new basis for each, so 
- Choose $\e{\alpha_0^\perp}$ to be orthnorm to $\e{\alpha_0}$, so $\e{\alpha_0^\perp}, \e{\alpha_0}$ forms a basis.
- *Let* $\e{\alpha_0} = \begin{bmatrix} 1 \\\\ 0 \end{bmatrix}; \e{\alpha_1} = \begin{bmatrix} c_0 \\\\ c_1 \end{bmatrix} = c_0\e{\alpha_0} + c_1 \e{\alpha_0^\perp}$.
Find the new coefficients by taking inner products of each base with the original vector:
- $c_0 = \ip{\alpha_0}{\alpha_1}$, $|c_1| = \sin\theta$, and $|\ip{\alpha_0}{\alpha_1}| = \cos \theta$ for the angle between the two vectors (presumably)
And so 
$$
D = \begin{bmatrix} 1 \\\\ 0 \end{bmatrix}\begin{bmatrix} 1 & 0 \end{bmatrix} -
\begin{bmatrix} c_0 \\\\ c_1 \end{bmatrix}\begin{bmatrix} c_0^* & c_1^* \end{bmatrix} = \begin{bmatrix} 
|c_1|^2 & -c_0c_1^* \\\\ -c_1c_0^* & -|c_1|^2
 \end{bmatrix}
$$
We want the eigenvectors, i.e. to solve the characteristic equation $\det(D = \lambda I) = 0$
- From this we get $\lambda = |c_1| = \pm \sin\theta$, and so $\delta = \sin  \theta$.
- Substituting into ($\dagger$)
$$
\begin{align*}
P_s &= \frac{1}{2} + \frac{\delta}{2}\Tr(\Pi_0)(\e p \b p - \e m \b m)\\\\
&= \frac{1}{2} + \frac{\delta}{2}(\b p \Pi_0 \e p - \b m \Pi_0 \e m)
\end{align*}
$$

For any projector $\Pi$ and arbitrary state $\e\xi$, we have that 
$$0 \leq \b\xi \Pi \e\xi \leq 1$$
And so $P_s$ achieves a maximum value when the LH term in the bracket goes to 1, and RH goes to 0, i.e.
$$
P_s = \frac{1}{2} + \frac{\delta}{2} = \frac{1}{2}(1+\sin\theta)
$$
When states are orthogonal, $\sin\theta = 1$, and the success chance is 1. If states are aligned, then success is zero, and somewhere in between etc.

> So how do we find $\Pi_0$?

If this is chosen to be any projection in a subspace that
- contains $\e p \implies \Pi_0 \e p = \e p$
- orthogonal to $\e m \implies \Pi_0 \e m = \e m$
Such a chance is **always possible**, since they are orthogonal, and so the achievable bound 
$$
P_s \leq \frac{1}{2}(1 + \sin\theta).
$$

> This is the *Helstrom Holevo* bound

***Note.*** 
- The ancilla is **never needed**, since only the inner product is relevant.
- If the two alphas are qubit states, we can just work in 2D space
- Optimal discrimination mnt is a **complete** mnt of a quantum observable D. 

<b-blue>

***Theorem.* Helstrom-Holevo Bound**

Given one of two equally likely states $\e{\alpha_0}, \e{\alpha_1}$ with $|\ip{\alpha_0}{\alpha_1}| = \cos \theta$, then the probability of correct identification is bounded **tightly** by
$$P_s \leq \frac{1}{2}(1 + \sin\theta)$$

</b-blue>

Remark: Other disambiguation processes are possible. We could have an **unambiguous discrimination** with three outcome states: 0, 1, fail, where fail occurs when it is neither certainly 0 nor 1.

### No Signalling Principle

***The standard setup.*** 
- We have two people, Alice and Bob, who are distantly separated in space. <span class="grey">This is an arbitary distance, and can be quite close or very far</span>
- Each hold a local quantum system A, B respectively.
- Initially, A, B is in the same (possibly entangled) quantum state. 
- Each can apply local actions on their own systems.

***The issue.*** Suppose Alice performs a local measurement on A. 

The born rule says that for each measurement outcome $k$ on A, the state at B will "instantaneously change" to reflect measurement collapse to a post-mnt state $\e{\beta_k}$.

Can B notice this change by only local actions? i.e. can we have faster-than-light information panel?

(No.)

Consider local operations on composite system $\e\psi_{AB}$. Let $H_A, H_B$ be the state space of A and B, i.e. $H_{AB} = H_A \tens H_B$. 

【Local ancilla】 Alice and bob can adjoin local ancilla spaces $A', B'$ to enlarge the dimension of their local systems.

【Local unitary】 Alice can perform a local unitary on her own half respective to B's system:
$$
\begin{matrix}U_A \tens I_B \pod{\rm{Alice}} & I_A \tens U_B \pod{\rm{Bob}}\end{matrix}
$$
**Note** that unitary operators on disjoint subsystems always commute: i.e. they can be done in any order $\lra U_A \tens U_B$. 

【Local measurement】 Say Alice performs mnt on A with some orth subspaces $E_a$, and projectors $\Pi_a$. She will have outcomes $a$. Note that the space is made as 
$$
H_A  = \oplus_a E_a
$$
like before. 

A full span measurement effect is represented by the subspace $E_a \tens H_B$, and is gotten by projector $\Pi_a \tens I_B$ over $H_{AB}$.

Similarly Bob can do the same for B, to get subspaces $F_b$ and outcomes $b$ by projectors $\Pi_b$.

By the born rule we can obtain a joint prob dist $P(a,b)$ by performing the corresponding measurements independently and getting subspace $E_a \tens F_b$, and these projectors commute.

<b-blue>

***Theorem.* No signalling principle**

Suppose Alice and Bob have access to local states A, B and a joint quantum system $\e\psi_{AB}$. Alice **cannot** convey any information to Bob by performing local operations.

i.e. no local action by Alice can change the output probability of any local quantum process of Bob

</b-blue>

<s-side>

***Proof.*** Consider a case when bob performs a complete mnt on B, w.r.t bases $\{\e b_B\}$ and outcomes $b$. 

Firstly, alice does nothing, and the state can be represented using this basis as
$$
\e\psi_{AB}  = \sum\limits_{\forall b} \e{\xi_b}_A \e b \pod{\dagger}
$$
For some xi vector where $\e{\xi\_b}\_A = \ip{b}{\psi}\_{AB}$ -- just converting bases. These are the *conditioned states of A given b*. By the born rule $P(b) = \ip{\xi\_b}{\xi\_b}$.

Now suppose alice does complete measurement w.r.t bases $\{\e a \}$ and outcomes $a$, projectors $\Pi_a = \e{a}\b{a}$. In $(\dagger)$ this becomes
$$
P(a) = \left\lVert \sum\limits\_{\forall b} (\Pi_a \e{\xi\_b}\_A) \e b\_B \right\rVert
$$
And the post measurement state is
$$
\e{\psi\_a}\_{AB} = \frac{1}{\sqrt{P(a)}}\sum\limits\_{\forall b} (\Pi\_a \e{\xi\_b}\_A) \e b\_B \pod{\ddagger}
$$

Suppose alice obtains $a$, and now bob does a measurement. $P(b|a)$ is the l2 squared of the projection of $(\ddagger)$ onto $\e b$:
$$P(b|a) = \lVert \Pi_a \e{\xi_b} \rVert^2 = \b{\xi_b} \Pi_a \e{\xi_b}$$
Therefore
$$
P(b) = \sum\limits_{\forall a}\b{\xi_b} \Pi_a \e{\xi_b} = \b{\xi_b} \sum\limits_{\forall a} \Pi_a \e{\xi_b} = \b{\xi_b} I\e{\xi_b}
$$
Which is just $\ip{\xi_b}{\xi_b} = P(b)$, so no matter what alice does, bob's measurement probabilities doesn't change. $\Box$

</s-side>

Remarks:
- This generalises to incomplete measurements -- if you sum over the projectors it gives the identity
- Unitary preserve inner products and so local unitaries won't work either
- Therefore there is no FTL transfer.



</div>
</div>

<div class="colourband">
	<h2 id="qit">Quantum Information Transfer</h2>
</div>

<div class="cbox">
<div class="md-conv">

### Quantum Dense Coding 

We know that a single qbit can only reliably encode one bit of information. i.e. you can only send one bit per qbit... right?

Well with some quantum f\_ckery we can send more information, if the qbit being sent is already entangled with a qbit at the receiver. This lets us send **2 bits** of information per qibt.

<b-blue>

***Def.*** **Bell states**, or bell basis, is defined by the following: 

\begin{align*}
\e{\phi^+} &=  \frac{1}{\sqrt{2}}(\e{00} + \e{11})\\\\
\e{\phi^-} &=  \frac{1}{\sqrt{2}}(\e{00} - \e{11})\\\\
\e{\psi^+} &= \frac{1}{\sqrt{2}}(\e{01}+\e{10})\\\\
\e{\psi^-} &= \frac{1}{\sqrt{2}}(\e{01}-\e{10})
\end{align*}

These states are orthogonal, and the bell basis for 2 qbits are give by these four:
$$
\\{ \e{\phi^+}, \e{\phi^-}, \e{\psi^+}, \e{\psi^-} \\}
$$

</b-blue>

Notably, whereas the 2 qbit computational basis (00 01 10 11) are all product states, these are all **entangled**. Also,

\begin{align}
\e{\phi^+} &= I \tens I \e{\phi^+} \\\\	
\e{\phi^-} &= Z \tens I \e{\phi^+} \\\\	
\e{\psi^+} &= X \tens I \e{\phi^+} \\\\	
\e{\psi^+} &= Y \tens I \e{\phi^+} \\\\	
\end{align}

And for any one qbit unitary U:

$$ U \tens I \e{\phi^+} = I \tens U\t \e{\phi^+} $$

We can also make these states by applying operations to the computational basis:

$$
\0\0 \overset{H \tens I}{\lra} \e+\0 = \frac{1}{\sqrt{2}}(\0 + \1)\0 \overset{CX_{12}}{\lra} \e{\phi^+}
$$

This works over the other three states and produces the other three bases.

<s-side>

***The quantum dense coding protocol.*** Let Alice and Bob (A and B) be distantly separated in space, and each has one qbit of the entangled $\e{\psi^+}$ state. A wants to send 2 bits of B, so she does:

1. A applies $I,X,Z,Y$ respectively to her (first) qbit, to make the state $\e{\phi^+}, \e{\phi^-}, \e{\psi^+}, \e{\psi^-}$, which encode messages 00, 01, 10, 11.
2. A sends this qbit to B
3. B does a **bell measurement** on both qbits together.

</s-side>
<p></p>
<b-blue>

***Def.*** A bell measurement is one of four projectors in the bell basis:

\begin{matrix}
	\Pi_0 = \e{\phi^+}\b{\phi^+} & \Pi_2 = \e{\psi^+}\b{\psi^+}  \\\\
	\Pi_4 = \e{\phi^-}\b{\phi^-} & \Pi_3 = \e{\psi^-}\b{\psi^-}
\end{matrix}

</b-blue>

### Quantum Teleportation 

A protocol to send quantum information, in the **LOCC** (local operation and classical communication) paradigm. I.e. A and B can do local quantum operations but can only communicate through classical channels.

Classical channels can mean anything, such as a phone line.

A and B are separated in space, but each have an entangled state $\e{\phi^+}$. 

A has another qbit in some arbitrary state $\e\alpha$, which is possibly unknown, and wants to send this to B without directly sending it over. A cannot identify $\e\alpha$ without destroying it, and the space between A and B is hostile to quantum transfer.

<s-side>

***The protocol.*** A can transfer $\e\alpha$ to B using the entanglement of $\e{\phi^+}$, without anything being passed through space. Let the qbit labels:

- 1: The input qbit $\e\alpha$ (owned by A)
- 2: The first qbit of entangled $\e{\phi^+}$ (owned by A)
- 3: The second qbit of entangled $\e{\phi^+}$ (owned by B)

The initial state is $\e\alpha_1 \e{\phi^+}_{23}$, where $\e\alpha = a\0 + b\1$ for some amplitudes. We have that 
\begin{align}
\e\alpha \e{\phi^+} &= (a\0 + b\1) \tens \frac{1 }{\sqrt{2} } (\e{00} + \e{11}) \\\\
&= \frac{a}{\sqrt{2}}\e{000} + \frac{a}{\sqrt{2}}\e{011} + \frac{b}{\sqrt{2}}\e{100} + \frac{b}{\sqrt{2}}\e{111} \pod{\dagger}
\end{align}

We perform the following steps.

1. A applies $CX_{12}$ to 1 and 2.
2. A applies $H$ to 1 
3. A measures both qbits in computational basis, and obtains one of 00, 01, 10, 11

(Note that this is equivalent to a bell measurement on 12)

</s-side>

We can look at the effects of these steps on $(\dagger)$:

\begin{matrix}
	\frac{a}{\sqrt{2}}\e{000} + \frac{a}{\sqrt{2}}\e{011} + \frac{b}{\sqrt{2}}\e{100} + \frac{b}{\sqrt{2}}\e{111} \\\\
	\Big\downarrow CX_{12} \\\\
	\frac{a}{\sqrt{2}}\e{000} + \frac{a}{\sqrt{2}}\e{011} + \frac{b}{\sqrt{2}}\e{110} + \frac{b}{\sqrt{2}}\e{101} \\\\
	\Big\downarrow H_1 \\\\
	\frac{a}{\sqrt{2}}(\frac{\0 + \1}{\sqrt{2}})\e{00} + \frac{a}{\sqrt{2}}(\frac{\0 + \1}{\sqrt{2}})\e{11} + \frac{b}{\sqrt{2}}(\frac{\0 - \1}{\sqrt{2}})\e{00} + \frac{b}{\sqrt{2}}(\frac{\0 - \1}{\sqrt{2}})\e{11} \\\\
	= \\\\
	\frac{1 }{2 } (\e{00}(a\0 + b\1) + \e{01}(a\1 + b\0) + \e{10}(a\0 - b\1) + \e{11}(a\1 - b\0)) \\\\
	= \\\\
	\frac{1}{2} (\e{00}I\e\alpha + \e{01}X\e\alpha+ \e{01}Z\e\alpha+ \e{01}Y\e\alpha)
\end{matrix}

Therefore via the born rule we get 

Outcome | Post measurement state | Probability
-|-|- 
00 | $ \e{00}_{12}\e\alpha_3$  | 0.25
01 | $ \e{01}_{12}X\e\alpha_3$  | 0.25
10 | $ \e{10}_{12}Z\e\alpha_3$  | 0.25
11 | $ \e{11}_{12}Y\e\alpha_3$  | 0.25

I.e. for outcome $\e{ij}$ the post measurement state has transformation $X^jZ^i$ applied. 

<s-side>

A then sends the 2 bit outcome to B, so B knows which state alpha is in.

B applies the back-transform $Z^iX^j$ to his 3 state, and the state becomes just $\e\alpha$. 

</s-side>

Teleportation!

***Quantum Circuit diagram.***

Quantum processes like this can be represented as a circuit diagram with time moving along the x axis:

![teleportation circuit diagram](./qcircuit.png)

Double lines represent classical information transfer.

Remarks:
- After teleportation, A is left, uniformly randomly, with one of the four 2 q-bit states 00, 01, 10, 11. I.e., *no information* is left at A (and consistent with no cloning and no signalling)
- Before A's measurement, B's qbit is half of the $\e{\psi^+}$ state, and we can show that any complete measurement on that would give a random outcome.
- After A's measurement, B's qbit is one of the four results all with 0.25 probability. Any complete measurement would thus result in 0 or 1 with prob 1/2.
- The *physical system* of $\e\alpha$ is not transferred, only the identity/information being reconstructed exactly in a *different* system.

</div>
</div>	

<div class="colourband">
	<h2 id="qcyp">Quantum Cryptography</h2>
</div>

<div class="cbox">
<div class="md-conv">

### Background 

Quantum cryptography takes advantage of non-orthogonal states to encode information. The receiver can thus not read message reliably, and furthermore any reading will destroy the message. 

This may be inconvenient for the sender and receiver, but much more for an eavesdropper, Eve (E).

First, we talk about classical systems.

***Secret Sharing*.** The most primitive ciphers are like the caesar cipher. For it to work, the sender and receiver must pre-share an agreed secret, the permutation to un-transform the ciphertext. This is *symmetric* encryption.

The problem with a lot of these systems is that they can be cracked, whether easily (e.g. caesar) or not. Only the **one time pad** is provably secure. Furthermore, a secret key must always be shared, which could be intercepted.

***Public Key Cryptography.*** Using *asymmetric* public private key pairs to encrypt and decrypt data.

There are many different schemes, such as RSA, but they all rely on unproved assumptions about computational hardness (i.e. $P \neq NP$), which could (but probably won't) be disproved, or skirted by using quantum computing f\_ckery.

#### The One-time Pad.

Let the message be a bitstring M of length $n$. 

Encryption/decryption requires A and B to share a private key K, also of length $n$, known **only** to them.

- A encrypts by adding K to M bitwise mod 2 (i.e. XOR). The ciphertext $C = K \oplus M$ 
- Be decrypts by doing the exact same thing. 

If K is *uniformly random*, then C is also random, and an eavesdropper seeing C would get no useful information. 

However, K must only ever be used **once**, else it could be broken. If we have two $C_1 = M_1 \oplus K$ and $C_2 \oplus K$, then an eavesdropper can do $C_1 \oplus C_2 = M_1 \oplus M_2$ and get information.

Further to this, we have to send the key in the first place.

### Quantum Key Distribution

Methods to send a key in a quantumly secure manner.

Suppose A, B are distantly separated in space, and can communicate quantumly and classically. There is an eavesdropper E who can read and access both these channels.

For quantum transmissions, we have:
$$
\begin{matrix}
	\e{\psi_{00}} = \0 & \e{\psi_{01}} = \e+ \\\\
	\e{\psi_{10}} = \1 & \e{\psi_{11}} = \e- 
\end{matrix}
$$
Given over two orth-norm basis $B_0 = \0, \1$ the Z eigenbasis, and $B_1 = \e+, \e-$ the X eigenbasis, which are called **mutually unbiased bases**.

Let bit value 0 be encoded in one of $\0, \e+$, and a 1 be encoded in one of $\1, \e-$. This means $\e{\psi_{ij}}$ has a bit value $i$ in basis $B_j$.

***Mutually Unbiased Bases.*** (MUB) A set of MUB on $\bb{C}^d$ is a set of orthnorm bases s.t. any vector of a basis is an **equally weighted superposition** of vectors in any other basis:
$$
|\ip{e_i}{f_j}|^2 = \frac{1}{d} \pod{\forall i, j \in \{\e{e_i}, \e{f_j}\}}
$$ 

I.e. $\0, \1$ are both equal weighted probabilities of the plus-minus basis, and vice versa.

There are a couple things about $N$ the max number of MUBs in dimension $d$:
- $d=2 \implies N = 3$ being the Z, X, Y eigenbases.
- For any $d$ that is **prime**, $N = d+1$ 
- For any $d$ that is **not** prime, we only know a bound for N, that is if $d = p_1^{n_1} p_2^{n_2} .. p_k^{n_k} \pod{p_1 \lt p_2 \lt \cdots \lt p_k}$ breaks down into these prime factors with these powers, $p_1^{n_1} +1 \leq N \leq d_1$.

#### BB84 Protocol

A quantum key distribution QKD protocol.

<s-side>


【1】A generates 2 random uniform strings uniformly of length n:
$$
\begin{matrix}
	X = x_1 x_2 .. x_n & Y = y_1 y_2 .. y_n
\end{matrix}
$$
Then prepares n qbit states
$$ \e{\psi_{x_1y_1}} .. \e{\psi_{x_ny_n}} $$ 

And sends these to B in order. *(Conjugate coding)*

</s-side>
<p></p>
<s-side>

【2】When B receives n qbits, they may not be in the states $\e{\psi_{x_iy_i}}$, perhaps due to channel noise, or due to eavesdropping and tampering. 

*Firstly.* Assume transmission is perfect, B receives everything as-is. 

B generates a random uniform string $ Y' = y_1' y_2' .. y_n'$ and measures each qbit $i$ in basis $B_{y'_i}$ to get $X' = x_1'..x_n'$ 

> $Y'$ is B's guess at A's encoding basis Y. 

*Note:* If B is correct $y_i' = y_i \implies x_i' = x_i$. If B is incorrect $y_i' \neq y_i$ then $x_i'$ has **no correlation** to $x_i$.

$y_i' = y_i$ happens with probability 0.5.

</s-side>
<p></p>
<s-side>

【3】A and B *publicly reveal* and compare their basis strings Y and Y' (but keep secret Xs).

They both discard all bits $x_i, x_i'$ where the basis bits do not match, leaving shorter strings of *expected* length $\frac n2 : \tilde X , \tilde X'$

Under the assumption of perfect transfer, then these bits provide the desired secret key. 

**However** there is always noise and there may be eavesdropping, and so there are 2 more steps to correct for this.

</s-side>
<p></p>
<s-side>

【4】(**Information reconciliation**) A and B want to estimate the bit error rate BER = $\rm{count}(\tilde X' \neq \tilde X)$.

They publicly compare a **subset** of Xs, at pre-agreed random positions. This can be as much as half. Then, all revealed bits are **discarded**.

They assume the remaining bits have the same *proportional error* <span class="grey">but at unknown positions</span>. 

They want to correct these errors without sacrificing too many key bits, and can be done if BER not too large.

</s-side>
<p></p>

<s-side>

【5】(**Privacy amplification**) are classical methods (not explained) for improving the quality of the key. A and B can do this, also using an estimation of the amount of information E has, via the BER.

</s-side>

There are many possible eavesdropping strategies for E. Such as 

- **Intercept and resend attack** Intercept each qbit separately, measures it in a pre-determined basis, and sends the post measurement state, or try to reconstruct the qbit from her measurement.
- **General Coherent Attack** With a "large quantum probe" unitarily interact (and entangle with) each passing bit, so E has a set of entangled bits (the "probe") which she could measure to obtain possibly joint info -- can even do this after sending and agreement.

-----

***Intercept and Resend.*** Assume quantum channel has no noise, but E intercepts each qbit and measures it in the **breidbart basis** ($\frac\pi8$ basis):

\begin{align}
	\e{\alpha_0} &= \cos \frac\pi8 \0 + \sin \frac\pi 8 \1\\\\
	\e{\alpha_1} &= \cos \frac\pi 8 \0 - \sin \frac\pi 8 \1
\end{align}

This is a basis angled just between computational and conjugate, at 22.5 degrees offset, which is the best for getting information.

We can work out that in every single case, E's probability of measuring A's bit correctly is 
$$ \cos^2 \frac\pi 8 = \frac{1 + \frac 1 {\sqrt 2}}{2} \approx 0.85 $$ 

Now the bit error rate, we have to analyse the probability of getting a *wrong* outcome case by case. This is usually done in a probability tree but I don't want to draw it so more $\TeX$:

$$
\0 \overset{|\ip{\alpha_0}{0}|^2}{\underset{\cos^2}\lra} \e{\alpha_0} \overset{|\ip{\alpha_0}{1}|^2}{\underset{\sin^2}\lra} \1 
$$
$$
\0 \overset{|\ip{\alpha_1}{0}|^2}{\underset{\cos^2}\lra} \e{\alpha_1} \overset{|\ip{\alpha_1}{1}|^2}{\underset{\sin^2}\lra} \1 
$$

Where the left is what A sends, the middle is what E resends, and the right is what B measures (wrong result only). Calculating this we have 
$$P(\rm{wrong}) = \cos^2\sin^2 + \sin^2\cos^2 = 2\sin^2\cos^2 = \frac12 (4\cos^2\sin^2) = \frac12 (2\sin\cos)^2$$
$$= \frac12 \sin^2(\frac\pi4) = \frac14$$
For the case of a missent $\0$. 

Repeating this for all the other three cases, we get $\frac14$ each time, leading to an average BER of $\frac14$.

-----

***Information Reconciliation.*** Suppose there is already some secret key established, but due to noise (or spying) there is some BER (which we have estimated).

So:
- Apply a "random public permutation" to both strings
	- to randomise positions of errors -- both sides must agree on this permutation 
- A and B breaks their strings into blocks of suitable lengths (based on BER) : unlikely each block has 2 errors 
- Compute *bit parity* for each block and announce 
	- Blocks with agreeing parity are tentatively accepted correct.
- Blocks with disagreeing parities must have odd number of errors (likely 1)
	- Break each block in half, and repeat above until offending block is 1 bit long 
	- B corrects that bit 
- Repeat the above as many times as needed to gradually reduce BER 

> Since parity is public, more info is leaked to E. However for blocks of length $k$, only $\log_2 k$ halvings, so exponentially less information is leaked.


------

***Privacy Amplification.***

Ex. A and B share 3 bit string $x_1 x_2 x_3$, and suppose E knows only 1 bit of this bitstring.

<s-side>

***Fact.*** If E knows bit $x$, not $y$, then $x \oplus y$ is uniformly random for E. 

More generally, if E knows some bit, but not all, then there is no knowledge of parity. 

</s-side>

Consider 2 bit strings $y_1 y_2:$ 

$$ \begin{matrix}
	y_1 = x_1 \oplus x_3  & y_2 = x_2 \oplus x_3
\end{matrix} $$ 

Then the outcomes can be:

x | 000 | 001 | 010 | 011 | 100 | 101 | 110 | 111 
-|-|-|-|-|-|-|-|-
y | 00 | 11 | 01 | 10 | 10 | 01 | 11 | 00

For any fixed value of any $x_1$, the corresponding $y$ outcomes are always uniform.

**These can't be arbitrarily picked, as they must be uniform depending on E's knowledge.** 

We can represent the above operation in a matrix: 

\begin{align}
	\begin{bmatrix}
		y_1 \\\\ y_2
	\end{bmatrix} &= \begin{bmatrix}
		1 & 0 & 1 \\\\ 0 & 1 & 1
	\end{bmatrix} \begin{bmatrix}
		x_1 \\\\ x_2 \\\\ x_3 
	\end{bmatrix} \\\\ 
	y &= Gx
\end{align}

> Rows of $G$ denote subsets of bits for parity sums. Generally, 

<b-blue>

***Thm.*** If E knows only $k/n$ bits, then the $m \times n \pod{m \lt n}$ matrix G will produce secret $y$s **if and only if** the minimum "hamming weight" of the code generated by G is bigger than k.

There is always a G that can generate a secret.

</b-blue>

- *Code:* representation of linear subspace of $(\bb{Z}_2)^n$, i.e. the span of k basis codewords in (that) is given by rows of G 
- *Minimum weight of code:* The least hamming weight of any code word $c \in C$ 
- *Hamming distance:* of two codewords $c_1, c_2 \in C$, is essentially `np.sum(c_1 != c_2)`.

**Universal hashing:** given an $n$ bit string, choose an $m \lt n$ and random boolean matrix $G$, then with high probability, E will have no information about the string $y = Gx$.

</div>
</div>

<div class="colourband">
	<h2 id="qm">Quantum Money</h2>
</div>

<div class="cbox">
<div class="md-conv">

### Quantum Banknotes

A quantum banknote is a banknote with a printed serial number, which is an N bit string (publicly visible), as well as N qbits embedded within (which are stable). 

For each banknote, the bank will have an N bit secret "basis" string.

When the note is manufactured, the serial number is encoded into **BB84 bases** according to the basis string.

When the note is returned / checked later, the bank can test the authenticity of the note by looking up the secret, and measuring the serial number in the basis given. The note is accepted *only if* the serial number matches exactly. 

- A genuine banknote passes the test and **remains** genuine (since the qbit doesnt change if you measure it in the right basis.)

A counterfeiter C wants to make notes that pass the test.

Consider the $k$th bit. We want to ask: what is the maximum probability that the counterfeiter can determine the $k$th basis by measuring that bit?

C can see the $k$th serial number, and knows that it is in $\0, \e+p$ for a 0 bit, and $\1, \e-$ for a 1 bit. 

To determine the basis, C must determine between two **equally probable** states (their inner product is $\frac{1}{\sqrt 2}$).

With the **Helstrom Holevo bound** we know that the maximum probability of successs is UB by 
$$
\frac{1 + \sin \frac{\pi}{2}}{2} = \frac{1 + \frac{1}{\sqrt 2}}{2} \approx 0.8535
$$
So C gets a wrong result with $p \approx 0.1465$.

Now C use uses this result to set a basis string for a new fake banknote with the same serial number. If the note is subsequently inspected by the bank, the probability that bit $k$ 
- has the correct basis and passes is 0.8535 
- has the wrong basis and passes is 0.5 &times; 0.1465
- has the wrong basis and fails is 0.5 &times; 0.1465

And so one bit would pass with $p \approx 0.926$, and so we just need to increase the number of bits to make this probability arbitrarily small.
- For 100 bits, the probability of full success is $0.926^{100} \approx 4.6 \times 10^{-4}$

</div>
</div>

<div class="colourband">
	<h2 id="complexity">Computation and Complexity Theory</h2>
</div>

<div class="cbox">
<div class="md-conv">

### Computations 

Let bitstring set $B = B_1 = \\{0, 1\\}$ be single bit bitstrings.
- $B_n$ is then the set of all $n$-bit bitstrings, and $B^*$ is the set of all finite bitstrings.

***Computational Task.*** A computational task is:
- Given an **input** as a bit string $x = i_1 i_2 .. \in B_n$ 
- A language $L \subseteq B^*$

We want to solve 
- Given $x \in B^*$, is $x \in L$?

And output 
- 1 if true, 0 if not.

***Computational Model.*** 

There are many possible choices of model, e.g. circuit model, finite automata, etc. 

But all have an important feature, they are 
- A process with discrete steps 
- Each step requires a fixed constant effort/resource to complete

<s-side>

The **circuit model** or gate array model is as follows: 

For a given $x = i_1..i_n$, we extend by an arbitary extra number of zero bits, which is our *working space*
$$ \implies i_1 .. i_n 00 .. 0$$

The basis steps are a specified sequence of $\land, \lor, \lnot$ gates on specified bits.

</s-side>

Note that this set of classical gates is universal, i.e. any func $f: B_m \lra B_n$ can be constructed by a sequence of these gates. A **computation** is a prescribed sequence of steps for each input size $n$. The **output** is the value of some designated bits, after final step.

This is a **boolean circuit**.

<s-side>

A **randomised (probabilistic) classical computation**

Like a circuit gate model, but we initially extend input $x$ *in addition* by a sequence of random bits $r_1 .. r_k$ 
$$ \implies i_1 .. i_n 0 .. 0 r_1 .. r_k $$ 

So each time the circuit is run, the r bits are set uniformly at random, and the output is probabilistic. 

Usually require output to be correct with a suitably high probability (over 0.5)

</s-side>

### Complexity 

A consumption of resources as a function of n. We have $T(n)$ the number of computational steps (time), and $Sp(n)$ the amount of space taken (space). Usually we like to look at time.

The main question is does $T(n)$ grow polynomially or exponentially (super-poly) prop. to the size of the input. 

Poly time calculations are called **tractable** or **feasible**.

<s-side>
	
***Class P.*** the set of all problems with poly-time deterministic algorithms.

</s-side>
<p></p>
<s-side>

***Class BPP.*** (Bounded error probabilistic poly time): the set of all probabilistic poly-time algorithms s.t. for all inputs $x$, the **probability of correctness $\geq \frac32$**. 

Note that this class still holds for any probability $p \gt \frac12$ (bounded away from half)

</s-side>

These are all considered "efficient"

For BPP with any probability $\frac12 + \delta$ of success, we can repeat it $k$ times and take a majority vote. The **chernoff bound** says that in this case we would be correct with a $p \gt 1 - e^{-2\delta^2 k}$. 

We can always scale K up, and since K is a constant and BPP requires poly time algorithms, this is still poly time.

<s-side>

***Example.*** Prime testing. 

IN: Integer N in binary    
SIZE: $n = \left\lceil{\log_2 N	}\right\rceil $ 

Naive algorithm: test and divide by all numbers $2..\sqrt{N}$. This is not poly-time, as it takes at most $\sqrt{N} \approx 2^{\frac n 2}$ steps.

However, prime testing is proven to be BPP, and finally P in 2004.

</s-side>

### Quantum Computation 

We will focus on the circuit model. 

For input $x = i_1 .. i_n \in B_n$, we start with qbits $\e{i_1}..\e{i_n}\0..\0$ similar to classical.

Computational steps are 1 or 2 qbit gates designated on qbits. 
- Single qbit gates include: $H, X, Z, P(\phi), \dots$ (last one is rotation)
- Double qbit gates include: $CX, CZ, \dots$ 

Output is a quantum measurement in $\\{\0, \1\\}$ basis only on specified qbits.

***Universal Gates.*** A program can be thought of as some fat unitary U over all bits. This has continuous parameters. Therefore, there are **no finite set** of gates that can be exactly universal.

We can think about *approximate universality*, 

<b-blue>

***Def.*** $G$ is **approximately universal** if 
- $\forall \varepsilon \gt 0$, unitary $W$ on $n$ qbits:
- There exists a circuit $\tilde W$ if gates in $G$ such that 
$$
\lVert W - \tilde W \rVert \lt \epsilon
$$ 
Where $\lVert A \rVert$ is the max over all normalised $\e\psi$ of $\lVert A\e\psi \rVert$ (the spectral norm).

i.e. the maximum distance an approximate gate set program can take you from the actual result is an error $\varepsilon$.

</b-blue>

The size of $\tilde w$ is expressed generally in number of bits $n$. 

<b-blue>

***Thm.*** (Solway-Kitaer for dependence on accuracy).

For each fixed $n$, there is a polynomial $p$ s.t. $\forall W$ on $n$ qbits, 

the size of the circuit $\tilde W$ is bounded by $p(\log \frac{1}{\varepsilon})$. <span class="grey">Polynomial in number of digits of accuracy</span>

</b-blue>
<p></p>
<s-side>

***Fact.*** $G = \\{CX, \rm{all 1 bit gates}\\}$ is **exactly** universal, but there are infinite 1 bit gates.

$G' = \\{H, CX, P(\frac \pi 4)\\}$ is an approximately universal set.

</s-side>
<p></p>
<b-blue>

***Def. Class BQP* (Bounded error quantum poly-time)** All problems that can be solved with a poly-sized quantum circuit having probability of correctness $\gt \frac 2 3$ (or anything above 1/2).

</b-blue>

These problems are feasible quantumly.

Note that 
- BQP is independent of choice of approximately universal gate set 
- $BPP \subseteq BQP$ but we do not know if $BPP \neq BQP$.

***Reversible Boolean Functions.*** For any function $f : B_m \lra B_n$ which maps boolean values $x \mapsto y$. 

In general, boolean functions are not usually reversible. AND is an example of this. Quantum unitaries however are always reversible.

Consider then a $\tilde f : B_{m+n} \lra B_{m+n}$ which does 
$$\tilde f : (x, y) \mapsto (x, y \oplus f(x)) $$
Which can easily be constructed from $f$. $\oplus$ is still bitwise addition mod 2.

<s-side>

***Lemma.*** $\tilde f$ is always reversible.

***Proof.*** Note $x \oplus x = 0 \forall x$. Therefore 

$$ \tilde f(\tilde f(x, y)) = (x, y \oplus f(x) \oplus f(x)) = (x, y) $$

Hence $\tilde f$ is always reversible and is its own inverse.

</s-side>

Now if $g: B_k \lra B_k$ is any invertible boolaen function, let the linear map on $k$ qbits defined on the $k$-basis be 
$$
A_g : \e{x} \lra \e{g(x)} 
$$ 
For a unitary $A_g$.

For a function $f$ that can be made into a reversible function $\tilde f$, we write $A_{\tilde f} \equiv U_f$, so 
$$ U_f \e{x}\e{y} = \e{x} \e{y \oplus f(x)} $$ 

***Computation by quantum parallelism.*** Let
$$
\e{x} \e{0..0} \overset{U_f}{\lra} \e{x} \e{f(x)} 
$$
By linaerity of the operation, also get 
$$
\left(\frac{1}{\sqrt{2^m}}\sum\limits_{\forall x} \e{x}\right) \e{0..0} \overset{U_f}{\lra} \frac{1}{\sqrt{2^m}}\sum\limits_{\forall x} \e{x} \e{f(x)}
$$
Let this be written as $\e{f}$, and is basically $f$ calculated over a superposition of all possible input bit strings $x$. 

Therefore **one** run of $U_f$ gives a state of all exponentially many values of $f(x)$. 

Furthermore, although $\e\psi = \frac{1}{\sqrt{2^m}}\sum\limits_{forall x} \e{x}$ has exponentially many terms, it can be prepared easily by using only *linear* effort. 

- By using $m$ hadamard gates 
$$ \e{0..0} \overset{H \tens H \tens \cdots \tens H}{\lra} \frac{1}{\sqrt{2^m}}(\0 + \1) \cdots (\0 + \1) = \e\psi $$ 

### Promise Problems 

Instead of the input $x$ being a binary string (or quantum binary string), we have 
- $x$ is a given black box / **oracle** $O_f$, that computes some boolean function $f : B_m \lra B_n$.
- Each use of the oracle counts as 1 computational step 
- And we can be given an *a-priori* **promise** about a property of $f$. 

The problem is:
- Given $x$, we want to determine some property of $f$ (given our promise)
- We can only access $f$ via the oracle $O_f$ 
- Computation starts on a string of zeros (or quantum $\0 .. \0$)

**Query Complexity.** Number of times $O_f$ needs to be queried to solve the problem.

**Total time complexity.** Total size of circuit (oracle = 1 gate)

<s-side>

***Example.*** Balanced versus Constant.

INPUT: A oracle for $f: B_n \lra B_1 \pod{\equiv B}$    
PROMISE: $f$ is either (a) **constant**, or (b) **balanced** 
- Balanced: half the inputs result in 1, the other half 0 

PROBLEM: Determine if $f$ is constant or balanced with *perfect certainty*.

</s-side>

<s-side>

***Classically.*** $\frac{2^n}{2} + 1$ queries are necessary and sufficient to solve with certainty. 

*Sufficiency.* we need to measure over half of inputs to determine for certain if it is balanced or not.

*Necessity.* Suppose we have a deterministic classical algorithm. Assume for contradiction that it claims to solve the problem for any $f$ using $K \leq \frac{2^n}{2}$ queries. 

An adversary can engineer a function that: when run with this algorithm, always returns 0. However, the function itself is not fully defined.  

- Since *less than half* of inputs are run, if the algorithm says balanced we can then define all the unmeasured inputs to be 0, and if constant, we can define half of all inputs (we have more than half "undiscovered") as 1.

</s-side>

<s-side>

***Quantumly.*** We claim that **one** query is sufficient.

- Start with $U_f \e{x}\e{y} = \e{x} \e{y \oplus f(x)} $ 
- We use a method of "phase kickback" to encode values of $f$ in the phase/amplitudes. 

**Important:** Our working space $\e{y} := \e-$ needs first to be set to the minus state. 

Then, note that 
\begin{align}
	\e{x} \e- &= \e{x} \frac{1}{\sqrt 2} (\0 - \1) \\\\
	&\overset{U_f}{\lra} \e{x} \frac{1}{\sqrt 2} (\e{f(x)} - \e{1 \oplus f(x)}) \\\\
	&= \begin{cases} 
		e{x}\left(\frac{\0 - \1}{\sqrt{2}}\right) & \rm{if } f(x) = 0  \\\\
    	\e{x}\left(\frac{\1 - \0}{\sqrt{2}}\right) & f(x) = 1
	\end{cases} \\\\ 
	&= (-1)^{f(x)} \e{x} \e- 
\end{align}

And so now we have the result of $f$ as either a + or - amplitude -- this is phase kickback and is a very important trick.

Now, as a superposition of all $x$s, this becomes 
$$
\frac{1}{\sqrt{2}^n} \sum\limits_{\forall x} \e{x} \m \overset{U_f}{\lra} \left(\frac{1}{\sqrt{2^n}}\sum\limits_{\forall x} (-1)^{f(x)} \e{x}\right)\m
$$

We can now discard the second state, and now have our phase-encoded query:
$$
\frac{1}{\sqrt{2^n}}\sum\limits_{\forall x} (-1)^{f(x)} \e{x}
$$

- If $f$ is constant, then all the signs are the **same**.
- If $f$ is balanced, **exactly half** the signs will be different.

i.e. $\e{\xi_{f_{const}}} \perp \e{\xi_{f_{balanced}}}$, therefore they are perfectly distinguishable. However, they are not in the basis $\0, \1$, and we only allow measurement in that basis, and so we must convert it back. 

Since we applied H gates to get to this rotated state, we can apply all H gates again to rotate back (H is self inverse):
$$
\e{\eta_f} = H \tens \cdots \tens H\e{\xi_f}
$$
Unitaries preserve dot product $\implies \e{\eta_{f_{const}}} \perp \e{\eta_{f_{balanced}}}$ still holds. 

- When $f$ is constant, $\e{\eta_f} = \pm \e{0 \cdots 0}$. When measured, this gives 0...0 with **certainty**.
- When $f$ is balanced $\e{\eta_f} = \sum\limits_{\forall x \in B_n}^{x \neq 0} a_x \e{x}$ for some coefficients $a_x$. When measured, this gives **some** bitstring $B_n$, which will never be 0.

</s-side>

A circuit is shown.

![Circuit diagram](./balanced-constant-circuit.png)

It takes 1 query and $O(n)$ processing.

Some observations:
- We cannot prove that there is a quantum algorithm that can answer a decision problem for any $f:B_n \lra B_1$ problem using polynomial oracle queries. 
	- SAT is a problem that cannot be solved. It can be worded as: given a $f: B_n \lra B_1$ with *no* promise, is there an $x : f(x) = 1$?
	- Rather it is proved that *any* algorithm solving SAT with $p = 1-\varepsilon \pod{\varepsilon > 0}$ probability needs at least $O(\sqrt{2^n})$ queries.
	- I.e. no promise = bad.
- If we can tolerate error in the above problem (success rate $p = 1-\varepsilon \pod{\varepsilon \geq 0}$) then we can design a randomised algorithm with a constant $O(\log \frac{1}{\varepsilon})$ queries, which removes the advantage of quantum.
	- The classical alg is just: (a) choose $k$ values of $x = x_1 .. x_n$ uniformly at random, and execute $f$ on each $x$ ($k$ queries). (b) if any queries are different then balanced, else constant.
	- If $f$ is constant, the answer is correct with $p=1$, but if balanced, the probability of all zeros or ones is $\frac{2}{2^k}$ and just increase $k$ until this is suitably small.

So this may lead one to claim that quantum algorithms are no more powerful than classical randomised ones (like NFAs being no more powerful than DFAs), but the below shows differently:

<s-side>

***Simon's Problem.***

Given an oracle $f : B_n \lra B_n$    
And a promise that $f$ is either 
- one-to-one
- two-to-one or **periodic**: there is some bitstring $\xi \in B_n : f(x \oplus \xi) = f(x) \pod{\forall x}$.

Determine which one it is.

</s-side>

> This is a follow-on from DJ algorithm, and this builds into prime factoring algorithms.

So far we only look at oracle problems - often though we would like to do standard, more general comptational tasks, that are not in oracle form. However of this type none so far have been found to be better quantumly.

</div>
</div>

<div class="colourband">
	<h2 id="qft">Quantum Fourier Transforms</h2>
</div>

<div class="cbox">
<div class="md-conv">

### Periodicity

<b-blue>

***Def.*** A **Quantum Fourier Transform mod N** $QFT_{N}$

Takes an N-dimensional state space basis $\0, \1, \cdots, \e{N} :\in \bb{Z}\_N$, and transforms it by 

$$
QFT : \e{a} \mapsto \frac{ 1 }{ \sqrt{N}  } \sum\_{b=0}^{N-1} e^{\frac{ 2 \pi i a b  }{ N  }} \e{b}
$$

Can be written in the matrix form where each index element $[\cdot]\_{ab}$ is 
$$
[QFT]\_{ab} = \frac{ 1 }{ \sqrt{N}  } \omega ^{ab} \pod{\omega = e^{\frac{ 2\pi i  }{ N  }}}
$$

Then the matrix $\sqrt{N} QFT$ is 

- Symmetrical
- Has 1s in its first row and column 
- Each row and column is a **geometric sequence** $1, r, r^2, \dots$ where $r = \omega^k$ for the $k$th row/column.
- Is **unitary** <span class="grey">Proof is left as an exercise to the reader</span>

</b-blue>

Note that $QFT_2$ happens to literally just be the hadamar gate. 

*However* over higher dimensions $QFT_N$ is not just composed hadamars, the latter is often called a *boolean transformation*. 

***Periodicity Problem.***

Carrying on from Simon's problem, 

<s-side>


INPUT: $f : \bb{Z}_N \lra \bb{Z}_M$ as an oracle    
PROMISE: $f$ is periodic
- $f(x + r \mod N) = f(x)$ for the smallest some $r$, the **period** in $f$. 
- Note that $r$ divides N $\therefore N = Ar$ for some integer A the number of periods.   
PROMISE 2: $f$ is one-to-one within each period

PROBLEM: Find $r$ with any constant probability $1 - \varepsilon$. 

</s-side>

***Fact.*** Classically, $O(\sqrt N)$ queries are necessary and sufficient. 

However quantumly, only $O(\log \log N)$ queries and $O(\poly(\log N))$ total processing time is required.

We can also reduce the problem of finding a factor of an integer to this periodicity problem. 

<s-side>

***Quantum Algorithm for Periodicity Determination.***

We have a quantum oracle for $f: \bb Z_N \lra \bb Z_M$. Therefore 
$$
U_f \e{x} \e{y} = \e x \e{y + f(x) \mod M}
$$

【1】Generate superpositions by some method, e.g. $QFT_N \e{\mathbf{0}}$
$$
\frac{1}{\sqrt{N}} \sum\limits_{x=0}^{N-1} \e{x}
$$

【2】We use one query to get 
$$
\e{f} := \frac{1}{\sqrt{N}}\sum\limits_{\forall x} \e{x}\e{f(x)}
$$
Since $N = Ar$, 

【3】Measure the second register in the $\0, \1, \cdots, \e{N-1}$ basis. We see some value $y = f(x_0)$ with $x_0$ being the smallest value such that $f(x_0) = y$.

So there are one such $x_0$ in each period, and in total 
$$
x_0, x_0 + r, x_0 + 2r, \cdots, x_0 + (A-1)r
$$
After measurement, first register collapses to
$$
\e\per := \frac{1}{\sqrt{A}}\sum\limits_{j=0}^{A-1} \e{x_0 + jr}
$$

</s-side>

> *Note.* that $x_0$ is uniformly random from $0..r-1$. All function values occur equally often.
> 
> If we measure $\e\per$, we will get a random $j : x_0 + jr$.
> - Therefore we get a random $x_0$ from a random period $j$.
> - And a uniformly random $x$, which is not helpful.
> 
> **But** if we apply QFT first:

<s-side>


【4】We get 
$$
\begin{align*}
QFT \e{\per} &= \frac{1}{\sqrt{N}} \frac{1}{\sqrt{A}} \sum\limits_{j=0}^{A-1} \sum\limits_{y=0}^{N-1} \omega^{(x_0 + jr )y} \e{y}\\\\
&= \frac{1}{\sqrt{NA}} \sum\limits_{y=1}^{N-1} \omega^{x_0 y} \left(\sum\limits_{j=0}^{A-1} \omega^{jyr}\right)\e{y}
\end{align*}
$$
Where the big bracket with the sum inside is a geometric series $1 + \alpha + \cdots + \alpha^{A-1}$ such that 
$$
\alpha = \omega^{yr} = e^{\frac{2\pi i r y}{N}} = e^{(\frac{2 \pi i}{A})y} = 1 \\; \forall y
$$
if $y$ is a multiple of A, otherwise it will be the sum 
$$
\frac{1 - \alpha^A}{1-\alpha} = 0
$$
Therefore $\alpha = 1 \iff y$ is a multiple of $A = \frac{N}{r}$.

Therefore
$$
QFT \e\per  = \sqrt{\frac{A}{N}} \sum\limits_{k=0}^{r-1} \omega^{x_0 k(\frac{N}{r})} \e{k \frac{N}{r}}
$$
Where $\sqrt{A/N} = 1/\sqrt{r}$.

By magic we have encoded the random shift in the phase of the state, and so its amplitude is **independent** of $x_0$.


【5】We measure the label now, and obtain the result C, which is a multiple of $k_0 \frac{N}{r} \pod{0 \leq k_0 \leq r-1}$ uniformly at random. Therefore 
$$
C = k_0 \frac{N}{r} \implies \frac{k_0}{r} =\frac{C}{N}
$$
Where $k_0$ is random, $r$ is unknown, C and N are known. 


【6】(The number theory cop out part)

</s-side>

**If** $k_0$ is coprime to $r$, then trivially the way we get $r$ is simplify down $\frac{C}{N}$ and read off the denominator. If $k_0$ is not coprime to $r$, then we have no way of getting it. But, there is a non-negligible probability that $k_0$ is coprime, as:

<b-blue>

	
***Theorem.*** The number of integers less than a $r$ that is coprime to it is at least $\Omega (\frac{1}{\log \log r})$. 

</b-blue>

Thus $P(k_0 \rm{ coprime to } r) \geq \Omega\left(\frac{1}{\log \log r}\right)\geq \Omega\left(\frac{1}{\log \log N}\right)$.

<s-side>


Therefore:
- When we simplify $\frac{C}{N}$ down, we get a $\tilde r$, our tentative $r$. We can check if this is indeed the period by checking if $f(0) = f(\tilde r)$.
- If so, we are done with 2 queries. Otherwise, **repeat the algorithm until we get lucky and our $k_0$ is indeed coprime with $r$**.

</s-side>

<b-blue>
	
***Lemma.*** If an event has probability $p$ of succeeding, and the number of trials $M \geq \frac{\log 1/\varepsilon}{p}$, then the probability that at least one success happens in M trials is $1 - \varepsilon$.

</b-blue>

<s-side>

***Proof.*** The probability of all trials failing is $(1-p)^M$. Want to see $(1-p)^M \leq \varepsilon$, which happens if and only if 
$$
\begin{align*}
M \log (1-p) &\leq \log\varepsilon \\\\
M &\geq \frac{\log \frac{1}{\varepsilon}}{\log (\frac{1}{1-p})} \geq \frac{\log \frac{1}{\varepsilon}}{p} & \Box
\end{align*}
$$

</s-side>

***Note.*** To achieve 99% success, $O(p)$ repeats suffices. Thus repeating algorithm $O(\log \log N)$ times and checking $O(1)$ queries leads us to the $O(\log \log N)$ query complexity. 


### Efficient Implementations

<b-blue>

***Thm.*** QFT mod $2^n$ can be implemented by a small quantum circuit of size $O(n^2)$.

</b-blue>

Recall that $QFT_{2^n} \e{x} = \frac{1}{\sqrt{2^n}} \sum_{y=0}^{2^n-1} \exp\left(\frac{2\pi i y x}{2^n}\right) \e{y}$. (Note we are using exp rather than e-to-the-power due to formatting)

***Key Fact.*** $QFT \e{x}$ is always a product state.

We first write $y$ in binary, i.e. $y = y_{n-1}2^{n-1} + y_{n-2}2^{n-2} + \cdots + y_0$. Then:

$$
\begin{align*}
\frac{xy}{2^n} &= y{n-1} \frac{x}{2} + y_{n-2} \frac{x}{2^2} + \cdots + y_n \frac{x}{2^n}\\\\
\therefore QFT \e{x} &= \frac{1}{\sqrt{2^n} } \sum\limits_{y_0}^{y_{n-1}} \exp\left(\frac{2\pi i x y}{2^n}\right) \e{y_{n-1}y_{n-2} .. y_0}\\\\
&= \frac{1}{\sqrt{2^n} } \sum\limits_{y_0..y_{n-1} = 0}^{1} \prod_{j=1}^n \exp\left(\frac{2\pi i y_{n-j}x}{2^j}\right)\e{y_{n-1}} \e{y_{n-2}}..\e{y_0}\\\\
&= \sum\limits_{y_0=0}^1 \sum\limits_{y_1 = 0}^1 \cdots \sum\limits_{y_{n-1} =0}^1 (\cdots) &(1)\\\\
&= \frac{1}{\sqrt{2^n}} \left(\sum\limits_{y_{n-1}=0}^1 \exp\left(\frac{2\pi i y_{n-1} x}{2}\right)\right) .. \left(\sum\limits_{y_0 =0}^1 \exp\left(\frac{2\pi i y_0 x}{2^n}\right)\right)\\\\
&= \bigotimes_{j=1}^n \left(\frac{\0 + e^{\frac{2\pi i x}{2^j}}\1}{\sqrt{2}}\right) &(2)
\end{align*}
$$

1. Each product depends only on one of the binary digits of $y$, i.e. only one sum. So we can separate the sums.
2. So we can see this is a product of 1 qubit states, which makes it efficient to compute.

Note that if x is binary, then we can write 
$$
\exp\left(\frac{2\pi i x}{2^j}\right)= \exp(2\pi i [x_{n-1} x_{n-2} .. x_j \cdot x_{j-1} .. x_0]) = \exp(2 \pi i [0\cdot x_{j=1}..x_0])
$$
Where that centre dot · represents a *binary decimal point*, and we can discard any whole number above that fixed point since $e^{2\pi i}$ has a period of 1.

Thus $QFT \e{x_{n-1} x_{n-2} .. x_0}$
$$
= \frac{\0 + e^{2\pi i 0\cdot x_0}\1}{\sqrt{2}} \tens \frac{\0 + e^{2\pi i 0\cdot x_0 x_1}\1}{\sqrt{2}} \tens \cdots \tens \frac{\0 + e^{2\pi i 0\cdot x_{n-1}x_{n-2}..x_0}\1}{\sqrt{2}}
$$
This is the main key to a circuit for QFT.

For $n=1$, we note that $e^{2\pi i 0\cdot1} = e^{\pi i} = -1$, and so the QFT over 1 bit would end up being
$$
\frac{1}{\sqrt{2}} (\0 + e^{2\pi i 0\cdot1}\1) = \frac{1}{\sqrt{2}}(\0 - \1) = \frac{1}{\sqrt{2}}(\0 + (-1)^{x_0}\1)= H(x_0)
$$
Therefore a 1 qubit QFT is just a Hadamar gate.

For a higher number of $n$, we first introduce the one qubit **phase gates** $R_j$:
$$
R_j = \begin{bmatrix} 1 & 0 \\ 0 & e^{\frac{2\pi i}{2^j}} \end{bmatrix}
= \begin{bmatrix} 1 & 0 \\ 0 & e^{2\pi i 0\cdot0..01} \end{bmatrix}
$$
The controlled phase gate $CR_j$ over 2 qubits is defined as:
$$
\begin{matrix}
CR_j \0\e\psi = \0\e\psi  & CR_j\1\e\psi = \1 R_j \e\psi
\end{matrix}
$$
This is diagrammatically represented the same as a CX gate.

We can observe what happens for $n=2$:
$$
QFT\e{x_1 x_0} = \frac{\0 + e^{2\pi i 0\cdot x_0} \1}{\sqrt{2}} \frac{\0 + e^{2\pi i 0\cdot x_1x_0}\1}{\sqrt{2}}
$$
Note that the first fraction is just $H\e{x_0}$. As for the second fraction:
$$
e^{2\pi i 0\cdot x_1x_0} = e^{2\pi i 0\cdot x_1} e^{2\pi i 0\cdot0x_0}
$$
Which is a $H$ and a Phase gate at the same time. And so the diagram would look something like:

<figure>
	<img src="qft-2n.png " alt="QFT on 2 bits" style="max-width: 60%;">
	<figcaption>QFT on 2 bits -- C-swap entails just swapping bits</figcaption>
</figure>

And so going off this pattern, for $n=3 : QFT_8$:

<figure>
	<img src="qft-8.png" alt="QFT on 8 bits" style="max-width: 80%;">
	<figcaption>QFT on 3 bits</figcaption>
</figure>


Note that $QFT_{2^{k+1}}$ has $QFT_{2^k}$ as its subcircuit.

***Complexity.*** Each qubit uses at most $n$ gates, and one swap gate at the end. This gives us roughly $\frac12 n(n+1) = O(n^2)$ complexity.



</div>
</div>

<div class="colourband">
	<h2 id="search">Quantum Search</h2>
</div>

<div class="cbox"><div class="md-conv">


### Introduction

***Search.*** Search problems are about looking in a *state space* for a "good" item, or one of many "good" items, out of all possible items. We assume it is easy (efficient) to check *if* an item is good, but the state space may be large.

e.g. Boolean satisfiability / SAT is a classic search problem:
- **Given** a $\poly(n)$ size boolean formula $\phi : B_n \lra B_1$
- **Problem** Find or determine if there exists a satisfying assignment.

***NP.*** (Non deterministic polynomial time)    
NP problems are problems that can be solved with a hypothetical non-deterministic computer in polynomial time. 

Whenever this computer reaches a choice, it *simultaneously* branches into both possible paths and runs them in parallel, accepting any valid path. Thus after $k$ steps we can have $2^k$ paths in parallel.

Polynomial time here means that every path must accept or reject within polynomial number of steps.

We can give an NP algorithm for SAT for example, based on the simple principle:
- Given a boolean function $\phi(x_1..x_n)$
- This is satisfiable $\iff$ either $\phi(x_1..x_{n-1}, 0)$ is satisfiable or $\phi(x_1..x_{n-1}, 1)$ is satisfiable.
- Repeat recursively.

***Important:*** On NP vs quantum parallelism:
- In quantum, it is easy to access quantum "exponential branching", by using as input a superposition of all states (by repeated hadamards).
- We can use a single query $U_\phi$ to get a superposition of all outputs.
- **But** we cannot easily extract this information, and deduced whether or not $\phi$ is satisfiable.

### Unstructured Search

Structure in a search space makes searching easier. If we know a list is ordered, we can use binary search to get $n$ queries for $2^n$ items. 

**Unstructured search** specifically means when we query a search space / database, we get **no information** about any other items.

Let us start by assuming a *unique* good item.
- **Given** unstructured database with $N = 2^n$ items, with a unique target item.
- **Problem** Find the good item with a high probability $1-\varepsilon$.

***Classically.*** We have to use linear search, giving a time complexity of $O(N) = O(2^n)$ being necessary and sufficient. If the good item is randomly placed, then $k$ queries give a probability of $\frac{k}{N}$ of success.

***Quantumly.*** We say that $O(\sqrt{N})$ queries are sufficient, and $\Omega(\sqrt{N})$ queries are necessary, via **grover's algorithm**.

> Note that here we only have a quadratic, and not exponential advantage.

We label items by $n$ bit strings, and so can represent queries by an oracle $f: B_n \lra B_1 : f(x) = 1 \iff x$ is the target.

- **Promise:** there is a *unique* $x_0 \in B_n : f(x_0) = 1$.
- **Problem:** Find $x_0$.


### Grover's Algorithm

Consider the circuit shown:

<figure>
	<img src="grover.png" alt="Grover circuit">
	<figcaption>The Grover algorithm circuit. One Q is a "Grover query"</figcaption>
</figure>

Initially, all possible states are in a superposition with amplitude $\frac{1}{\sqrt{N}}$, so there is only a $\frac{1}{\sqrt{N}}$ amplitude on $\e{x_0}$.

Every grover iteration Q moves roughly $\frac{1}{\sqrt{N}}$ more amplitude on to $\e{x_0}$ and takes away from everyone else.

<b-blue>

***Def.*** (Reflections) Given any state $\e\alpha$, let 
$$
I_{\e\alpha} = I - 2\e{\alpha}\b{\alpha}
$$
be the reflection in a "mirror hyperplane" orthogonal to $\e\alpha$. That is 
- $I_{\e\alpha} \e\alpha = \e\alpha - Z\e\alpha \ip\alpha\alpha = -\alpha$
- $I_\e\alpha \e\beta$ where $\e\beta \perp \alpha = \beta - 2\alpha \ip\alpha\beta = \beta$

</b-blue>

We can implement the reflection $I_{\e{x_0}}$ giving that $f(x_0) = 1$ is unique, by using one quantum query to $f$. We do this via phase kickback:

Using $U_f \e{x} \m = U_f \e{x} \left(\frac{\0 - \1}{\sqrt{2}}\right)$ gives us 
$$
\begin{align*}
U_f \e x \m &=  \e x (-1)^{f(x)}\m\\\\
\therefore U_f\e x \m &= \begin{cases} -\e{x}\m & x=x_0\\\\
\e{x}\m & x \neq x_0 \end{cases}\\\\
\implies U_f \e{x}\m &= I_{\e{x_0}} \e{x} \m
\end{align*}
$$

> This bypasses having to know $I_{\e{x_0}}$ as we can use the oracle to have the same effect.

<b-blue>

***Def.*** (Grover iteration) $Q$.
$$
Q = -H_n I_\e{0^n} H_n I_\e{x_0}
$$
Where $H_n = \bigoplus_{i=1}^n H$ and $I_{\e{x_0}}$ is a query to the oracle.

</b-blue>

<s-side>

***Algorithm.***
- Start with a uniform superposition $\e{\phi_0} = \frac{1}{\sqrt{2^n}} \sum\limits_{x \in B_n} \e{x}$
- Apply $Q \; k$ times where $k = \left\lfloor \frac{\pi \sqrt{N}}{4} \right \rfloor$ and measure all qubits.

</s-side>

Let $\space(x_0)$ be the real subspace generated by $\e{\phi_0}, \e{x_0}$ (the latter is unknown but useful for analysis).

We will show **(a)** In $\space(x_0)$, Q is the rotation through angle $2 \alpha : \sin\alpha = \frac{1}{\sqrt{N}}$.

Then **(a)** can show why Grover works:
<img src="./grover-p.png" alt="Rotation diagram" style="float: left; max-width: 300px;">

$$\cos \beta = \ip{x_0}{\psi_0} = \frac{1}{\sqrt{N}}$$
The above is independent of $x_0$. We want to rotate $\e{\psi_0}$ until it sufficiently overlaps $\e{x_0}$.

How much do we rotate? Given **(a)** the rotation angle is $2 \sin^{-1} \frac{1}{\sqrt{N}}$, we want the number $k$ of $2\alpha$ rotations: $2\alpha k = \beta$.
$$
\begin{align*}
k\cdot 2\sin^{-1} \frac{1}{\sqrt{N}} &= \cos^{-1} \frac{1}{\sqrt{N}}\\\\
k &= \frac{\cos^{-1} \frac{1}{\sqrt{N}}}{2\sin^{-1} \frac{1}{\sqrt{N}}}
\end{align*}
$$

e.g. If $N=4$, then $k = \frac{\arccos \frac{1}{2}}{2\arcsin \frac{1}{2}} = \frac{2\pi}{3} / \frac{2\pi}{3} = 1$. I.e. one query is enough for $N=4$. 

e.g. if N is large, then $\sin^{-1} \frac{1}{\sqrt{N}} \approx \frac{1}{\sqrt{N}}$, and $\cos^{-1}\frac{1}{\sqrt{N}} \approx \frac{\pi}{2}$ as the values are very close to zero. Therefore we would need 
$$
k \approx \frac{\left(\frac{\pi}{2}\right)}{2\left(\frac{1}{\sqrt{N}}\right)} = \frac{\pi \sqrt{N}}{4}
$$

*Note* that the final state $\e{\psi_k} = Q^k \e{\psi_0}$, which forms an angle $O\left(\frac{1}{\sqrt{N}}\right)$ with $\e{x_0}$, and so the probability that we will measure $P(:\e{\psi_k} = x_0)$ is given by the born rule as 
$$
|\ip{\psi_k}{x_0}|^2 = 1-O\left(\frac{1}{N}\right)
$$
Which is very close to one.

Of course it remains to prove **(a)**, which we will do in a collapsed block :)

</div>
<button class="collapsible">Proof (a)...</button>
<div class="ccontent md-conv">

***Proof.*** Recall that $Q = -H_n I_\e{0^n} H_n I_\e{x_0}$

For a unitary $U$: 
$$
\begin{align*}
U I_{\e{\psi}} U^\dagger &= UIU^\dagger - 2U \e\psi \b\psi U^\dagger\\\\
&= I - 2(U\e\psi)(U\e\psi)^\dagger\\\\
&= I_{U\e\psi}
\end{align*}
$$
Since $H_n$ is a unitary, and $H_n^\dagger = H_n$, and $H_n \e{0^n} = \e{\psi_0}$, we get
$$
Q = -(H_n I_{\e{0^n}}H_n^\dagger) I_{\e{x_0}} = -I_{\e{\psi_0}} I_{\e{x_0}}
$$
If some $\e\xi \in \space(x_0)$, then
$$
I_{\e{x_0}} \e\xi = \e\xi - 2 \e{x_0}\ip{x_0}{\xi} 
$$
And similarly for $I_{\e{\psi_0}}$. Note that the inner product is just a real number, therefore this expression is in $\space(x_0)$, and thus 
$$
Q_\e\psi \in \space(x_0)
$$
> Q *preserves* $\space(x_0)$ -- any vector on the plane will remain on the plane after operation Q.

We look at the action of Q on $\space(x_0)$.
- $I_{\e{x_0}}$ is the reflection on the mirror hyperplane (in 2D it's just a **line**) orthogonal to $\e{\x_0}$.
- $-I_{\e{\psi_0}}$ is a reflection through the mirror **parallel** to $\e{\psi_0}$

***Mini Proof.*** Let any $\e\xi \in \space(x_0)$. This can be written as $\e\xi = a\e{\psi_0} + b\e{\psi_0^\perp}$ where $\e{\psi_0^\perp}$ will be any vector on the place that is perpendicular to $\e{\psi_0}$. 

Then $-I_{\e{\psi_0}} \e\xi = (-I + 2\e{\psi_0} \b{\psi_0}) (a\e{\psi_0} + b\e{\psi_0^\perp})$
$$
= -a \e{\psi_0} - b\e{\psi_0^\perp} + 2a \e{\psi_0} \ip{\psi_0}{\psi_0} + 2b \e{\psi_0} \ip{\psi_0}{\psi_0^\perp}
$$
$$
= a \e{\psi_0} - b \e{\psi_0^\perp}
$$
Which mirrors in line $\e{\psi_0} \; \Box$.


<img src="./grover-reflect.png" alt="Action of grover iteration as reflection on 2D" style="float:left; max-width: 300px;">


Pictorally, we can represent this as:
- Angle of $\e{x_0^\perp}$ to $\e{\psi_0}$ is $\alpha$. 
	- $\cos \alpha = \ip{\psi_0}{x_0^{\perp}}; \; \sin\alpha = \ip{\psi_0}{x_0} = \frac{1}{\sqrt{N}}$.
- We want to look at the action of Q on some vector $\e\xi$.
- The angle from $\e{x_0^\perp}$ to $\e\xi$ is $\beta$
- The angle from $\e{x_0^\perp}$ to $Q\e\xi$ is then $2\alpha + \beta$, as shown on the diagram.

Therefore, Q shifts the angle of some vector $\e\xi$ on the plane by $2\alpha$. $\Box$

</div>
<div class="md-conv">

***Remark.*** Grover's algorithm is **optimal**. Unconstrained search must require $O(\sqrt N)$ quantum queries.

</div>

</div>

	<footer>
		<div class="cbox">
			<div class="columncontainer ctwo" id="fc2">
			</div>
			<script type="text/javascript" src="../../js/footerGen.js"></script>
		</div>
	</footer>   

</div>

</body>
</html>