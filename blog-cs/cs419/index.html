<!DOCTYPE html>
<html>
<head>
	<title>CS419</title>
	<meta charset="utf-8">
	<link rel="stylesheet" type="text/css" href="../../style/style.css" media="all">  <!--TODO: CHANGE HREF-->
	<link rel="stylesheet" type="text/css" href="../../style/prism.css" media="all">
	<meta name="viewport" content="width=device-width" initial-scale=1.0>  <!--TODO: CHANGE LINKS ON BOTTOM OF SHEET FOR COLLAPSIBLE-->
	<link rel="icon" type="image/png" href="../../style/images/DragonIcon.png">
	
	
	<script async id="MathJax-script" type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
	<script defer type="text/javascript" src="../../js/toggle-darklight.js"></script>
	<script defer type="text/javascript" src="../../js/collapsible.js"></script>  <!--This stays at the end-->
	<script defer type="text/javascript" src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
	<script defer type="text/javascript" src="../../js/arrange.js"></script>
	<script defer type="text/javascript" src="../../js/prism.js"></script>
</head>
<body>

<div class="hidden">
	<header>
		<div class="parallax parsmaller">
			<div  style="display: grid; grid-template-columns: 1fr 1fr 1fr 7fr 1fr 1fr; grid-column-gap: 10px; padding: 5px; ">
				<div class="column tinycolumn">
					<a href="../../" class="nav">Home</a>
				</div>
				<div class="column tinycolumn">
					<a href="../../blog.html" class="nav">Blog</a>
				</div>
				<div class="column tinycolumn">
					
					<a href="../../about.html" class="nav">About</a>
				</div>
				<div></div>
				<div class="column tinycolumn">
					<a href="https://ko-fi.com/yijunhu" class="nav">Tip me</a>
				</div>
				<div class="column">
					<button class="nav dark-light">Dark Mode</button>
				</div>
			</div>
			<div class="cbox"> 		
				<h1>CS419</h1>
				<p class="subheading">Quantum Computing</p>
			</div>
		</div>
	</header>

<header>
	<div class="cbox">
		<h1>Introduction</h1>
	</div>
</header>


<div class="cbox">

<div class="md-conv">

For this module, I am trying to write notes along with the lectures. Thus content headings may be a little late coming.

Lots of this is just linear algebra with funny notation.

> Commentary is shown in block quotes.

Enjoy the MathJax loading. (I did try out katex but it just isn't wanting to work)

## Contents 

1. [Quantum Computing Fundamentals](#qc-fundy)
2. [Quantum Mechanical Principles](#qmps)
3. [Quantum Information](#qinfo)
4. [Quantum Information Transfer](#qit)
4. [Quantum Cryptography](#qcyp)
4. [Quantum Money](#qm)
4. [Computation and Complexity Theory](#complexity)
</div>

<div>
\(
	\newcommand{\k}[1]{\left\lvert #1 \right\rangle}
	\newcommand{\e}[1]{\left\lvert #1 \right\rangle}
	\newcommand{\b}[1]{\left\langle #1 \right\rvert}
	\newcommand{\ip}[2]{\left\langle #1 \vert #2 \right\rangle}
	\newcommand{\bb}{\mathbb}
	\newcommand{\rm}{\textrm}
	\newcommand{\0}{\e{0}}
	\newcommand{\1}{\e{1}}
	\newcommand{\t}{^\top}
	\newcommand{\abs}[1]{\left\lvert #1 \right \rvert}
	\DeclareMathOperator{\tens}{\otimes}
	\DeclareMathOperator{\lra}{\longrightarrow}
	\DeclareMathOperator{\lla}{\longleftarrow}
	\DeclareMathOperator{\span}{span}
	\DeclareMathOperator{\dim}{dim}
	\DeclareMathOperator{\Tr}{Tr}
\)
</div>

</div>


<div class="colourband">
	<h2 id="qc-fundy">Quantum Computing Fundamentals</h2>
</div>

<div class="cbox">
<div class="md-conv" id="fund-dirac">
### Fundamentals and Dirac Notation 

Let $V$ be a finite dimensional vector space, where the vector coefficients are **complex**.


<b-blue>

***Def.*** We write a vector in $V$ as $\k{v} \in V$. This is called a **ket** vector and is a *column* vector.

</b-blue>


Generally we work in 2D vector spaces: $V_2$, with some chosen ortho-normal basis $\\{\k{0}, \k{1}\\}$

***Example.*** Some vector $\k{v}$ can be written as a decomposition of bases:
$$ \k{v} = a \k{0} + b \k{1} = \begin{bmatrix}
	a \\\\ b
\end{bmatrix} \pod{a, b \in \bb{C}} $$ 

<b-blue>

***Def.*** The **conjugate transpose** of vector $\k{v}$ is $\k{v}^\dagger$, and is made by transposing the vector and replacing its coefficients with their complex conjugates. This is a **bra** vector and is a row vector, and we reverse the direction of the brackets.

\begin{align}
	\b{v} = \k{v}^\dagger &= a^* \b{0} + b^* \b{1} \\\\
	&= \begin{bmatrix}
		a^*  & b^*
	\end{bmatrix}
\end{align}

</b-blue>

Let vector $\k{w} = c\k{0} + d \k{1}$.

<b-blue>


The **inner product** of $\k{v}$ and $\k{w}$ is written 
$$ \ip{v}{w} = \k{v}^\dagger \k{w} = \begin{bmatrix}
	a^* & b^*
\end{bmatrix} \begin{bmatrix}
	c \\\\ d
\end{bmatrix}
$$

</b-blue>

We can say that 
- $\ip{0}{1} = 0$ since the bases are ortho-normal,
- $\ip{i}{j} = \delta_{ij}$ for some $\k{i}, \k{j}$


> This is Dirac's "bra-ket" notation, which is just "bracket" without the c.

<b-blue>

***Def.*** The **Tensor product** of vectors (in a fixed basis) is defined as follows:

- Let vector spaces $V$ of dimension $m$, with basis $\k{e_1} \dots \k{e_m}$
- $W$ of dimension $n$ with basis $\k{f_1} \dots \k{f_n}$ 

The **tensor product space** $V \tens W$ has basis
$$ \\{ \k{e_i} \tens \k{e_j} : i = 1\cdots m , j = 1 \cdots n \\}  $$ 

i.e. there are $m \times n$ bases.


A general vector $\k{\xi} \in V \tens W$ is defined 
$$ \k{\xi} = \sum_{i, j} c_{ij} \k{e_i} \tens \k{e_j} $$ 

For coefficients $c_{ij}$ 


Let $\k{\alpha} \in V = \sum_{i=1}^m a_i \k{e_i}$, and $\k{\beta} \in W = \sum_{j=1}^n b_j \k{f_j} $.  Then the **tensor product** of two vectors is defined as:

\begin{align}
	 \k{\alpha} \tens \k{\beta} &= \sum_{i=1}^m a_i \k{e_i} \tens \sum_{j=1}^n b_j \k{f_j} \\\\
	 &= \sum_{\forall i, j} a_i b_j \k{e_i} \tens \k{e_j}
\end{align}

</b-blue>

> Whilst this is a rather... recursive definition, when we reach the fundamental bases (i.e. just have numbers) we can just perform the below operation.

***Example.*** Let:

$$\begin{matrix}
	\k{a} = \begin{bmatrix}
		0.1 \\\\ -0.7
	\end{bmatrix} & \k{b} = \begin{bmatrix}
		0.3 \\\\ 0.5
	\end{bmatrix}
\end{matrix}$$

Then 

$$ 
\k{a} \tens \k{b} = \begin{bmatrix}
	0.1 \\\\ -0.7 
\end{bmatrix} \tens \begin{bmatrix}
	0.3 \\\\ 0.5
\end{bmatrix} = \begin{bmatrix}
	0.1 \times 0.3 \\\\
	0.1 \times 0.5 \\\\
	-0.7 \times 0.3 \\\\
	-0.7 \times 0.5
\end{bmatrix}
$$

I.e. everything times everything.

Thus for fundamental bases $V_2 \sim \left\\{ \k{0} = \begin{bmatrix}
	1\\\\0
\end{bmatrix}, \k{1} = \begin{bmatrix}
	0\\\\1
\end{bmatrix} \right\\}$, we can get 

$$ 
\k{0} \tens \k{0} = \begin{bmatrix}
	1\\\\0
\end{bmatrix} \tens \begin{bmatrix}
	1\\\\0
\end{bmatrix} = \begin{bmatrix}
	1\\\\0\\\\0\\\\0
\end{bmatrix}
$$ 

And we can get all our other new bases the same way.

### Product and Entangled States

<b-blue>

***Def.*** Any vector $\k{\xi} \in V \tens W$ of the form $\k{\xi} = \k{a}\_{\in V} \tens \k{b}\_{\in W}$ is called a **product vector**.

</b-blue>
<p></p>
<b-blue>

Any vector which is *not* a product vector is an **entangled vector**.

</b-blue>
<p></p>
<b-blue>

***Def.*** The **k-fold tensor product***, denoted $\tens^k V\_2$ or $V^{\tens k}$ is the vector space 

$$ V_2 \tens V_2 \tens \cdots \tens V_2 \pod{k \textrm{ times}}$$

With $2^k$ bases, with each basis being denoted as a k-length bit string. 

Each basis is $\k{i_1} \tens \cdots \tens \k{i_k}$, but because $\tens$ is a bit of a pain it is often written as $\k{i_1}\k{i_2} \cdots \k{i_k}$ or just $\k{i_1i_2 \dots i_k}$.

</b-blue>

***Example.*** Let $\k{v} = 1\k{00} + 1\k{11}$. We claim that this is entangled.

To verify if it is entangled or not, we must demonstrate that it is or is not a product state. I.e. suppose 
$$ \k{v} = (a\k{0} + b\k{1}) \tens (c\k{0} + d\k{1}) $$ 
This resolves to 
$$ ac\k{00} + ad \k{01} + bc \k{10} + bd \k{11} $$ 
We get that $ac = bd = 0$ and $ad = bc = 1$, which is not possible to solve. Thus $\k{v}$ is entangled.


Generally for an arbitrary $\e{v} \in V_2 \tens V_2 = a_{00} \e{00} + a_{01} \e{01} + a_{10} \e{10} + a_{11} \e{11}$, 

$$ \e{v} \rm{ entangled } \iff \det(A) \neq 0 $$ 

Where 

$$ A = \begin{bmatrix}
	a_{00} & a_{01} \\\\ a_{10} & a_{11}
\end{bmatrix} $$

But this is *not true* in higher dimensions.

For general dimensions 

$$ \sum_{i=1}^m \sum_{i=1}^n A_{ij} \e{i} \e{j} \rm{ product vector } \iff \rm{ mat } A \rm{ is rank 1} $$

> Rank is a linear algebra term -- it is the number of columns (or rows, whichever is **smaller** that are linearly independent)

----- 

The inner product on general spaces $V \tens W$ is "induced by inner products on V and W applied slotwise". 

This is to say for product states $\e{a_1}\e{b_1}$ and $\e{a_2}\e{b_2}$, the inner product is 
$$ (\b{b_1}\b{a_1})(\k{a_2}\k{b_2}) \equiv \ip{a_1}{a_2} \ip{b_1}{b_2}.$$

----- 

When vectors come from the same subspaces tensored together, it is important to label which vector belongs to which space.

Tensor product is a commutative operation, so for subspaces $A, B$, we could have $\e{\alpha}_A \e{\beta}_B$ having the bra form $\b{\alpha}_A \b{\beta}_B = \b{\beta}_B \b{\alpha}_A$

</div>
</div>

<div class="colourband">
	<h2 id="qmps">Quantum Mechanical Principles</h2>
</div>

<div class="cbox">
<div class="md-conv">

### Principle 1 - On Physical States 

<b-blue>

The states of any isolated physical system $S$ are represented by unit vectors in complete vector space $V$, with an inner product $\ip{v}{v} = 1$

$\lra$ Any state is describable by unit vectors.

</b-blue>

***Ex.*** Take the simplest non trivial case of 1 qbit in 2-dimensional $V$.

Take bases $\e{0}, \e{1}$. The general state $\e{\psi} = a\e{0} + b\e{1}$.

$\lra \e\psi$ is a superposition of states $\e{0}, \e{1}$ with **amplitudes** $a, b \in \bb{C}$.
<!-- 我操竟能这样子 -->
<b-blue>

***Def.*** A **Qubit** is a quantum system with a 2D state space *and* a chosen ortho-normal basis labelled $\0, \1$. 

These are also called the $z-$, computational, or standard basis.

</b-blue>
<p></p>
<b-blue>

***Def.*** The **conjugate basis** for a qbit in the orth-norm basis $\0, \1$ is defined as 

\begin{align}
	\e+ &= \frac{1}{\sqrt{2}} (\0 + \1) \\\\
	\e- &= \frac{1}{\sqrt{2}} (\0 - \1)
\end{align}

This is rotated 45&deg; from the standard basis.

</b-blue>

</div>

<div class="md-conv">

### Princple 2 - Composite Systems

<b-blue>

Let system $S_1$ have state space $V_A$, $S_2$ have state space $V_B$;

Then the **joint system** $S_1 S_2$ has state space $V_A \tens V_B$.

</b-blue>

***Ex.*** Take $n$ qbits. Their state space is $\tens^n V_2$, with dimension $2^n$.

The standard basis is $2^n$ vectors of $n$ length bit strings $\e{i_1 \cdots i_n}$.

The $n$-bit state is a product state *if* 
- it is a tensor product of $n$ 1-qbit states $$ \e\psi = \e v_1 \e v_2 \cdots \e v_n $$ 
- Otherwise, $\e\psi$ is entangled.


In quantum computing as the number of qbits grow, the state description grows **exponentially**. 

However, for *product* states, the description only grows **linearly**. This describes a classical computing system.

#### Dirac and Linear Maps

Consider linear maps on $V_2$ 

> A linear map, or linear mapping on a 2D space is just a 2D transformation matrix.

Let $\e v = a\0 + b\1$ and $\e w = c\0 + d\1$, the *ket-bra product* gives 
$$ M = \e v \b w = \begin{bmatrix}
	a \\\\ b 
\end{bmatrix} \begin{bmatrix}
	c* & d* 
\end{bmatrix}$$ 
$$ = \begin{bmatrix}
	ac* & ad* \\\\ bc* & bd* 
\end{bmatrix} $$ 

This is a **linear map** on $V_2$ that projects a state down. That is to say,

For any vector $\e x = \begin{bmatrix}
	x_0 \\\\ x_1
\end{bmatrix} $,
$$ M \e x = (\e v \b w) \e x = \e v \ip w x $$

It turns into a scaled $\e v$. These are called **rank 1 mappings**.

Given 
\begin{matrix}
	\e 0 \b 0 = \begin{bmatrix}
		1&0 \\\\ 0&0
	\end{bmatrix} &
	\e 0 \b 1 = \begin{bmatrix}
		0&1 \\\\ 0&0
	\end{bmatrix} \\\\ 
	\e 1 \b 0 =\begin{bmatrix}
		0&0 \\\\ 1&0
	\end{bmatrix} &
	\e 1 \b 1 =\begin{bmatrix}
		0&0 \\\\ 0&1
	\end{bmatrix}
\end{matrix}

We can make any mapping $A$ as a weighted sum of these four. 

> Hopefully that's trivial.

<b-blue>

A **projection operator** is a special case of $M$ (above), with $\e v =\e w$ in any dimensions. And since vectors are normalised, $\ip v v = 1$.

$\Pi_v = \e v \b v$ is an operator projecting onto a 1D subspace spanned by $\e v$. It has these properties:

- $\Pi_v \Pi_v = \e v \b v \e v \b v = \Pi_v$ only.
- $\Pi_v \e v = \e v \b v \e v = \e v$. 
- $\Pi_v \e w = 0$ when $\e w$ is orthogonal to $\e v \pod{\e w \perp \e v} $

</b-blue>


Generally for any d-dimensional subspace E of an n-D space V, where E has basis $\\{ \e e_1 \cdots \e e_d \\}$, 

$$ \Pi_E = \e {e_1} \b {e_1} + \cdots + \e {e_d} \b {e_d} $$ 

is an operator projecting from $V \lra E$.


If $A = \begin{bmatrix}
	a & b \\\\ c & d
\end{bmatrix}, B = \begin{bmatrix}
	p & q \\\\ r & s
\end{bmatrix}$ are linear operators on $V_2$, 

Then $A \tens B : V_2 \tens V_2 \lra V_2 \tens V_2$ is defined by the action on the separate bases:
$$ \e i \e j \mapsto (A\e i)(B\e j)$$ 

This is also true for any general joint vectors.

To actually work out this matrix though, we would get a 4x4 matrix where each of the four quadrants is defined
$$ A \tens B = \begin{bmatrix}
	aB & bB \\\\ cB & dB
\end{bmatrix}. $$ 



</div>

<div class="md-conv">

### Principle 3 - Physical Evolution of Systems


<b-blue>

Any physical finite time evolution of a quantum system is represented by **unitary** linear operators on a vector space of states.

</b-blue>
<p></p>
<b-blue>

***Def.*** **Unitary matrices**: $U$ is unitary 

- **iff** $U^{-1} = U^\dagger$ (conjugate transpose);
- **iff** $U$ maps any orth-norm basis to any other orth-norm set of vectors.
- **iff** its columns or rows form an orth-norm set of vectors.

</b-blue>
<p></p>
<b-blue>

***Def.*** **Partial inner product:** On vectors in $V \tens W$:
- Take any ket $\e v \in V$, this defines a linear map $V \tens W \lra W$, which is the **partial inner product with $\e v$**.
- Which is defined on basis vectors $\e {e_i} \e {f_j} \in V \tens W$, and maps $$ \e {e_i} \e {f_j} \mapsto \ip v {e_i} \e f_j $$

If $V = W$, then we must specify *which* space is being used.

</b-blue>

***Example.*** Consider a state of 2 qbits 

$$ \e\psi = a\e{00} + b\e{01} + c\e{10} + d\e{11} \in V_A \tens V_B $$ 

Where $V = V_A = V_B$ and the first bit belongs to A, the second to B. 

We can form a partial inner product with $\0$ on either space:

\begin{align}
	_A\ip 0 \psi &= a \ip 0 0 _A \0_B + b\ip 0 0 _A \1_B + c \ip 0 1 _A \0_B + d \ip 0 1 _A \1_B \\\\
	&= a \0_B + b \1_B
\end{align}

Note that there is also the identity operator $I : A \tens I = I \tens A = A$ which is just the identity matrix.

</div>

<div class="md-conv">

### Principle 4 - Quantum Measurements and the Born Rule

> Getting information out of quantum states.
>
> Quantum measurements are invasive -- mmt changes state. 
> So even if a state has exponential info, we can only retrieve a small part of it **probabilistically**.
>
> And by doing so, change the system also.


Given a single instance $\e\psi$ of a quantum state in n-dimensional state space $V$.

<b-blue>

***Def.* The basic born rule:** (or a complete projective mmt / von neumann mmt)

- Let $B = \\{\e e_1 \cdots \e e_n\\}$ be a orth-norm basis of V. A state $\e\psi$ can be described a weighted sum of amplitude-bases:
$$ \e\psi = \sum_{i=1}^n a_i \e e_i $$ 

- Taking a measurement of this, we can get n possible outcomes $j = 1..n$, where the probability 
$$P(j) = \abs{\ip {e_j}{\psi}} ^2 = \abs{a_j}^2$$ 

- If outcome $j$ is seen, after mmt **the state is no longer $\e\psi$** but is **collapsed** to $\e{\psi_j} = \e {e_j}$.

</b-blue>

> A complete measurement is just a projection.

Thus repeated measurements on $\e{\psi_j}$ will only give outcomes $j$ forever with certainty.

The straight lines represent mod, and a probability is just the mod squared length of the **projection** of $\e\psi$ onto the given basis $\e {e_j}$. 

After projection, the state is **re-normalised** to have the squared mod sum of amplitudes equal 1 again.

<b-blue>

***Def.* Incomplete projective measurements:** 
- Let $\\{E_1 \cdots E_d \\}$ be a *decomposition* of $V$ into $d$ **mutually orthogonal** subspaces. 
- That is to say, $V = E_1 \oplus \cdots \oplus E_d$ where $\oplus$ is the "direct sum operator"
- Let $\Pi_i$ be a projection operator onto $E_i$.
- An incomplete mmt of $\e\psi$ w.r.t. the decomposition  $\\{E_1 \cdots E_d \\}$ has 
	- d possible outcomes $j = 1..d$
	- Where the probability ("Tr" is trace)
	$$P(j) = \ip{\psi}{\Pi_j^\dagger \Pi_j \vert \psi} = \ip{\psi}{\Pi_j \vert \psi} = \rm{Tr}(\Pi_j \e\psi \b\psi)$$ 
	- Where the post-mmt state is a collapsed normalised vector 
	$$ \e{\psi_j} = \frac{\Pi_j \e\psi}{\sqrt{P(j)}}$$ 

</b-blue>

> No, I don't know what a "direct sum" is either, nor a "Trace"

***Example.*** Parity measurements on two qbit states. 

The **parity** of a bit string $b_1b_2$ is just the mod-2 sum $b_1 \oplus b_2$. Alternatively, it's 1 if there are an odd number of 1s.

Make an orth-norm decomposition of the state $V$ as 
- $E_0 = \span(\e{00}, \e{11})$ :- parity zero
- $E_1 = \span(\e{01}, \e{10})$ :- parity one 

Let $\e\psi = a\e{00} + b\e{01} + c\e{10} + d\e{11}$ 
- The prob of measuring zero $P(0) = \abs{a}^2 + \abs{d}^2$
- The post-measure state $\e{\psi_0} = \frac{a\e{00} + d\e{11}}{\sqrt{\abs{a}^2 + \abs{d}^2}}$

----- 

*Addendum.* define measurement of quantum observables. 

<s-side>

***Def.*** A **quantum observable** $\Omega$ is
- a *hermitian* operator (matrix) on $V$ (meaning $\Omega$ has real eigenvalues $\lambda_{1..d}$) 
- which breaks into orthogonal $\Lambda_j : \dim(\Lambda_j) =$ the multiplicity of $\lambda_j$ (how many times that eig-val appears)
</s-side>
<s-side>

***Def.*** The measurement of such quantum observables is an incomplete mmnt which is relative to this orthogonal decomposition, and labelled by $\lambda_j$. 

</s-side>

The $\lambda_j$ values are the physical properties, and the average value of $\Omega = \sum_{j} \lambda_j P(j)$.

------

<b-blue>

***Def.* the Extended Born Rule**: 
- A special case of incomplete mmnts,
- measuring a component part of a complete system, to only partially destroy it.

Suppose $\e\psi$ is a state of system $S_1 S_2$, which is in a space $V \tens W$. 

Let bases
- $B_V = \\{\e{e_1} \cdots \e{e_n} \\}$ on V;
- $B_W = \\{\e{f_1} \cdots \e{f_m} \\}$ on W.

Then $\e\psi$ can be uniquely expanded as 
$$ \sum_{\forall i,j} c_{ij} \e{e_i} \e{f_j} $$ 

We now label the subspaces (so psi becomes $\e\psi_{VW}$), and we can expand this state as 
$$ \sum_{i=1}^n \e{e_i}_V \e{\xi_i}_W $$ 
Where $\e{\xi_i}$ is some arbitrary vector in the space W, which is generally **not** normalised nor orthogonal. (in reality $\e{\xi\_i}_W =\\, _V\ip{e\_i}{\psi}\_{VW}$)

Since $\e\psi_{VW}$ is normalised, we know that $\sum_{i=1}^n \ip{\xi_i}{\xi_i} = 1 = \ip\psi\psi$, and so we can perform a mmnt on $\e\psi$ relative to basis $B_V$ 
- A *complete measurement on $V$ but not $V \tens W$*

We have:
- outcomes $i = 1..n$, 
- corresponding orthogonal subspaces of $V \tens W$:
$$E_i = \span\\{ \e{e_i} \tens \e\xi : \xi \in W \\}$$ 
or by abusing notation $\e{e_i} \tens W$;
- which have projectors $\Pi_i = \e{e_i}\b{e_i} \tens I_W$ (identity), which we get with probability $P(i) = \ip {\xi_i}{\xi_i}$ 
- And post measurement state 
$$ \e{\psi_i} = \frac{\e{e\_i}_V \e{\xi\_i}_W}{ \sqrt{\ip{\xi\_i}{\xi\_i}} }. $$

</b-blue>

Some remarks:
- Orthogonal states are perfectly distinguishable, but non-orthogonal states are **not** completely distinguishable even if physically different.
- If $\e\psi$ has dimension $n$, any measurement on it has at most $n$ outcomes
- **But** if we adjoin it with a known quantum state, an **ancilla** $\e A$ of dimension m, that is independent of $\e\psi$, then we can measure them jointly ($\e\psi \e A$) to get $m\cdot n$ outcomes.

</div>

<div class="md-conv">
### Basic Unitary Operators for Qubits

#### Single Qubits 

We have unitary operators for single qbits.

***Hadamard Gate.***
$$ H = \frac{1 }{\sqrt{2} } \begin{bmatrix}
	1 & 1 \\\\ 1 & -1
\end{bmatrix} $$ 

This is a gate with the following properties:
- $HH = I$. 
- $H \0 = \frac{1 }{\sqrt{2} }(\0 + \1) = \e+$
- $H \1 = \frac{1 }{\sqrt{2} }(\0 - \1) = \e-$

> This is just a rotation of 45&deg; to the +/- bases.

***Pauli Gates.***
\begin{matrix}
	I = \begin{bmatrix}
		1 & 0 \\\\ 0 & 1
	\end{bmatrix} &
	\sigma_x = \begin{bmatrix}
		0 & 1 \\\\ 1 & 0
	\end{bmatrix} & 
	\sigma_y = \begin{bmatrix}
		0 & -i \\\\ i & 0
	\end{bmatrix} & 
	\sigma_z = \begin{bmatrix}
		1 & 0 \\\\ 0 & -1 
	\end{bmatrix}
\end{matrix}

These are all unitary hermitian operators, with the following properties:
- Multiplicative properties: $\sigma_x^2 + \sigma_y^2 + \sigma_z^2 = I$ 
	- This also implies the eigenvalues are $\pm 1$.
- Anti-commute properties: $\sigma_x\sigma_y = -\sigma_y\sigma_x = i\sigma_z$ 
	- These can be swapped with any combination of $x,y,z$ as long as they are in that order.

Pauli gates also have real versions:
\begin{matrix}
	X = \sigma_x & 
	Y = i\sigma_y = \begin{bmatrix}
		0 & 1 \\\\ -1 & 0
	\end{bmatrix} & 
	Z = \sigma_z
\end{matrix}

Such that 
- $X\0 = \1$, and $X\1 = \0$ -- *quantum NOT gate* 
	- i.e. $X\e k = \e{k \oplus 1} \pod{k=0,1}$ 
	- X's eigenbases are $\e+, \e-$ 
- $Z\0 = \0$, and $Z\1 = -\1$
	- i.e. $Z\e{k} = (-1)^k \e{k}$ 
	- Z's eigenbases are $\0, \1$

***Phase Gate.*** 
$$ P(\theta) = \begin{bmatrix}
	1 & 0 \\\\ 0 & e^{i\theta}	
\end{bmatrix}$$ 

Where $\theta$ is the angle of rotation. 

#### Double Qubits 

***Controlled X-gate.*** Also called CNOT, CX, controlled-NOT, etc. 

Where 
$$ CX \e j \e k = \e j \e{j \oplus k} = \e j X^j \e k$$ 
- That is, if $\e j$ is zero, do not apply the gate, and if $\e j$ is one, then apply $X\e k$. 
- $CX \0 \e\alpha = \0\e\alpha$ whilst $CX \1 \e\alpha = \1 X\e\alpha$. 

CX operates over two bits, thus the CX matrix is a 4x4 that:
$$ 
CX = \left[ \begin{array}{c:c} 
I & \mathbf{0} \\\\ \hdashline
\mathbf{0} & X 
\end{array} \right] = \begin{bmatrix}
	1&0&0&0\\\\0&1&0&0 \\\\ 0&0&0&1 \\\\ 0&0&1&0
\end{bmatrix}
$$

Note that the **order is important** to CX, and so often it is labelled with `12` or `21` with `1` being the control bit, and `2` being the applied bit. So
- $CX_{12} \0_1 \1_2 = \0_1 \1_2$ 
- $CX_{21} \0_1 \1_2 = X\0_1 \1_2 = \1_1 \1_2$

***Controlled Z-Gate.*** 
$$
CZ_{12} \e j \e k = \e{j} Z^j \e k = (-1)^{jk} \e j \e k
$$ 
CZ is **symmetric**: so the order actually doesn't matter, and 
$$ 
CZ = \left[ \begin{array}{c:c} 
I & \mathbf{0} \\\\ \hdashline
\mathbf{0} & Z 
\end{array} \right]
$$

***General Controlled Gate $CU$.*** Has the form 
$$ 
CU = \left[ \begin{array}{c:c} 
I & \mathbf{0} \\\\ \hdashline
\mathbf{0} & U 
\end{array} \right]
$$ 

</div>



</div>

<div class="colourband">
	<h2 id="qinfo">Quantum Information</h2>
</div>

<div class="cbox">
<div class="md-conv">

### Quantum States as Information Carriers

A qbit is the simplest system that can reliably encode a classical bit.

Information is proportional to the number of distinguishable states of a physical system.
- Classically, any two different states are distinguishable (trivially)
- Quantumly, states are **distinguishable** $\iff$ they are **orthogonal**
	- So if you take $\0$ and $\e+$, and a black box that outputs any one of the two, it is **impossible** to certainly identify which one it is.

Given some quantum information $\e\psi$, we can do 3 basic things:

1. **Ancilla.** Take a fixed known quant-state $\e A$ and adjoin it to our state to get a bigger one: $\e{\tilde{\psi}} = \e\psi \e A$.
2. **Unitary.** Apply a unitary operator $U$ 
3. **Measure.** Take a measurement on all or part of $\e\psi$, thus 
	- Can record result 
	- And based on outcomes choose further steps 
	- Output is generally probabilistic. 

And **any combination of the 3**.


### The No Cloning Theorem

> Quantum information cannot be copied or cloned.

Copying classical information is trivial. To relate it to operators, we can just use a CNOT operator. 

More generally, any copying process has the form
- $(b) (0) (M)$ an information register (with $b$), a blank register (with 0), and an internal machine state $M$ which is in the **Ready** state 
- And goes to $(b) (b) (M_2)$ with the blank register having the copy, and the machine state being $M_b$ post copy (since it can change during copy.)

$$ (b) (0) (M) \lra_{CNOT} (b)(b)(M)$$ 

Quantumly:
- Given some information $\e\psi_A$,
- Copying is a *quantum evolution* process of subsystems $A, B, M$. We want 
$$ \e\psi_A \0_B \e{M\_0}\_M \lra\_? \e\psi\_A \e\psi\_B \e{M\_\psi}_M $$
- Where B is the blank register space, and M is any extra space needed, which is initially in ready state $M_0$ independent of $\e\psi_A$. 

<b-blue>

***Theorem.*** **No cloning theorem** (Unitary version)

Let $S$ be any known set of quantum states of system $A$, that contains at least one pair $\e\xi, \e\eta : \e\xi \neq \e\eta$ and they are orthogonal. 

Then there exist **no unitary process** that achieves cloning of all states in $S$. 

</b-blue>

Remarks:
- If $\e\xi = \e\eta$, then there is only one state and it clones fine 
- If $\e\xi \perp \e\eta$, then they can also clone fine (can rotate to $\0, \1$ and apply CX)
	- So $CX \e k \0 = \e k \e k : k = 0,1$, 
	- but $CX(a\0 + b\1)\0 = a\e{00} + \e{11} \neq (a\0 + b\1)(a\0 + b\1)$. 
- No unitary process means no combination of operations above. 

<s-side>

***Proof.*** Let $\e\xi, \e\eta$ be two different non-orth states. Then we require the cloning process to 
$$ \e\xi\_A \0_B \e{M\_0}\_M \lra\_U \e\xi_A \e\xi_B \e{M\_\xi}_M $$ 
$$ \e\eta\_A \0_B \e{M\_0}\_M \lra\_U \e\eta_A \e\eta_B \e{M\_\eta}_M $$ 

***Note.** Unitary processes preserve inner products.*

Therefore
\begin{align}
	\ip\xi\eta \ip00 \ip{M_0}{M_0} &= \ip\xi\eta \ip\xi\eta \ip{M_\xi}{M_\eta}\\\\
	\implies \ip\xi\eta &= \ip\xi\eta \ip\xi\eta \ip{M_\xi}{M_\eta}
\end{align}
Since anything inner prod itself = 1 (in normalised vectors).

Since $\e\xi \neq \e\eta$, we know $0 &lt; \ip\xi\eta &lt; 1$, and $0 \leq \ip{M_\xi}{M_\eta} \leq 1$ (we don't really care what the machine state is)

Thus 
$$ 1 = \ip\xi\eta \ip{M_\xi} {M_\eta}  $$
Which is a contradiction since neither of the two terms on the right can ever multiply to 1. $\Box$

</s-side>

> However we *can* copy information with a good probability.

### Indistinguishability of Non-Orthogonal States

- *Given.* an unknown state $\e\psi$ of any dimension,
- *Promise.* $\e\psi$ is either $\e{\alpha_0}$ or $\e{\alpha_1}$, which are distinct known states 
- *Problem.* must determine which state $\e\psi$ is 

We know we cannot do this with certainty if $\ip{\alpha_0}{\alpha_1} \neq 0$.

***State Estimation Process.*** 
Given a state $\e\psi$, we can (1) adjoin an ancilla $\e A$, (2) do a unitary, or (3) perform a measurement.

By adjoining $\e A$ we can change the problem to discriminating against $\e{\alpha_0}\e A$ against $\e{\alpha_1}\e A$, **but** the inner product remains the same.

*The process.* Let us have a state estimation process $M_1$. We do a unitary U, followed by measurements $\Pi_0, \Pi_1$, i.e. a "rotated measurement", where the new projectors are:
$$
\tilde\Pi_i = U^\dagger \Pi_i U \pod{i=0,1}
$$
For any $\e\xi: P_{M_1}(i) = (\b{\xi}U^\dagger) \Pi_i (U\e\xi)) = \langle \xi | U^\dagger \Pi_i  U | \xi \rangle$, which becomes $\ip{\xi}{\tilde\Pi_i | \xi}$, so our rotated mnt is just a single mnt in reality.

Some measurements are better than others at giving a correct measurement -- introduce a *figure of merit*, a **success probability** $P_s$.

We assume no prior information about the state -- prior probabilities are $\frac{1}{2}$, so
$$
P_s = \frac{1}{2}P(0|\alpha_0) + \frac{1}{2}P(1|\alpha_1)
$$
Which by the born rule becomes
$$
P_s = \frac{1}{2} (\ip{\alpha_0}{\Pi_0|\alpha_0}+\ip{\alpha_1}{\Pi_1|\alpha_1})
$$
which since $\Pi_1 = I - \Pi_0$ we can write in terms of successful and mistaken inference of alpha-0:
$$
\begin{align*}
P_s &=  \frac{1}{2} + \frac{1}{2}(\ip{\alpha_0}{\Pi_0|\alpha_0} - \ip{\alpha_1}{\Pi_0|\alpha_1})\\\\
&= \frac{1}{2} + \frac{1}{2}\Tr(\Pi_0)(\e{\alpha_0}\b{\alpha_0} - \e{\alpha_1}\b{\alpha_1}) \pod{\dagger}
\end{align*}
$$
> Tr is the trace, the sum of diagonal elements.

And we want to find an optimal Pi-zero projector. Let $D = \e{\alpha_0}\b{\alpha_0} - \e{\alpha_1}\b{\alpha_1}$, we know D is hermitian, thus its eigenvalues are real. Therefore it has a complete eigenbasis of orthonormal states. 

Let $\e\beta : \e\beta \perp \e{\alpha_0}, \e{\alpha_1}$, and so
$$
D\e\beta = \e{\alpha_0}\ip{\alpha_0}\beta - \e{\alpha_1}\ip{\alpha_1}\beta = 0
$$
so D only has 2 nonzero eigenvalues. 

The trace of D is zero (the reason is left as an excersise), and so the sum of the eigenvalues is also zero. Let the eigenvalues be $\delta, -\delta$, with eigenstates $\e p, \e m$, and so $D = \delta\e p - \delta\e m$. 

We want to determine delta in terms of the alphas, so we work in subspaces of the two alphas. We need a new basis for each, so 
- Choose $\e{\alpha_0^\perp}$ to be orthnorm to $\e{\alpha_0}$, so $\e{\alpha_0^\perp}, \e{\alpha_0}$ forms a basis.
- *Let* $\e{\alpha_0} = \begin{bmatrix} 1 \\\\ 0 \end{bmatrix}; \e{\alpha_1} = \begin{bmatrix} c_0 \\\\ c_1 \end{bmatrix} = c_0\e{\alpha_0} + c_1 \e{\alpha_0^\perp}$.
Find the new coefficients by taking inner products of each base with the original vector:
- $c_0 = \ip{\alpha_0}{\alpha_1}$, $|c_1| = \sin\theta$, and $|\ip{\alpha_0}{\alpha_1}| = \cos \theta$ for the angle between the two vectors (presumably)
And so 
$$
D = \begin{bmatrix} 1 \\\\ 0 \end{bmatrix}\begin{bmatrix} 1 & 0 \end{bmatrix} -
\begin{bmatrix} c_0 \\\\ c_1 \end{bmatrix}\begin{bmatrix} c_0^* & c_1^* \end{bmatrix} = \begin{bmatrix} 
|c_1|^2 & -c_0c_1^* \\\\ -c_1c_0^* & -|c_1|^2
 \end{bmatrix}
$$
We want the eigenvectors, i.e. to solve the characteristic equation $\det(D = \lambda I) = 0$
- From this we get $\lambda = |c_1| = \pm \sin\theta$, and so $\delta = \sin  \theta$.
- Substituting into ($\dagger$)
$$
\begin{align*}
P_s &= \frac{1}{2} + \frac{\delta}{2}\Tr(\Pi_0)(\e p \b p - \e m \b m)\\\\
&= \frac{1}{2} + \frac{\delta}{2}(\b p \Pi_0 \e p - \b m \Pi_0 \e m)
\end{align*}
$$

For any projector $\Pi$ and arbitrary state $\e\xi$, we have that 
$$0 \leq \b\xi \Pi \e\xi \leq 1$$
And so $P_s$ achieves a maximum value when the LH term in the bracket goes to 1, and RH goes to 0, i.e.
$$
P_s = \frac{1}{2} + \frac{\delta}{2} = \frac{1}{2}(1+\sin\theta)
$$
When states are orthogonal, $\sin\theta = 1$, and the success chance is 1. If states are aligned, then success is zero, and somewhere in between etc.

> So how do we find $\Pi_0$?

If this is chosen to be any projection in a subspace that
- contains $\e p \implies \Pi_0 \e p = \e p$
- orthogonal to $\e m \implies \Pi_0 \e m = \e m$
Such a chance is **always possible**, since they are orthogonal, and so the achievable bound 
$$
P_s \leq \frac{1}{2}(1 + \sin\theta).
$$

> This is the *Helstrom Holevo* bound

***Note.*** 
- The ancilla is **never needed**, since only the inner product is relevant.
- If the two alphas are qubit states, we can just work in 2D space
- Optimal discrimination mnt is a **complete** mnt of a quantum observable D. 

<b-blue>

***Theorem.* Helstrom-Holevo Bound**

Given one of two equally likely states $\e{\alpha_0}, \e{\alpha_1}$ with $|\ip{\alpha_0}{\alpha_1}| = \cos \theta$, then the probability of correct identification is bounded **tightly** by
$$P_s \leq \frac{1}{2}(1 + \sin\theta)$$

</b-blue>

Remark: Other disambiguation processes are possible. We could have an **unambiguous discrimination** with three outcome states: 0, 1, fail, where fail occurs when it is neither certainly 0 nor 1.

### No Signalling Principle

***The standard setup.*** 
- We have two people, Alice and Bob, who are distantly separated in space. <span class="grey">This is an arbitary distance, and can be quite close or very far</span>
- Each hold a local quantum system A, B respectively.
- Initially, A, B is in the same (possibly entangled) quantum state. 
- Each can apply local actions on their own systems.

***The issue.*** Suppose Alice performs a local measurement on A. 

The born rule says that for each measurement outcome $k$ on A, the state at B will "instantaneously change" to reflect measurement collapse to a post-mnt state $\e{\beta_k}$.

Can B notice this change by only local actions? i.e. can we have faster-than-light information panel?

(No.)

Consider local operations on composite system $\e\psi_{AB}$. Let $H_A, H_B$ be the state space of A and B, i.e. $H_{AB} = H_A \tens H_B$. 

【Local ancilla】 Alice and bob can adjoin local ancilla spaces $A', B'$ to enlarge the dimension of their local systems.

【Local unitary】 Alice can perform a local unitary on her own half respective to B's system:
$$
\begin{matrix}U_A \tens I_B \pod{\rm{Alice}} & I_A \tens U_B \pod{\rm{Bob}}\end{matrix}
$$
**Note** that unitary operators on disjoint subsystems always commute: i.e. they can be done in any order $\lra U_A \tens U_B$. 

【Local measurement】 Say Alice performs mnt on A with some orth subspaces $E_a$, and projectors $\Pi_a$. She will have outcomes $a$. Note that the space is made as 
$$
H_A  = \oplus_a E_a
$$
like before. 

A full span measurement effect is represented by the subspace $E_a \tens H_B$, and is gotten by projector $\Pi_a \tens I_B$ over $H_{AB}$.

Similarly Bob can do the same for B, to get subspaces $F_b$ and outcomes $b$ by projectors $\Pi_b$.

By the born rule we can obtain a joint prob dist $P(a,b)$ by performing the corresponding measurements independently and getting subspace $E_a \tens F_b$, and these projectors commute.

<b-blue>

***Theorem.* No signalling principle**

Suppose Alice and Bob have access to local states A, B and a joint quantum system $\e\psi_{AB}$. Alice **cannot** convey any information to Bob by performing local operations.

i.e. no local action by Alice can change the output probability of any local quantum process of Bob

</b-blue>

<s-side>

***Proof.*** Consider a case when bob performs a complete mnt on B, w.r.t bases $\{\e b_B\}$ and outcomes $b$. 

Firstly, alice does nothing, and the state can be represented using this basis as
$$
\e\psi_{AB}  = \sum\limits_{\forall b} \e{\xi_b}_A \e b \pod{\dagger}
$$
For some xi vector where $\e{\xi\_b}\_A = \ip{b}{\psi}\_{AB}$ -- just converting bases. These are the *conditioned states of A given b*. By the born rule $P(b) = \ip{\xi\_b}{\xi\_b}$.

Now suppose alice does complete measurement w.r.t bases $\{\e a \}$ and outcomes $a$, projectors $\Pi_a = \e{a}\b{a}$. In $(\dagger)$ this becomes
$$
P(a) = \left\lVert \sum\limits\_{\forall b} (\Pi_a \e{\xi\_b}\_A) \e b\_B \right\rVert
$$
And the post measurement state is
$$
\e{\psi\_a}\_{AB} = \frac{1}{\sqrt{P(a)}}\sum\limits\_{\forall b} (\Pi\_a \e{\xi\_b}\_A) \e b\_B \pod{\ddagger}
$$

Suppose alice obtains $a$, and now bob does a measurement. $P(b|a)$ is the l2 squared of the projection of $(\ddagger)$ onto $\e b$:
$$P(b|a) = \lVert \Pi_a \e{\xi_b} \rVert^2 = \b{\xi_b} \Pi_a \e{\xi_b}$$
Therefore
$$
P(b) = \sum\limits_{\forall a}\b{\xi_b} \Pi_a \e{\xi_b} = \b{\xi_b} \sum\limits_{\forall a} \Pi_a \e{\xi_b} = \b{\xi_b} I\e{\xi_b}
$$
Which is just $\ip{\xi_b}{\xi_b} = P(b)$, so no matter what alice does, bob's measurement probabilities doesn't change. $\Box$

</s-side>

Remarks:
- This generalises to incomplete measurements -- if you sum over the projectors it gives the identity
- Unitary preserve inner products and so local unitaries won't work either
- Therefore there is no FTL transfer.



</div>
</div>

<div class="colourband">
	<h2 id="qit">Quantum Information Transfer</h2>
</div>

<div class="cbox">
<div class="md-conv">

### Quantum Dense Coding 

We know that a single qbit can only reliably encode one bit of information. i.e. you can only send one bit per qbit... right?

Well with some quantum f\_ckery we can send more information, if the qbit being sent is already entangled with a qbit at the receiver. This lets us send **2 bits** of information per qibt.

<b-blue>

***Def.*** **Bell states**, or bell basis, is defined by the following: 

\begin{align*}
\e{\phi^+} &=  \frac{1}{\sqrt{2}}(\e{00} + \e{11})\\\\
\e{\phi^-} &=  \frac{1}{\sqrt{2}}(\e{00} - \e{11})\\\\
\e{\psi^+} &= \frac{1}{\sqrt{2}}(\e{01}+\e{10})\\\\
\e{\psi^-} &= \frac{1}{\sqrt{2}}(\e{01}-\e{10})
\end{align*}

These states are orthogonal, and the bell basis for 2 qbits are give by these four:
$$
\\{ \e{\phi^+}, \e{\phi^-}, \e{\psi^+}, \e{\psi^-} \\}
$$

</b-blue>

Notably, whereas the 2 qbit computational basis (00 01 10 11) are all product states, these are all **entangled**. Also,

\begin{align}
\e{\phi^+} &= I \tens I \e{\phi^+} \\\\	
\e{\phi^-} &= Z \tens I \e{\phi^+} \\\\	
\e{\psi^+} &= X \tens I \e{\phi^+} \\\\	
\e{\psi^+} &= Y \tens I \e{\phi^+} \\\\	
\end{align}

And for any one qbit unitary U:

$$ U \tens I \e{\phi^+} = I \tens U\t \e{\phi^+} $$

We can also make these states by applying operations to the computational basis:

$$
\0\0 \overset{H \tens I}{\lra} \e+\0 = \frac{1}{\sqrt{2}}(\0 + \1)\0 \overset{CX_{12}}{\lra} \e{\phi^+}
$$

This works over the other three states and produces the other three bases.

<s-side>

***The quantum dense coding protocol.*** Let Alice and Bob (A and B) be distantly separated in space, and each has one qbit of the entangled $\e{\psi^+}$ state. A wants to send 2 bits of B, so she does:

1. A applies $I,X,Z,Y$ respectively to her (first) qbit, to make the state $\e{\phi^+}, \e{\phi^-}, \e{\psi^+}, \e{\psi^-}$, which encode messages 00, 01, 10, 11.
2. A sends this qbit to B
3. B does a **bell measurement** on both qbits together.

</s-side>
<p></p>
<b-blue>

***Def.*** A bell measurement is one of four projectors in the bell basis:

\begin{matrix}
	\Pi_0 = \e{\phi^+}\b{\phi^+} & \Pi_2 = \e{\psi^+}\b{\psi^+}  \\\\
	\Pi_4 = \e{\phi^-}\b{\phi^-} & \Pi_3 = \e{\psi^-}\b{\psi^-}
\end{matrix}

</b-blue>

### Quantum Teleportation 

A protocol to send quantum information, in the **LOCC** (local operation and classical communication) paradigm. I.e. A and B can do local quantum operations but can only communicate through classical channels.

Classical channels can mean anything, such as a phone line.

A and B are separated in space, but each have an entangled state $\e{\phi^+}$. 

A has another qbit in some arbitrary state $\e\alpha$, which is possibly unknown, and wants to send this to B without directly sending it over. A cannot identify $\e\alpha$ without destroying it, and the space between A and B is hostile to quantum transfer.

<s-side>

***The protocol.*** A can transfer $\e\alpha$ to B using the entanglement of $\e{\phi^+}$, without anything being passed through space. Let the qbit labels:

- 1: The input qbit $\e\alpha$ (owned by A)
- 2: The first qbit of entangled $\e{\phi^+}$ (owned by A)
- 3: The second qbit of entangled $\e{\phi^+}$ (owned by B)

The initial state is $\e\alpha_1 \e{\phi^+}_{23}$, where $\e\alpha = a\0 + b\1$ for some amplitudes. We have that 
\begin{align}
\e\alpha \e{\phi^+} &= (a\0 + b\1) \tens \frac{1 }{\sqrt{2} } (\e{00} + \e{11}) \\\\
&= \frac{a}{\sqrt{2}}\e{000} + \frac{a}{\sqrt{2}}\e{001} + \frac{b}{\sqrt{2}}\e{100} + \frac{b}{\sqrt{2}}\e{111} \pod{\dagger}
\end{align}

We perform the following steps.

1. A applies $CX_{12}$ to 1 and 2.
2. A applies $H$ to 1 
3. A measures both qbits in computational basis, and obtains one of 00, 01, 10, 11

(Note that this is equivalent to a bell measurement on 12)

</s-side>

We can look at the effects of these steps on $(\dagger)$:

\begin{matrix}
	\frac{a}{\sqrt{2}}\e{000} + \frac{a}{\sqrt{2}}\e{001} + \frac{b}{\sqrt{2}}\e{100} + \frac{b}{\sqrt{2}}\e{111} \\\\
	\Big\downarrow CX_{12} \\\\
	\frac{a}{\sqrt{2}}\e{000} + \frac{a}{\sqrt{2}}\e{001} + \frac{b}{\sqrt{2}}\e{110} + \frac{b}{\sqrt{2}}\e{101} \\\\
	\Big\downarrow H_1 \\\\
	\frac{a}{\sqrt{2}}(\frac{\0 + \1}{\sqrt{2}})\e{00} + \frac{a}{\sqrt{2}}(\frac{\0 + \1}{\sqrt{2}})\e{01} + \frac{b}{\sqrt{2}}(\frac{\0 - \1}{\sqrt{2}})\e{00} + \frac{b}{\sqrt{2}}(\frac{\0 - \1}{\sqrt{2}})\e{11} \\\\
	= \\\\
	\frac{1 }{2 } (\e{00}(a\0 + b\1) + \e{01}(a\1 + b\0) + \e{10}(a\0 - b\1) + \e{11}(a\1 - b\0)) \\\\
	= \\\\
	\frac{1}{2} (\e{00}I\e\alpha + \e{01}X\e\alpha+ \e{01}Z\e\alpha+ \e{01}Y\e\alpha)
\end{matrix}

Therefore via the born rule we get 

Outcome | Post measurement state | Probability
-|-|- 
00 | $ \e{00}_{12}\e\alpha_3$  | 0.25
01 | $ \e{01}_{12}X\e\alpha_3$  | 0.25
10 | $ \e{10}_{12}Z\e\alpha_3$  | 0.25
11 | $ \e{11}_{12}Y\e\alpha_3$  | 0.25

I.e. for outcome $\e{ij}$ the post measurement state has transformation $X^jZ^i$ applied. 

<s-side>

A then sends the 2 bit outcome to B, so B knows which state alpha is in.

B applies the back-transform $Z^iX^j$ to his 3 state, and the state becomes just $\e\alpha$. 

</s-side>

Teleportation!

***Quantum Circuit diagram.***

Quantum processes like this can be represented as a circuit diagram with time moving along the x axis:

![teleportation circuit diagram](./qcircuit.png)

Double lines represent classical information transfer.

Remarks:
- After teleportation, A is left, uniformly randomly, with one of the four 2 q-bit states 00, 01, 10, 11. I.e., *no information* is left at A (and consistent with no cloning and no signalling)
- Before A's measurement, B's qbit is half of the $\e{\psi^+}$ state, and we can show that any complete measurement on that would give a random outcome.
- After A's measurement, B's qbit is one of the four results all with 0.25 probability. Any complete measurement would thus result in 0 or 1 with prob 1/2.
- The *physical system* of $\e\alpha$ is not transferred, only the identity/information being reconstructed exactly in a *different* system.

</div>
</div>	

<div class="colourband">
	<h2 id="qcyp">Quantum Cryptography</h2>
</div>

<div class="cbox">
<div class="md-conv">

### Background 

Quantum cryptography takes advantage of non-orthogonal states to encode information. The receiver can thus not read message reliably, and furthermore any reading will destroy the message. 

This may be inconvenient for the sender and receiver, but much more for an eavesdropper, Eve (E).

First, we talk about classical systems.

***Secret Sharing*.** The most primitive ciphers are like the caesar cipher. For it to work, the sender and receiver must pre-share an agreed secret, the permutation to un-transform the ciphertext. This is *symmetric* encryption.

The problem with a lot of these systems is that they can be cracked, whether easily (e.g. caesar) or not. Only the **one time pad** is provably secure. Furthermore, a secret key must always be shared, which could be intercepted.

***Public Key Cryptography.*** Using *asymmetric* public private key pairs to encrypt and decrypt data.

There are many different schemes, such as RSA, but they all rely on unproved assumptions about computational hardness (i.e. $P \neq NP$), which could (but probably won't) be disproved, or skirted by using quantum computing f\_ckery.

#### The One-time Pad.

Let the message be a bitstring M of length $n$. 

Encryption/decryption requires A and B to share a private key K, also of length $n$, known **only** to them.

- A encrypts by adding K to M bitwise mod 2 (i.e. XOR). The ciphertext $C = K \oplus M$ 
- Be decrypts by doing the exact same thing. 

If K is *uniformly random*, then C is also random, and an eavesdropper seeing C would get no useful information. 

However, K must only ever be used **once**, else it could be broken. If we have two $C_1 = M_1 \oplus K$ and $C_2 \oplus K$, then an eavesdropper can do $C_1 \oplus C_2 = M_1 \oplus M_2$ and get information.

Further to this, we have to send the key in the first place.

### Quantum Key Distribution

Methods to send a key in a quantumly secure manner.

Suppose A, B are distantly separated in space, and can communicate quantumly and classically. There is an eavesdropper E who can read and access both these channels.

For quantum transmissions, we have:
$$
\begin{matrix}
	\e{\psi_{00}} = \0 & \e{\psi_{01}} = \e+ \\\\
	\e{\psi_{10}} = \1 & \e{\psi_{11}} = \e- 
\end{matrix}
$$
Given over two orth-norm basis $B_0 = \0, \1$ the Z eigenbasis, and $B_1 = \e+, \e-$ the X eigenbasis, which are called **mutually unbiased bases**.

Let bit value 0 be encoded in one of $\0, \e+$, and a 1 be encoded in one of $\1, \e-$. This means $\e{\psi_{ij}}$ has a bit value $i$ in basis $B_j$.

***Mutually Unbiased Bases.*** (MUB) A set of MUB on $\bb{C}^d$ is a set of orthnorm bases s.t. any vector of a basis is an **equally weighted superposition** of vectors in any other basis:
$$
|\ip{e_i}{f_j}|^2 = \frac{1}{d} \pod{\forall i, j \in \{\e{e_i}, \e{f_j}\}}
$$ 

I.e. $\0, \1$ are both equal weighted probabilities of the plus-minus basis, and vice versa.

There are a couple things about $N$ the max number of MUBs in dimension $d$:
- $d=2 \implies N = 3$ being the Z, X, Y eigenbases.
- For any $d$ that is **prime**, $N = d+1$ 
- For any $d$ that is **not** prime, we only know a bound for N, that is if $d = p_1^{n_1} p_2^{n_2} .. p_k^{n_k} \pod{p_1 \lt p_2 \lt \cdots \lt p_k}$ breaks down into these prime factors with these powers, $p_1^{n_1} +1 \leq N \leq d_1$.

#### BB84 Protocol

A quantum key distribution QKD protocol.

<s-side>


【1】A generates 2 random uniform strings uniformly of length n:
$$
\begin{matrix}
	X = x_1 x_2 .. x_n & Y = y_1 y_2 .. y_n
\end{matrix}
$$
Then prepares n qbit states
$$ \e{\psi_{x_1y_1}} .. \e{\psi_{x_ny_n}} $$ 

And sends these to B in order. *(Conjugate coding)*

</s-side>
<p></p>
<s-side>

【2】When B receives n qbits, they may not be in the states $\e{\psi_{x_iy_i}}$, perhaps due to channel noise, or due to eavesdropping and tampering. 

*Firstly.* Assume transmission is perfect, B receives everything as-is. 

B generates a random uniform string $ Y' = y_1' y_2' .. y_n'$ and measures each qbit $i$ in basis $B_{y'_i}$ to get $X' = x_1'..x_n'$ 

> $Y'$ is B's guess at A's encoding basis Y. 

*Note:* If B is correct $y_i' = y_i \implies x_i' = x_i$. If B is incorrect $y_i' \neq y_i$ then $x_i'$ has **no correlation** to $x_i$.

$y_i' = y_i$ happens with probability 0.5.

</s-side>
<p></p>
<s-side>

【3】A and B *publicly reveal* and compare their basis strings Y and Y' (but keep secret Xs).

They both discard all bits $x_i, x_i'$ where the basis bits do not match, leaving shorter strings of *expected* length $\frac n2 : \tilde X , \tilde X'$

Under the assumption of perfect transfer, then these bits provide the desired secret key. 

**However** there is always noise and there may be eavesdropping, and so there are 2 more steps to correct for this.

</s-side>
<p></p>
<s-side>

【4】(**Information reconciliation**) A and B want to estimate the bit error rate BER = $\rm{count}(\tilde X' \neq \tilde X)$.

They publicly compare a **subset** of Xs, at pre-agreed random positions. This can be as much as half. Then, all revealed bits are **discarded**.

They assume the remaining bits have the same *proportional error* <span class="grey">but at unknown positions</span>. 

They want to correct these errors without sacrificing too many key bits, and can be done if BER not too large.

</s-side>
<p></p>

<s-side>

【5】(**Privacy amplification**) are classical methods (not explained) for improving the quality of the key. A and B can do this, also using an estimation of the amount of information E has, via the BER.

</s-side>

There are many possible eavesdropping strategies for E. Such as 

- **Intercept and resend attack** Intercept each qbit separately, measures it in a pre-determined basis, and sends the post measurement state, or try to reconstruct the qbit from her measurement.
- **General Coherent Attack** With a "large quantum probe" unitarily interact (and entangle with) each passing bit, so E has a set of entangled bits (the "probe") which she could measure to obtain possibly joint info -- can even do this after sending and agreement.

-----

***Intercept and Resend.*** Assume quantum channel has no noise, but E intercepts each qbit and measures it in the **breidbart basis** ($\frac\pi8$ basis):

\begin{align}
	\e{\alpha_0} &= \cos \frac\pi8 \0 + \sin \frac\pi 8 \1\\\\
	\e{\alpha_1} &= \cos \frac\pi 8 \0 - \sin \frac\pi 8 \1
\end{align}

This is a basis angled just between computational and conjugate, at 22.5 degrees offset, which is the best for getting information.

We can work out that in every single case, E's probability of measuring A's bit correctly is 
$$ \cos^2 \frac\pi 8 = \frac{1 + \frac 1 {\sqrt 2}}{2} \approx 0.85 $$ 

Now the bit error rate, we have to analyse the probability of getting a *wrong* outcome case by case. This is usually done in a probability tree but I don't want to draw it so more $\TeX$:

$$
\0 \overset{|\ip{\alpha_0}{0}|^2}{\underset{\cos^2}\lra} \e{\alpha_0} \overset{|\ip{\alpha_0}{1}|^2}{\underset{\sin^2}\lra} \1 
$$
$$
\0 \overset{|\ip{\alpha_1}{0}|^2}{\underset{\cos^2}\lra} \e{\alpha_1} \overset{|\ip{\alpha_1}{1}|^2}{\underset{\sin^2}\lra} \1 
$$

Where the left is what A sends, the middle is what E resends, and the right is what B measures (wrong result only). Calculating this we have 
$$P(\rm{wrong}) = \cos^2\sin^2 + \sin^2\cos^2 = 2\sin^2\cos^2 = \frac12 (4\cos^2\sin^2) = \frac12 (2\sin\cos)^2$$
$$= \frac12 \sin^2(\frac\pi4) = \frac14$$
For the case of a missent $\0$. 

Repeating this for all the other three cases, we get $\frac14$ each time, leading to an average BER of $\frac14$.

-----

***Information Reconciliation.*** Suppose there is already some secret key established, but due to noise (or spying) there is some BER (which we have estimated).

So:
- Apply a "random public permutation" to both strings
	- to randomise positions of errors -- both sides must agree on this permutation 
- A and B breaks their strings into blocks of suitable lengths (based on BER) : unlikely each block has 2 errors 
- Compute *bit parity* for each block and announce 
	- Blocks with agreeing parity are tentatively accepted correct.
- Blocks with disagreeing parities must have odd number of errors (likely 1)
	- Break each block in half, and repeat above until offending block is 1 bit long 
	- B corrects that bit 
- Repeat the above as many times as needed to gradually reduce BER 

> Since parity is public, more info is leaked to E. However for blocks of length $k$, only $\log_2 k$ halvings, so exponentially less information is leaked.


------

***Privacy Amplification.***

Ex. A and B share 3 bit string $x_1 x_2 x_3$, and suppose E knows only 1 bit of this bitstring.

<s-side>

***Fact.*** If E knows bit $x$, not $y$, then $x \oplus y$ is uniformly random for E. 

More generally, if E knows some bit, but not all, then there is no knowledge of parity. 

</s-side>

Consider 2 bit strings $y_1 y_2:$ 

$$ \begin{matrix}
	y_1 = x_1 \oplus x_3  & y_2 = x_2 \oplus x_3
\end{matrix} $$ 

Then the outcomes can be:

x | 000 | 001 | 010 | 011 | 100 | 101 | 110 | 111 
-|-|-|-|-|-|-|-|-
y | 00 | 11 | 01 | 10 | 10 | 01 | 11 | 00

For any fixed value of any $x_1$, the corresponding $y$ outcomes are always uniform.

**These can't be arbitrarily picked, as they must be uniform depending on E's knowledge.** 

We can represent the above operation in a matrix: 

\begin{align}
	\begin{bmatrix}
		y_1 \\\\ y_2
	\end{bmatrix} &= \begin{bmatrix}
		1 & 0 & 1 \\\\ 0 & 1 & 1
	\end{bmatrix} \begin{bmatrix}
		x_1 \\\\ x_2 \\\\ x_3 
	\end{bmatrix} \\\\ 
	y &= Gx
\end{align}

> Rows of $G$ denote subsets of bits for parity sums. Generally, 

<b-blue>

***Thm.*** If E knows only $k/n$ bits, then the $m \times n \pod{m \lt n}$ matrix G will produce secret $y$s **if and only if** the minimum "hamming weight" of the code generated by G is bigger than k.

There is always a G that can generate a secret.

</b-blue>

- *Code:* representation of linear subspace of $(\bb{Z}_2)^n$, i.e. the span of k basis codewords in (that) is given by rows of G 
- *Minimum weight of code:* The least hamming weight of any code word $c \in C$ 
- *Hamming distance:* of two codewords $c_1, c_2 \in C$, is essentially `np.sum(c_1 != c_2)`.

**Universal hashing:** given an $n$ bit string, choose an $m \lt n$ and random boolean matrix $G$, then with high probability, E will have no information about the string $y = Gx$.

</div>
</div>

<div class="colourband">
	<h2 id="qm">Quantum Money</h2>
</div>

<div class="cbox">
<div class="md-conv">

### Quantum Banknotes

A quantum banknote is a banknote with a printed serial number, which is an N bit string (publicly visible), as well as N qbits embedded within (which are stable). 

For each banknote, the bank will have an N bit secret "basis" string.

When the note is manufactured, the serial number is encoded into **BB84 bases** according to the basis string.

When the note is returned / checked later, the bank can test the authenticity of the note by looking up the secret, and measuring the serial number in the basis given. The note is accepted *only if* the serial number matches exactly. 

- A genuine banknote passes the test and **remains** genuine (since the qbit doesnt change if you measure it in the right basis.)

A counterfeiter C wants to make notes that pass the test.

Consider the $k$th bit. We want to ask: what is the maximum probability that the counterfeiter can determine the $k$th basis by measuring that bit?

C can see the $k$th serial number, and knows that it is in $\0, \e+p$ for a 0 bit, and $\1, \e-$ for a 1 bit. 

To determine the basis, C must determine between two **equally probable** states (their inner product is $\frac{1}{\sqrt 2}$).

With the **Helstrom Holevo bound** we know that the maximum probability of successs is UB by 
$$
\frac{1 + \sin \frac{\pi}{2}}{2} = \frac{1 + \frac{1}{\sqrt 2}}{2} \approx 0.8535
$$
So C gets a wrong result with $p \approx 0.1465$.

Now C use uses this result to set a basis string for a new fake banknote with the same serial number. If the note is subsequently inspected by the bank, the probability that bit $k$ 
- has the correct basis and passes is 0.8535 
- has the wrong basis and passes is 0.5 &times; 0.1465
- has the wrong basis and fails is 0.5 &times; 0.1465

And so one bit would pass with $p \approx 0.926$, and so we just need to increase the number of bits to make this probability arbitrarily small.
- For 100 bits, the probability of full success is $0.926^{100} \approx 4.6 \times 10^{-4}$

</div>
</div>

<div class="colourband">
	<h2 id="complexity">Computation and Complexity Theory</h2>
</div>

<div class="cbox">
<div class="md-conv">

### Computations 

Let bitstring set $B = B_1 = \\{0, 1\\}$ be single bit bitstrings.
- $B_n$ is then the set of all $n$-bit bitstrings, and $B^*$ is the set of all finite bitstrings.

***Computational Task.*** A computational task is:
- Given an **input** as a bit string $x = i_1 i_2 .. \in B_n$ 
- A language $L \subseteq B^*$

We want to solve 
- Given $x \in B^*$, is $x \in L$?

And output 
- 1 if true, 0 if not.

***Computational Model.*** 

There are many possible choices of model, e.g. circuit model, finite automata, etc. 

But all have an important feature, they are 
- A process with discrete steps 
- Each step requires a fixed constant effort/resource to complete

<s-side>

The **circuit model** or gate array model is as follows: 

For a given $x = i_1..i_n$, we extend by an arbitary extra number of zero bits, which is our *working space*
$$ \implies i_1 .. i_n 00 .. 0$$

The basis steps are a specified sequence of $\land, \lor, \lnot$ gates on specified bits.

</s-side>

Note that this set of classical gates is universal, i.e. any func $f: B_m \lra B_n$ can be constructed by a sequence of these gates. A **computation** is a prescribed sequence of steps for each input size $n$. The **output** is the value of some designated bits, after final step.

This is a **boolean circuit**.

<s-side>

A **randomised (probabilistic) classical computation**

Like a circuit gate model, but we initially extend input $x$ *in addition* by a sequence of random bits $r_1 .. r_k$ 
$$ \implies i_1 .. i_n 0 .. 0 r_1 .. r_k $$ 

So each time the circuit is run, the r bits are set uniformly at random, and the output is probabilistic. 

Usually require output to be correct with a suitably high probability (over 0.5)

</s-side>

### Complexity 

A consumption of resources as a function of n. We have $T(n)$ the number of computational steps (time), and $Sp(n)$ the amount of space taken (space). Usually we like to look at time.

The main question is does $T(n)$ grow polynomially or exponentially (super-poly) prop. to the size of the input. 

Poly time calculations are called **tractable** or **feasible**.


</div>
</div>

	<footer>
		<div class="cbox">
			<div class="columncontainer ctwo" id="fc2">
			</div>
			<script type="text/javascript" src="../../js/footerGen.js"></script>
		</div>
	</footer>   

</div>

</body>
</html>