<!DOCTYPE html>
<html>
<head>
	<title>CS258</title>
	<meta charset="utf-8">
	<link rel="stylesheet" type="text/css" href="../../style/style.css" media="all">  <!--TODO: CHANGE HREF-->
	<link rel="stylesheet" type="text/css" href="../../style/prism.css" media="all">
	<meta name="viewport" content="width=device-width" initial-scale=1.0>  <!--TODO: CHANGE LINKS ON BOTTOM OF SHEET FOR COLLAPSIBLE-->
	<link rel="icon" type="image/png" href="../../style/images/DragonIcon.png">
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>

	<div class="hidden">
		<header>
			<div class="parallax parsmaller">
				<div  style="display: grid; grid-template-columns: 1fr 1fr 1fr 8fr 1fr; grid-column-gap: 10px; padding: 5px; ">
					<div class="column tinycolumn">
						<a href="../../" class="nav">Home</a>
					</div>
					<div class="column tinycolumn">
						<a href="../../blog.html" class="nav">Blog</a>
					</div>
					<div class="column tinycolumn">
						
						<a href="../../about.html" class="nav">About</a>
					</div>
					<div></div>
					<div class="column">
						<button class="nav dark-light">Dark Mode</button>
					</div>
				</div>
				<div class="cbox"> 		
					<h1>CS258</h1>
                    <p class="subheading">Database Systems</p>
				</div>
			</div>
		</header>

		<header>
			<div class="cbox">
				<h1>Introduction</h1>
			</div>
		</header>

		<div class="cbox">
			<h3>Contents</h3>

			<ol>
				<li><a href="#rel-db">Relational Databases and Constraints</a></li>
				<li><a href="#sql">SQL</a></li>
			</ol>

			<h3>Introduction</h3>

			<div class="cornell">
				<div>
					<p>Introduction</p>
				</div>
				<div>
					<p>
						Most of human activity is data driven or generating. This data comes in two main types: structured (tabulated, nice to process) and unstructured (hard to tabulate, like images, letters, web pages). There is also semi-structured, such as XML/JSON based data. 
					</p>
					<p>
						Traditional databases are structured and alphanumeric. Newer techologies can handle unstructured data, but often in a tabular "wrapping".
					</p>

				</div>

				<div>
					<p>Data modelling</p>
				</div>
				<div>
					<p>
						We need to consider
						<ul>
							<li>What data items do we care about (e.g. students)</li>
							<li>What attributes of said data items (e.g. ID, Name, Year)</li>
							<li>Relationships between data items and attributes of said relations</li>
						</ul>
						<b>Relational Databases</b> are table-centric, and contain "relationships" (linked attributes) between different tables to remove duplication difficulties one gets with a single table. 
					</p>
				</div>

				<div>
					<p>Principal functions of database systems</p>
				</div>
				<div>
					<p>
						<b>DB Management Systems</b> are software which manages data (as name implies). It lets us model the data; query, update, and store data; and secure and ensure the integrity and consistency of stored data. 
					</p>
					<p>
						<b>Integrity is maintained</b> in cases of unauthorised access, as well as updates to the database (which may violate constraints), concurrent transactions, failure or natural disaster, etc, etc. 
					</p>
					<p class="small"><i>In cases of natural disaster, this is not as much guaranteed.</i></p>
					<p>
						The software <b>optimises data access</b>, by creating and using indexes, finding the best way to execute a set of operations, and the best order of <i>relational data operations</i> (SELECT, PROJECT, JOIN, etc).
					</p>
					<p>
						The interface to a DBMS is often through a <b>declarative language</b> (like SQL), which lets one easily use database functions. 
					</p>
				</div>

				<div>
					<p>3-schema architecture</p>
				</div>
				<div>
					<figure>
						<img src="./3schema.svg" alt="3 Schema architecture">
						<figcaption>Our main focus is on the <i>conceptual</i> layer</figcaption>
					</figure>
				</div>

				<div>
					<p>External views</p>
				</div>
				<div>
					<p>
						Different users may not want or need access to different parts of the database, so external views are different per user group. You could think of the difference between a customer's interface vs an employee's.
					</p>
				</div>

				<div>
					<p>Other definitions</p>
				</div>
				<div>
					<p>
						The <b>Schema</b> is the collection and relations between tables. 
					</p>
					<p>
						<b>Normalisation</b> is a process of removing anomalies from tables.
					</p>
				</div>
			</div>
		</div>


		<div class="colourband">
			<h2 id="rel-db">Relational Database Model and Constraints</h2>
		</div>

		<div class="cbox">
			<h3>Contents</h3>
			<ol>
				<li><a href="#rel-1">The Relational Database</a></li>
				<li><a href="#rel-2">Constraints</a></li>
			</ol>

			<h3 id="rel-1">The Relational Database</h3>
			<div class="cornell">
				<div>
					<p>Informal Definition</p>
				</div>
				<div>
					<p>
						A <b>relation</b> is a <i>table</i> of values. It contains a set of <i>rows</i>, called <b>tuples</b>, and a set of <i>columns</i>. <br>
						Elements in rows represent certain facts of an entity, and column headers denote the atrributes of interest we store. 
					</p>

					<p>
						A <b>relational database</b> then is a database built out of relations, with known <i>table names</i> and attribute (name, type) pairs.
					</p>

					<p>
						Formulating queries involves specifying the table and attribute name(s) of interest, and setting constraints <i>(predicates)</i> that need to be satisfied for interest.
					</p>
				</div>

				<div>
					<p>Formal definition</p>
				</div>
				<div>
					<p>
						The <b>Schema</b> (description) of a relation:
						<ul>
							<li>
								Is denoted \(R(A_1, A_2, ..., A_n)\) where R is the name and \(A_i\) are attributes. <br>
								<i>Ex. <code>Customer(id, name, address, phoneNo)</code></i>
							</li>
							<li>
								Every attribute has a <b>domain</b>, a set of valid values.
							</li>
							<li>
								A <b>tuple</b> is an <i>ordered*</i> set of values, enclosed in &lt;angle brackets&gt;. <br>
								<i>A relation however is an unordered set of tuples.</i>
							</li>
							<li>
								A <b>domain</b> is a logical definition in the real world <br>
								<i>
									Ex. <code>BritishPhoneNumbers</code> are all 11 digit phone numbers in the UK.
								</i>
							</li>
							<li>
								A domain also has a data format<br>
								<i>
									Ex. US phone numbers have <code>(ddd)dddd-ddd</code> format (d for digit)
								</i>
							</li>
							<li>
								Attribute name designates the "role played" - the same domain can apply to multiple attributes. The names of said attributes determine what they are.
							</li>
							<li>
								The <b>relation state</b> is the set of all tuples in a relation (i.e. all the actual data in the relation at that time) <br>
								<i>
									A "subset of the cartesian product of all domains", 
								</i>
							</li>
						</ul>
					</p>

					<p class="small">
						* Technically attributes are unordered, but for human readability sake we make it ordered.
					</p>

					<p>
						Given the schema \(R(A_1, A_2, ..., A_n)\),
						<ul>
							<li>
								\(r(R)\) is a specific state <i>(instance)</i> of R.
							</li>
							<li>
								\(r(R) = \{t_1, t_2, ..., t_m\} : t_j\) is an n-tuple (n attributes).
							</li>
							<li>
								\(\therefore t_j = < v_1, v_2, ..., v_n> : v_j \in \textrm{domain}(A_j)\)
							</li>
							<li>
								And \(r(R) \subset \textrm{domain}(A_1) \times \textrm{domain}(A_2) \times ... \times \textrm{domain}(A_n)\)
							</li>
						</ul>
					</p>

					<p>
						The purpose of all this is to present a (relatively) human-understandable format, with the goal to simplify how to interrogate (query) and maintain the database.
					</p>
				</div>

				<div>
					<p>On schemas</p>
				</div>
				<div>
					<p>
						The <b>relation schema</b> is the relation name and attribute list (<code>Tea(name: string, manuf: string)</code> ) <br>
						The <b>Database schema</b> is the set of relationship schemas.
					</p>
					<p>
						The relation schema is defined during table creation, for example with creating a (tea) drinkers' table:
					</p>
					<pre><code class="lang-sql">CREATE TABLE Drinkers (
	name CHAR(30) Primary Key,
	addr CHAR(50) DEFAULT "0 Null Island",
	phoneNo CHAR(16) NOT NULL
);</code></pre>

					<p>
						<code>Primary Key</code> and <code>NOT NULL</code> are constraints.
					</p>
				</div>

				<div>
					<p>About the Relational Model</p>
				</div>
				<div>
					<ul>
						<li>
							The order of tuples is <i>not important</i>
						</li>
						<li>The order of attributes is not important, but we do assume order</li>
						<li>A collection of relationship schemas is the <i>database schema</i> - <b>intention</b></li>
						<li>Corresponding relation states is a relational database - <b>extension</b></li>
						<li>The metadata includes the schema and other key information about tables.</li>
					</ul>
				</div>

				<div>
					<p>Why do we use relational databases</p>
				</div>
				<div>
					<p>It's a fairly simple abstract model, but also comes with declarative languages like SQL.</p>
					<p>
						Note that the abstract model is set based, but SQL itself is <i>bag</i>-based (bags are multisets, bags can have duplicate elements whilst sets cannot).
					</p>
				</div>
			</div>

			<h3 id="rel-2">Constraints</h3>

			<p>
				Constraints exist to determine <b>permissible states</b>. 
			</p>
			<p>
				We have <b>domain constraints</b> (values in attributes must be \(\in\) domain, or null if permitted); and 3 explicit <b>schema-based constraints</b>:
				<ul>
					<li>Key constraints</li>
					<li>Entity integrity</li>
					<li>Referential integrity</li>
				</ul>
			</p>

			<div class="cornell">
				<div>
					<p>Key constraints</p>
				</div>
				<div>
					<p>
						The <b>Superkey</b> of a relation R is the subset \(SK \subseteq R :\) in <i>any</i> valid \(r(R)\), for <i>any</i> different tuples \(t_1, t_2;\;\) \(t_1[SK] \neq t_2[SK] \). Superkeys are <b>unique</b>.
					</p>
					<p>
						Ex. Take the relation <code>R(name, country, phone)</code>, the superkey <code>SK{country, phone}</code> means every row must have a unique <code>country, phone</code> combination.
					</p>
				</div>

				<div>
					<p>Minimal Key</p>
				</div>
				<div>
					<p>
						The <b>Candidate Superkey</b> of R is a <b>minimal</b> superkey. That is, if removing any attribute from the cand. key makes it not a key.
					</p>
					<p>
						A relation may have several candidate keys, one can arbitrarily determine one to be the primary key. 
					</p>
				</div>
				
				<div>
					<p>Entity integrity</p>
				</div>
				<div>
					<p>
						<b>Entity integrity</b> basically deals with nulls where they shouldn't be. 
					</p>
					<p>
						Primary keys must <i>never</i> be null (they are identifiers), and other entries can be set to not null.
					</p>
				</div>

				<div>
					<p>Referential Integrity</p>
				</div>
				<div>
					<p>
						<b>Referential Integrity</b> deals with inter-table references. 
					</p>
					<p>
						For example, we have a students table, which has student ID as a primary key. We also have a table of courses which students do, with student ID as foreign keys. If we delete a student, the foreign key for that student will be referening nothing, and this is an integrity violation.
					</p>
					<p>
						A set of attributes \(FK\) from relation \(R_1\) is a <b>Foreign Key</b> that references \(R_2\) if the attributes of \(FK\) in \(R_1\) is the <i>same</i> as the Primary Key \(PK\) in \(R_2\). Foreign keys <i>must</i> either refer to the \(PK\) of \(R_2\), or be NULL.
					</p>

					<p>
						Foreign keys are also defined during table creation.
					</p>
				</div>

				<div>
					<p>
						Semantic attribution integrity
					</p>
				</div>
				<div>
					<p>
						We also have <b>Semantic attribution integrity</b>, which in short comprise validation checks that the attributes make sense, such as Age > 0.
					</p>
				</div>

				<div>
					<p>Constraints and updates</p>
				</div>
				<div>
					<p>
						On an update operation, integrity constraints may be violated. The DB management system is there to ensure that these are caught, and corrected, rejected, or reported. <br>
						Some possible violations that may occur:
					</p>
					<ul>
						<li>
							On INSERT:
							<ul class="not">
								<li>Domain: if attribute values are not in domain</li>
								<li>Key: if key already exists</li>
								<li>Foreign Key: if FK value references nonexistent PK</li>
								<li>Entity Integ.: NULL when not null specified</li>
							</ul>
						</li>
						<li>
							On DELETE:
							<ul class="not">
								<li>Ref. Integ. (only): PK being deleted causes a FK to lose reference</li>
							</ul>
						</li>
						<li>
							on UPDATE:
							<ul class="not">
								<li>Domain and Entity integ. violations</li>
								<li>Ref. Integ.: updatng PK or FK</li>
							</ul>
						</li>
					</ul>
				</div>

				<div>
					<p>Functional dependencies</p>
				</div>
				<div>
					<p>
						<b>Functional dependencies</b> (FDs) are useful, since they are formal statements which allow derivation of good database design.
					</p>
					<p>
						Let X, Y, Z be sets of attributes, and A, B, C be single attributes, where \(ABC \implies \{A, B, C\}\).
					</p>
					<p>
						\(X \longrightarrow Y \) is an assertion about relation R and 2 sets of attributes from R, which constrains all possible tuples in \(r(R)\). If \(X \longrightarrow Y\), values of Y <i>depend</i> on values of X. For any two tuples \(t_1, t_2 \in R\), 
						\[t_1[X] = t_2[X] \implies t_1[Y] = t_2[Y]\]
						(Injunctive function)
					</p>
				</div>

				<div>
					<p>FDs and Keys</p>
				</div>
				<div>
					<p>
						<b><i>Claim.</i></b> if K is a superkey, then \(K \longrightarrow A\; \forall\) other subsets \(A \in R\)
					</p>
					<button class="collapsible">Proof.</button>
					<div class="ccontent">
						<p>
							<b><i>Proof.</i></b> Assume \(K \longrightarrow A, K \longrightarrow B\) for some \(A, B \in R\). This violates key constraints, as keys must be unique for all tuples on R. \(\Box\)
						</p>
					</div>
					<p>
						The reverse is also true, making if and only if.
					</p>
				</div>

				<div>
					<p>Determining keys</p>
				</div>
				<div>
					<p>
						(1) We can assert a key. Say "this attribute will be the key." This makes it our only functional dependency by definition. 
					</p>
					<p>
						(2) Assert functional dependencies. If we have a set of functional dependencies, then we have our key. 
					</p>
					<p>
						FDs can come from keys or physical limits, e.g. <i>no two lectures can happen in the same room at the same time</i> \(\implies\) <code>{room, time}</code> as a viable key.
					</p>
				</div>
			</div>
		</div>

		<div class="colourband">
			<h2 id="sql">Structured Query Language</h2>
		</div>

		<div class="cbox">

			<h3>Contents</h3>

			<ol>
				<li><a href="#sql-1">Declaring</a></li>
				<li><a href="#sql-2">Querying</a></li>
			</ol>

			<h3 id="sql-1">Declaring</h3>

			<div class="cornell">
				<div>
					<p>SQL and declarative languages</p>
				</div>
				<div>
					<p>
						SQL is a <b>declarative</b> language - a very high level language that tells the system merely <i>what</i> to do instead of <i>how</i> to do it. 
					</p>
					<p>
						Things like data manipulation that one would have to implement in a procedural language are implemented in the back-end by the DB management system, and it is the one responsible for finding the optimal way of carrying out an SQL command. 
					</p>
					<p>
						SQL is both a <b>data definition language</b> (DDL) and a <b>data manipulation language</b> (DML). 
					</p>
				</div>

				<div>
					<p>SQL Terminology</p>
				</div>
				<div>
					<p>
						In SQL, relations are tables, tuples are rows, and attributes are columns.
					</p>
				</div>

				<div>
					<p>Standards</p>
				</div>
				<div>
					<p>
						Whilst SQL has an official standard - SQL 3 currently - different comapnies implement SQL differently and none have implemented the standard directly, thus different platforms have <i>slightly</i> different versions of the language.
					</p>
				</div>

				<div>
					<p>Databases, Schemas, and Catalogues</p>
				</div>
				<div>
					<p>
						A database contains 1 or more schemas, which contain one or more related tables. A schema can be created with the <code class="lang-sql">create schema</code> command, and schemas can (supposedly) be given an authorisation, <code class="lang-sql">create schema Company authorisation 'JSmith'</code>
					</p>
					<p>
						If one does not create a schema before creating tables, those tables go in the default <code>public</code> schema.
					</p>
					<p>
						<i>Virtual relations</i> can be created with <code class="lang-sql">create view</code>, which aren't actual tables but "virtual" tables spanning actual tables.
					</p>
					<p>
						<i>Note that SQL is generally case insensitive.</i>
					</p>

					<p><span class="sc">now, syntax time</span></p>
				</div>

				<div>
					<p>Tables</p>
				</div>
				<div>
					<p>
						Tables are created with 
						<pre><code class="lang-sql">create table &lt;tableName&gt; (
	&lt;name1&gt; &lt;type1&gt; &lt;constraint1&gt;,
	&lt;name2&gt; &lt;type2&gt; &lt;constraint2&gt;,
	[otherConstraint], [otherConstraint]
);</code></pre>

						There are a few essential data types, their PostgreSQL (pn. post-gres) equivalents are given. The ANSI names are omitted.

						<table>
							<tr>
								<th>PostgreSQL type</th>
								<th>Description</th>
							</tr>
							<tr>
								<td><code class="lang-sql">char(n)</code></td>
								<td>Fixed length character string - string is padded with spaces </td>
							</tr>
							<tr>
								<td><code class="lang-sql">varchar(n)</code></td>
								<td>Variable limited length - like above but with no padding</td>
							</tr>
							<tr>
								<td><code class="lang-sql">numberic(p, s)</code></td>
								<td>Arbitrary precision numbers. \(p\) is precision and \(s\) is scale</td>
							</tr>
							<tr>
								<td><code class="lang-sql">int, int4, int2</code></td>
								<td>First two are 4 byte ints, <code class="lang-sql">int2</code> is a 2 byte int</td>
							</tr>
							<tr>
								<td><code class="lang-sql">float4, float8</code></td>
								<td>4 byte and 8 byte floating point numbers</td>
							</tr>
						</table>
						Amongst others like <code class="lang-sql">blob, date, boolean, time</code>, etc.
					</p>

					<p>
						Thus we can create an example table like so:
						<pre><code class="lang-sql">create table students (
	studentID int primary key,  -- this is a comment
	studentName varchar(30),  -- char varying
	courseID int
);</code></pre>
					</p>

					<p>
						Attributes can be set to have a default value, not null, and semantic checks
						<pre><code class="lang-sql">accountBalance real not null default 0.0,
age int not null check (age &gt; 0 and age &lt; 125)</code></pre>
					</p>

					<p>
						One may also add a unique clause - this can specify alternate secondary keys, candidate keys. 
						<pre><code class="lang-sql">dname varchar(15) unique</code></pre>
					</p>
					
				</div>

				<div>
					<p>Foreign keys</p>
				</div>
				<div>
					<p>
						Constraints can be declared inline or at the after attributes. Below is an exmaple with foreign keys, where constraints are written at the end. 
						<pre><code class="lang-sql">create table project (
	Pname varchar(15) not null,
	Pnumber int not null,
	Plocation int,
	Dnum int not null, 
	primary key (Pnumber),
	unique (Pname),
	foreign key (Dnum) references department (Dnumber) 
	-- department is another table
);</code></pre>
					</p>

				</div>

				<div>
					<p>Constraints</p>
				</div>
				<div>
					<p>
						One can set actions for foreign keys, which would trigger when specific updates cause integrity violations. These actions are <code class="lang-sql">set null</code>, <code class="lang-sql">cascade</code> (propagate), <code class="lang-sql">set default</code>.
					</p>
					<p>
						Different actions can happen for different queries, specified with <code class="lang-sql">on update</code> and <code class="lang-sql">on delete</code>. Thus,

						<pre><code class="lang-sql">constraint superSSN_SSN
    foreign key (superSSN) references employee (SSN)
	on delete set null
	on update cascade</code></pre>
						
						Where <code>superSSN_SSN</code> is the name of the constraint.
					</p>

					<p>
						Constraints can also be set on fields inline, with the syntax <code class="lang-sql">constraint name details</code>
						<pre><code class="lang-sql">studentID int constraint nonzero check (studentID > 0)</code></pre>
					</p>

				</div>

				<div>
					<p><code>rm -rf /</code></p>
				</div>
				<div>
					<p>
						SQL also has delete (DROP) commands, which <i>do not double check</i> and will delete your data. Use with caution. 
					</p>
					<p>
						These are <code class="lang-sql">drop table</code> and <code class="lang-sql">drop schema</code>.
					</p>
				</div>
			</div>

			<h3 id="sql-2">Querying</h3>

			<div class="cornell">
				<div>
					<p>Selecting</p>
				</div>
				<div>
					<p>
						SQL allows duplicate entries in the database - these are dealt with at point of query instead of point of insertion.
					</p>
					<p>
						Generally, the terminology is that rows are <b>selected</b> whilst columns are <b>projected</b>.
					</p>
					<p>
						The basic select command is like <code class="lang-sql">select attr1, attr2 from someTable where someCondition;</code>. 
					</p>
					<p>
						The output is <i>also a table</i>, and we can manipulate said table.
						<ul>
							<li><code class="lang-sql">select distinct</code> removes duplicates</li>
							<li><code class="lang-sql">where</code> sets conditions on which rows are selected, and use the boolean operations <code class="lang-sql">and or not</code>.</li>
							<li><code class="lang-sql">*</code> is the wildcard "all" operator.</li>
						</ul>
					</p>
					<p>
						We can qualify names using a dot, if there are multiple tables that share a column name (whether through foreign keys or otherwise), by doing <code class="lang-sql">select students.studentID from students, courses;</code>.
					</p>
					<p>
						If table names are too long or unweildy, they can be <b>aliased</b>, for example <code class="lang-sql">S.studentID from students S</code>.
					</p>
					<p>
						Please note that strings in SQL are single quoted only.
					</p>
					<p>
						We can order by a field by <code class="lang-sql">order by field asc</code> (or <code class="lang-sql">desc</code>)
					</p>
					<p>
						Columns can be renamed using as, such as <code class="lang-sql">select name as teaName, manufacturer from</code>... 
					</p>
				</div>

				<div>
					<p>Operational semantics</p>
				</div>
				<div>
					<p>
						The general order of operations goes
						<ul>
							<li>Get relation in <code class="lang-sql">from</code> clause</li>
							<li>Apply the <i>row selection</i> in <code class="lang-sql">where</code></li>
							<li>Apply the <i>column projection</i> in <code class="lang-sql">select</code></li>
						</ul>
						When performing comparisons, linear search is used. 
					</p>
				</div>

				<div>
					<p>Comparisons</p>
				</div>
				<div>
					<p>
						Once can replace a column value with a constant value. For example, if we search from a database of tea drinkers for those with Earl Grey as favourite tea, we can do something like the following:
						<pre><code class="lang-sql">select drinker, 'likes earl grey' as likesEarlGrey 
	from likes
	where tea = 'Earl Grey';</code></pre>
	
						There are several more string functions, but often these are implementation-specific. 
					</p>
					
					<p>
						Apostrophes have to be written using double quotes, so <code class="lang-sql">'Joe"s'</code> would mean Joe's.
					</p>

					<p>
						String attributes can also be <b>pattern matched</b>, using the keywords <code class="lang-sql">like</code> and <code class="lang-sql">not like</code>. A pattern is a quoted string with special characters, like a simplified form of regex. <code class="lang-sql">_</code> means any one character, <code class="lang-sql">%</code> means any number of any characters.

						<pre><code class="lang-sql">where phone like '%1926_______'</code></pre>
					</p>
				</div>
				<div>
					<p>Nulls</p>
				</div>
				<div>
					<p>
						Nulls are special in that they are <b>not real values</b>. They are useful for unknown/not applicable values.
					</p>
					<p>
						Thus, nulls are <b>incomparable</b>: if A's phone number is NULL, B's is also NULL, A's phone number <b>does not equal</b> B's. 
					</p>
					<p>
						SQL comparisons actually have <b>three boolean values</b>, those being <b>True, False, Unknown</b>. Comparing with NULL can yield unknown values. The process of three value logic is that if the value of unknown does not matter in an expression (e.g. \(F \land U = F\) and \(T \lor U = T\)). 
					</p>

					<button class="collapsible">Truth Tables...</button>
					<div class="ccontent">
						<img src="./3logictruth.png" alt="3 logic truth table">
					</div>

					<p>
						To check nulls, use <i>is</i>: <code class="lang-sql">attr is null</code> or <code class="lang-sql">attr is not null</code>.
					</p>
				</div>
			</div>
		</div>

		<footer>
			<div class="cbox">
                <div class="columncontainer ctwo" id="fc2">
                </div>
                <script type="text/javascript" src="../../js/footerGen.js"></script>
            </div>
		</footer>

	</div>

	<script type="text/javascript" src="../../js/collapsible.js"></script>  <!--This stays at the end-->
	<script type="text/javascript" src="../../js/toggle-darklight.js"></script>
	<script type="text/javascript" src="../../js/prism.js"></script>
</body>
</html>