<!DOCTYPE html>
<html>
<head>
	<title>CS258</title>
	<meta charset="utf-8">
	<link rel="stylesheet" type="text/css" href="../../style/style.css" media="all">  <!--TODO: CHANGE HREF-->
	<link rel="stylesheet" type="text/css" href="../../style/prism.css" media="all">
	<meta name="viewport" content="width=device-width" initial-scale=1.0>  <!--TODO: CHANGE LINKS ON BOTTOM OF SHEET FOR COLLAPSIBLE-->
	<link rel="icon" type="image/png" href="../../style/images/DragonIcon.png">
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>

	<div class="hidden">
		<header>
			<div class="parallax parsmaller">
				<div  style="display: grid; grid-template-columns: 1fr 1fr 1fr 8fr 1fr; grid-column-gap: 10px; padding: 5px; ">
					<div class="column tinycolumn">
						<a href="../../" class="nav">Home</a>
					</div>
					<div class="column tinycolumn">
						<a href="../../blog.html" class="nav">Blog</a>
					</div>
					<div class="column tinycolumn">
						
						<a href="../../about.html" class="nav">About</a>
					</div>
					<div></div>
					<div class="column">
						<button class="nav dark-light">Dark Mode</button>
					</div>
				</div>
				<div class="cbox"> 		
					<h1>CS258</h1>
                    <p class="subheading">Database Systems</p>
				</div>
			</div>
		</header>

		<header>
			<div class="cbox">
				<h1>Introduction</h1>
			</div>
		</header>

		<div class="cbox">
			<h3>Contents</h3>

			<ol>
				<li><a href="#rel-db">Relational Databases and Constraints</a></li>
				<li><a href="#sql">SQL</a></li>
				<li><a href="#algebra">Relational Algebra</a></li>
				<li><a href="#calculus">Relational Calculus</a></li>
				<li><a href="#design">Database Design, Normalisation and Security</a></li>
			</ol>

			<h3>Introduction</h3>

			<div class="cornell">
				<div>
					<p>Introduction</p>
				</div>
				<div>
					<p>
						Most of human activity is data driven or generating. This data comes in two main types: structured (tabulated, nice to process) and unstructured (hard to tabulate, like images, letters, web pages). There is also semi-structured, such as XML/JSON based data. 
					</p>
					<p>
						Traditional databases are structured and alphanumeric. Newer techologies can handle unstructured data, but often in a tabular "wrapping".
					</p>

				</div>

				<div>
					<p>Data modelling</p>
				</div>
				<div>
					<p>
						We need to consider
						<ul>
							<li>What data items do we care about (e.g. students)</li>
							<li>What attributes of said data items (e.g. ID, Name, Year)</li>
							<li>Relationships between data items and attributes of said relations</li>
						</ul>
						<b>Relational Databases</b> are table-centric, and contain "relationships" (linked attributes) between different tables to remove duplication difficulties one gets with a single table. 
					</p>
				</div>

				<div>
					<p>Principal functions of database systems</p>
				</div>
				<div>
					<p>
						<b>DB Management Systems</b> are software which manages data (as name implies). It lets us model the data; query, update, and store data; and secure and ensure the integrity and consistency of stored data. 
					</p>
					<p>
						<b>Integrity is maintained</b> in cases of unauthorised access, as well as updates to the database (which may violate constraints), concurrent transactions, failure or natural disaster, etc, etc. 
					</p>
					<p class="small"><i>In cases of natural disaster, this is not as much guaranteed.</i></p>
					<p>
						The software <b>optimises data access</b>, by creating and using indexes, finding the best way to execute a set of operations, and the best order of <i>relational data operations</i> (SELECT, PROJECT, JOIN, etc).
					</p>
					<p>
						The interface to a DBMS is often through a <b>declarative language</b> (like SQL), which lets one easily use database functions. 
					</p>
				</div>

				<div>
					<p>3-schema architecture</p>
				</div>
				<div>
					<figure>
						<img src="./3schema.svg" alt="3 Schema architecture">
						<figcaption>Our main focus is on the <i>conceptual</i> layer</figcaption>
					</figure>
				</div>

				<div>
					<p>External views</p>
				</div>
				<div>
					<p>
						Different users may not want or need access to different parts of the database, so external views are different per user group. You could think of the difference between a customer's interface vs an employee's.
					</p>
				</div>

				<div>
					<p>Other definitions</p>
				</div>
				<div>
					<p>
						The <b>Schema</b> is the collection and relations between tables. 
					</p>
					<p>
						<b>Normalisation</b> is a process of removing anomalies from tables.
					</p>
				</div>
			</div>
		</div>


		<div class="colourband">
			<h2 id="rel-db">Relational Database Model and Constraints</h2>
		</div>

		<div class="cbox">
			<h3>Contents</h3>
			<ol>
				<li><a href="#rel-1">The Relational Database</a></li>
				<li><a href="#rel-2">Constraints</a></li>
			</ol>

			<h3 id="rel-1">The Relational Database</h3>
			<div class="cornell">
				<div>
					<p>Informal Definition</p>
				</div>
				<div>
					<p>
						A <b>relation</b> is a <i>table</i> of values. It contains a set of <i>rows</i>, called <b>tuples</b>, and a set of <i>columns</i>. <br>
						Elements in rows represent certain facts of an entity, and column headers denote the atrributes of interest we store. 
					</p>

					<p>
						A <b>relational database</b> then is a database built out of relations, with known <i>table names</i> and attribute (name, type) pairs.
					</p>

					<p>
						Formulating queries involves specifying the table and attribute name(s) of interest, and setting constraints <i>(predicates)</i> that need to be satisfied for interest.
					</p>
				</div>

				<div>
					<p>Formal definition</p>
				</div>
				<div>
					<p>
						The <b>Schema</b> (description) of a relation:
						<ul>
							<li>
								Is denoted \(R(A_1, A_2, ..., A_n)\) where R is the name and \(A_i\) are attributes. <br>
								<i>Ex. <code>Customer(id, name, address, phoneNo)</code></i>
							</li>
							<li>
								Every attribute has a <b>domain</b>, a set of valid values.
							</li>
							<li>
								A <b>tuple</b> is an <i>ordered*</i> set of values, enclosed in &lt;angle brackets&gt;. <br>
								<i>A relation however is an unordered set of tuples.</i>
							</li>
							<li>
								A <b>domain</b> is a logical definition in the real world <br>
								<i>
									Ex. <code>BritishPhoneNumbers</code> are all 11 digit phone numbers in the UK.
								</i>
							</li>
							<li>
								A domain also has a data format<br>
								<i>
									Ex. US phone numbers have <code>(ddd)dddd-ddd</code> format (d for digit)
								</i>
							</li>
							<li>
								Attribute name designates the "role played" - the same domain can apply to multiple attributes. The names of said attributes determine what they are.
							</li>
							<li>
								The <b>relation state</b> is the set of all tuples in a relation (i.e. all the actual data in the relation at that time) <br>
								<i>
									A "subset of the cartesian product of all domains", 
								</i>
							</li>
						</ul>
					</p>

					<p class="small">
						* Technically attributes are unordered, but for human readability sake we make it ordered.
					</p>

					<p>
						Given the schema \(R(A_1, A_2, ..., A_n)\),
						<ul>
							<li>
								\(r(R)\) is a specific state <i>(instance)</i> of R.
							</li>
							<li>
								\(r(R) = \{t_1, t_2, ..., t_m\} : t_j\) is an n-tuple (n attributes).
							</li>
							<li>
								\(\therefore t_j = < v_1, v_2, ..., v_n> : v_j \in \textrm{domain}(A_j)\)
							</li>
							<li>
								And \(r(R) \subset \textrm{domain}(A_1) \times \textrm{domain}(A_2) \times ... \times \textrm{domain}(A_n)\)
							</li>
						</ul>
					</p>

					<p>
						The purpose of all this is to present a (relatively) human-understandable format, with the goal to simplify how to interrogate (query) and maintain the database.
					</p>
				</div>

				<div>
					<p>On schemas</p>
				</div>
				<div>
					<p>
						The <b>relation schema</b> is the relation name and attribute list (<code>Tea(name: string, manuf: string)</code> ) <br>
						The <b>Database schema</b> is the set of relationship schemas.
					</p>
					<p>
						The relation schema is defined during table creation, for example with creating a (tea) drinkers' table:
					</p>
					<pre><code class="lang-sql">CREATE TABLE Drinkers (
	name CHAR(30) Primary Key,
	addr CHAR(50) DEFAULT "0 Null Island",
	phoneNo CHAR(16) NOT NULL
);</code></pre>

					<p>
						<code>Primary Key</code> and <code>NOT NULL</code> are constraints.
					</p>
				</div>

				<div>
					<p>About the Relational Model</p>
				</div>
				<div>
					<ul>
						<li>
							The order of tuples is <i>not important</i>
						</li>
						<li>The order of attributes is not important, but we do assume order</li>
						<li>A collection of relationship schemas is the <i>database schema</i> - <b>intention</b></li>
						<li>Corresponding relation states is a relational database - <b>extension</b></li>
						<li>The metadata includes the schema and other key information about tables.</li>
					</ul>
				</div>

				<div>
					<p>Why do we use relational databases</p>
				</div>
				<div>
					<p>It's a fairly simple abstract model, but also comes with declarative languages like SQL.</p>
					<p>
						Note that the abstract model is set based, but SQL itself is <i>bag</i>-based (bags are multisets, bags can have duplicate elements whilst sets cannot).
					</p>
				</div>
			</div>

			<h3 id="rel-2">Constraints</h3>

			<p>
				Constraints exist to determine <b>permissible states</b>. 
			</p>
			<p>
				We have <b>domain constraints</b> (values in attributes must be \(\in\) domain, or null if permitted); and 3 explicit <b>schema-based constraints</b>:
				<ul>
					<li>Key constraints</li>
					<li>Entity integrity</li>
					<li>Referential integrity</li>
				</ul>
			</p>

			<div class="cornell">
				<div>
					<p>Key constraints</p>
				</div>
				<div>
					<p>
						The <b>Superkey</b> of a relation R is the subset \(SK \subseteq R :\) in <i>any</i> valid \(r(R)\), for <i>any</i> different tuples \(t_1, t_2;\;\) \(t_1[SK] \neq t_2[SK] \). Superkeys are <b>unique</b>.
					</p>
					<p>
						Ex. Take the relation <code>R(name, country, phone)</code>, the superkey <code>SK{country, phone}</code> means every row must have a unique <code>country, phone</code> combination.
					</p>
				</div>

				<div>
					<p>Minimal Key</p>
				</div>
				<div>
					<p>
						The <b>Candidate Superkey</b> of R is a <b>minimal</b> superkey. That is, if removing any attribute from the cand. key makes it not a key.
					</p>
					<p>
						A relation may have several candidate keys, one can arbitrarily determine one to be the primary key. 
					</p>
				</div>
				
				<div>
					<p>Entity integrity</p>
				</div>
				<div>
					<p>
						<b>Entity integrity</b> basically deals with nulls where they shouldn't be. 
					</p>
					<p>
						Primary keys must <i>never</i> be null (they are identifiers), and other entries can be set to not null.
					</p>
				</div>

				<div>
					<p>Referential Integrity</p>
				</div>
				<div>
					<p>
						<b>Referential Integrity</b> deals with inter-table references. 
					</p>
					<p>
						For example, we have a students table, which has student ID as a primary key. We also have a table of courses which students do, with student ID as foreign keys. If we delete a student, the foreign key for that student will be referening nothing, and this is an integrity violation.
					</p>
					<p>
						A set of attributes \(FK\) from relation \(R_1\) is a <b>Foreign Key</b> that references \(R_2\) if the attributes of \(FK\) in \(R_1\) is the <i>same</i> as the Primary Key \(PK\) in \(R_2\). Foreign keys <i>must</i> either refer to the \(PK\) of \(R_2\), or be NULL.
					</p>

					<p>
						Foreign keys are also defined during table creation.
					</p>
				</div>

				<div>
					<p>
						Semantic attribution integrity
					</p>
				</div>
				<div>
					<p>
						We also have <b>Semantic attribution integrity</b>, which in short comprise validation checks that the attributes make sense, such as Age > 0.
					</p>
				</div>

				<div>
					<p>Constraints and updates</p>
				</div>
				<div>
					<p>
						On an update operation, integrity constraints may be violated. The DB management system is there to ensure that these are caught, and corrected, rejected, or reported. <br>
						Some possible violations that may occur:
					</p>
					<ul>
						<li>
							On INSERT:
							<ul class="not">
								<li>Domain: if attribute values are not in domain</li>
								<li>Key: if key already exists</li>
								<li>Foreign Key: if FK value references nonexistent PK</li>
								<li>Entity Integ.: NULL when not null specified</li>
							</ul>
						</li>
						<li>
							On DELETE:
							<ul class="not">
								<li>Ref. Integ. (only): PK being deleted causes a FK to lose reference</li>
							</ul>
						</li>
						<li>
							on UPDATE:
							<ul class="not">
								<li>Domain and Entity integ. violations</li>
								<li>Ref. Integ.: updatng PK or FK</li>
							</ul>
						</li>
					</ul>
				</div>

				<div>
					<p>Functional dependencies</p>
				</div>
				<div>
					<p>
						<b>Functional dependencies</b> (FDs) are useful, since they are formal statements which allow derivation of good database design.
					</p>
					<p>
						Let X, Y, Z be sets of attributes, and A, B, C be single attributes, where \(ABC \implies \{A, B, C\}\).
					</p>
					<p>
						\(X \longrightarrow Y \) is an assertion about relation R and 2 sets of attributes from R, which constrains all possible tuples in \(r(R)\). If \(X \longrightarrow Y\), values of Y <i>depend</i> on values of X. For any two tuples \(t_1, t_2 \in R\), 
						\[t_1[X] = t_2[X] \implies t_1[Y] = t_2[Y]\]
						(Injunctive function)
					</p>
				</div>

				<div>
					<p>FDs and Keys</p>
				</div>
				<div>
					<p>
						<b><i>Claim.</i></b> if K is a superkey, then \(K \longrightarrow A\; \forall\) other subsets \(A \in R\)
					</p>
					<button class="collapsible">Proof.</button>
					<div class="ccontent">
						<p>
							<b><i>Proof.</i></b> Assume \(K \longrightarrow A, K \longrightarrow B\) for some \(A, B \in R\). This violates key constraints, as keys must be unique for all tuples on R. \(\Box\)
						</p>
					</div>
					<p>
						The reverse is also true, making if and only if.
					</p>
				</div>

				<div>
					<p>Determining keys</p>
				</div>
				<div>
					<p>
						(1) We can assert a key. Say "this attribute will be the key." This makes it our only functional dependency by definition. 
					</p>
					<p>
						(2) Assert functional dependencies. If we have a set of functional dependencies, then we have our key. 
					</p>
					<p>
						FDs can come from keys or physical limits, e.g. <i>no two lectures can happen in the same room at the same time</i> \(\implies\) <code>{room, time}</code> as a viable key.
					</p>
				</div>
			</div>
		</div>

		<div class="colourband">
			<h2 id="sql">Structured Query Language</h2>
		</div>

		<div class="cbox">

			<h3>Contents</h3>

			<ol>
				<li><a href="#sql-1">Declaring</a></li>
				<li><a href="#sql-2">Querying</a></li>
				<li><a href="#sql-3">Updating</a></li>
				<li><a href="#sql-4">Joins</a></li>
				<li><a href="#sql-5">Query Nesting</a></li>
				<li><a href="#sql-6">Correlated Subqueries</a></li>
				<li><a href="#sql-7">Aggregation and Grouping</a></li>
			</ol>

			<h3 id="sql-1">Declaring</h3>

			<div class="cornell">
				<div>
					<p>SQL and declarative languages</p>
				</div>
				<div>
					<p>
						SQL is a <b>declarative</b> language - a very high level language that tells the system merely <i>what</i> to do instead of <i>how</i> to do it. 
					</p>
					<p>
						Things like data manipulation that one would have to implement in a procedural language are implemented in the back-end by the DB management system, and it is the one responsible for finding the optimal way of carrying out an SQL command. 
					</p>
					<p>
						SQL is both a <b>data definition language</b> (DDL) and a <b>data manipulation language</b> (DML). 
					</p>
				</div>

				<div>
					<p>SQL Terminology</p>
				</div>
				<div>
					<p>
						In SQL, relations are tables, tuples are rows, and attributes are columns.
					</p>
				</div>

				<div>
					<p>Standards</p>
				</div>
				<div>
					<p>
						Whilst SQL has an official standard - SQL 3 currently - different comapnies implement SQL differently and none have implemented the standard directly, thus different platforms have <i>slightly</i> different versions of the language.
					</p>
				</div>

				<div>
					<p>Databases, Schemas, and Catalogues</p>
				</div>
				<div>
					<p>
						A database contains 1 or more schemas, which contain one or more related tables. A schema can be created with the <code class="lang-sql">create schema</code> command, and schemas can (supposedly) be given an authorisation, <code class="lang-sql">create schema Company authorisation 'JSmith'</code>
					</p>
					<p>
						If one does not create a schema before creating tables, those tables go in the default <code>public</code> schema.
					</p>
					<p>
						<i>Virtual relations</i> can be created with <code class="lang-sql">create view</code>, which aren't actual tables but "virtual" tables spanning actual tables.
					</p>
					<p>
						<i>Note that SQL is generally case insensitive.</i>
					</p>

					<p><span class="sc">now, syntax time</span></p>
				</div>

				<div>
					<p>Tables</p>
				</div>
				<div>
					<p>
						Tables are created with 
						<pre><code class="lang-sql">create table &lt;tableName&gt; (
	&lt;name1&gt; &lt;type1&gt; &lt;constraint1&gt;,
	&lt;name2&gt; &lt;type2&gt; &lt;constraint2&gt;,
	[otherConstraint], [otherConstraint]
);</code></pre>

						There are a few essential data types, their PostgreSQL (pn. post-gres) equivalents are given. The ANSI names are omitted.

						<table>
							<tr>
								<th>PostgreSQL type</th>
								<th>Description</th>
							</tr>
							<tr>
								<td><code class="lang-sql">char(n)</code></td>
								<td>Fixed length character string - string is padded with spaces </td>
							</tr>
							<tr>
								<td><code class="lang-sql">varchar(n)</code></td>
								<td>Variable limited length - like above but with no padding</td>
							</tr>
							<tr>
								<td><code class="lang-sql">numberic(p, s)</code></td>
								<td>Arbitrary precision numbers. \(p\) is precision and \(s\) is scale</td>
							</tr>
							<tr>
								<td><code class="lang-sql">int, int4, int2</code></td>
								<td>First two are 4 byte ints, <code class="lang-sql">int2</code> is a 2 byte int</td>
							</tr>
							<tr>
								<td><code class="lang-sql">float4, float8</code></td>
								<td>4 byte and 8 byte floating point numbers</td>
							</tr>
						</table>
						Amongst others like <code class="lang-sql">blob, date, boolean, time</code>, etc.
					</p>

					<p>
						Thus we can create an example table like so:
						<pre><code class="lang-sql">create table students (
	studentID int primary key,  -- this is a comment
	studentName varchar(30),  -- char varying
	courseID int
);</code></pre>
					</p>

					<p>
						Attributes can be set to have a default value, not null, and semantic checks
						<pre><code class="lang-sql">accountBalance real not null default 0.0,
age int not null check (age &gt; 0 and age &lt; 125)</code></pre>
					</p>

					<p>
						One may also add a unique clause - this can specify alternate secondary keys, candidate keys. 
						<pre><code class="lang-sql">dname varchar(15) unique</code></pre>
					</p>
					
				</div>

				<div>
					<p>Foreign keys</p>
				</div>
				<div>
					<p>
						Constraints can be declared inline or at the after attributes. Below is an exmaple with foreign keys, where constraints are written at the end. 
						<pre><code class="lang-sql">create table project (
	Pname varchar(15) not null,
	Pnumber int not null,
	Plocation int,
	Dnum int not null, 
	primary key (Pnumber),
	unique (Pname),
	foreign key (Dnum) references department (Dnumber) 
	-- department is another table
);</code></pre>
					</p>

				</div>

				<div>
					<p>Constraints</p>
				</div>
				<div>
					<p>
						One can set actions for foreign keys, which would trigger when specific updates cause integrity violations. These actions are <code class="lang-sql">set null</code>, <code class="lang-sql">cascade</code> (propagate), <code class="lang-sql">set default</code>.
					</p>
					<p>
						Different actions can happen for different queries, specified with <code class="lang-sql">on update</code> and <code class="lang-sql">on delete</code>. Thus,

						<pre><code class="lang-sql">constraint superSSN_SSN
    foreign key (superSSN) references employee (SSN)
	on delete set null
	on update cascade</code></pre>
						
						Where <code>superSSN_SSN</code> is the name of the constraint.
					</p>

					<p>
						Constraints can also be set on fields inline, with the syntax <code class="lang-sql">constraint name details</code>
						<pre><code class="lang-sql">studentID int constraint nonzero check (studentID > 0)</code></pre>
					</p>

				</div>

				<div>
					<p><code>rm -rf /</code></p>
				</div>
				<div>
					<p>
						SQL also has delete (DROP) commands, which <i>do not double check</i> and will delete your data. Use with caution. 
					</p>
					<p>
						These are <code class="lang-sql">drop table</code> and <code class="lang-sql">drop schema</code>.
					</p>
				</div>
			</div>

			<h3 id="sql-2">Querying</h3>

			<div class="cornell">
				<div>
					<p>Selecting</p>
				</div>
				<div>
					<p>
						SQL allows duplicate entries in the database - these are dealt with at point of query instead of point of insertion.
					</p>
					<p>
						Generally, the terminology is that rows are <b>selected</b> whilst columns are <b>projected</b>.
					</p>
					<p>
						The basic select command is like <code class="lang-sql">select attr1, attr2 from someTable where someCondition;</code>. 
					</p>
					<p>
						The output is <i>also a table</i>, and we can manipulate said table.
						<ul>
							<li><code class="lang-sql">select distinct</code> removes duplicates</li>
							<li><code class="lang-sql">where</code> sets conditions on which rows are selected, and use the boolean operations <code class="lang-sql">and or not</code>.</li>
							<li><code class="lang-sql">*</code> is the wildcard "all" operator.</li>
						</ul>
					</p>
					<p>
						We can qualify names using a dot, if there are multiple tables that share a column name (whether through foreign keys or otherwise), by doing <code class="lang-sql">select students.studentID from students, courses;</code>.
					</p>
					<p>
						If table names are too long or unweildy, they can be <b>aliased</b>, for example <code class="lang-sql">S.studentID from students S</code>.
					</p>
					<p>
						Please note that strings in SQL are single quoted only.
					</p>
					<p>
						We can order by a field by <code class="lang-sql">order by field asc</code> (or <code class="lang-sql">desc</code>)
					</p>
					<p>
						Columns can be renamed using as, such as <code class="lang-sql">select name as teaName, manufacturer from</code>... 
					</p>
				</div>

				<div>
					<p>Operational semantics</p>
				</div>
				<div>
					<p>
						The general order of operations goes
						<ul>
							<li>Get relation in <code class="lang-sql">from</code> clause</li>
							<li>Apply the <i>row selection</i> in <code class="lang-sql">where</code></li>
							<li>Apply the <i>column projection</i> in <code class="lang-sql">select</code></li>
						</ul>
						When performing comparisons, linear search is used. 
					</p>
				</div>

				<div>
					<p>Comparisons</p>
				</div>
				<div>
					<p>
						Once can replace a column value with a constant value. For example, if we search from a database of tea drinkers for those with Earl Grey as favourite tea, we can do something like the following:
						<pre><code class="lang-sql">select drinker, 'likes earl grey' as likesEarlGrey 
	from likes
	where tea = 'Earl Grey';</code></pre>
	
						There are several more string functions, but often these are implementation-specific. 
					</p>
					
					<p>
						Apostrophes have to be written using double quotes, so <code class="lang-sql">'Joe"s'</code> would mean Joe's.
					</p>

					<p>
						String attributes can also be <b>pattern matched</b>, using the keywords <code class="lang-sql">like</code> and <code class="lang-sql">not like</code>. A pattern is a quoted string with special characters, like a simplified form of regex. <code class="lang-sql">_</code> means any one character, <code class="lang-sql">%</code> means any number of any characters.

						<pre><code class="lang-sql">where phone like '%1926_______'</code></pre>
					</p>
				</div>
				<div>
					<p>Nulls</p>
				</div>
				<div>
					<p>
						Nulls are special in that they are <b>not real values</b>. They are useful for unknown/not applicable values.
					</p>
					<p>
						Thus, nulls are <b>incomparable</b>: if A's phone number is NULL, B's is also NULL, A's phone number <b>does not equal</b> B's. 
					</p>
					<p>
						SQL comparisons actually have <b>three boolean values</b>, those being <b>True, False, Unknown</b>. Comparing with NULL can yield unknown values. The process of three value logic is that if the value of unknown does not matter in an expression (e.g. \(F \land U = F\) and \(T \lor U = T\)). 
					</p>

					<button class="collapsible">Truth Tables...</button>
					<div class="ccontent">
						<img src="./3logictruth.png" alt="3 logic truth table">
					</div>

					<p>
						To check nulls, use <i>is</i>: <code class="lang-sql">attr is null</code> or <code class="lang-sql">attr is not null</code>.
					</p>
				</div>
			</div>

			<h3 id="sql-3">Updating</h3>

			<div class="cornell">
				<div></div>
				<div>
					<p>A modification does not return, but changes the state of the DB</p>
				</div>

				<div>
					<p>Insert</p>
				</div>
				<div>
					<pre><code class="lang-sql">insert into &lt;tableName&gt; values (&lt;val1&gt;, &lt;val2&gt;, ...);</code></pre>
					<p>
						Inserted values must be <b>in attribute order</b> of list in schema. To insert partial values, we can specify the column names:
					</p>
					<pre><code class="lang-sql">insert into &lt;tableName&gt; (A1, A2, ..., Aj) values (V1, V2, ..., Vj);</code></pre>
					<p>
						Unspecified attributes will fall to a default or null value. This is also useful if we do not know the order of attributes.
					</p>
				</div>

				<div>
					<p>Delete</p>
				</div>
				<div>
					<p>
						To delete tuples from a table matching the expression,
					</p>
					<pre><code class="lang-sql">delete from &lt;tableName&gt; where &lt;expression&gt;;</code></pre>
					<p>
						And the next one, depending on database, will delete <b>either nothing or everything</b> -- in postgres, this deletes <b style="color: red">every tuple from the table</b>.
					</p>
					<pre><code class="lang-sql">delete from &lt;tableName&gt;;</code></pre>
				</div>

				<div>
					<p>Update</p>
				</div>
				<div>
					<pre><code class="lang-sql">update &lt;tableName&gt;
set (att1=val1, att2=val2, ...)
where &lt;condition&gt;</code></pre>
				</div>
			</div>

			<h3 id="sql-4">Joins</h3>

			<div class="cornell">
				<div>
					<p>Selecting from multiple tables</p>
				</div>
				<div>
					<p>
						In a from when selecting more than one table: <code class="lang-sql">... from students, courses ...</code> by default with the comma we will get the <b>cartesian product</b>, or <b>cross join</b>.
					</p>
				</div>
				<div>
					<p>Cross join</p>
				</div>
				<div>
					<p>
						Cross join can also be explicit: <code class="lang-sql">students cross join courses</code>.
					</p>
				</div>
				<div>
					<p>Natural Join</p>
				</div>
				<div>
					<p>
						Write <code class="lang-sql">R natural join S</code>, natural join can be done by first cross joining \(R \times S\), take the attribute in R with the <b>same name</b> as that in S, merge the two columns into one and remove any where they don't match up:

						\[
						\begin{array} {|r|r|}\hline \textrm{StudentID} & \textrm{Name} \\ \hline 1 & Bob \\ \hline 2 & Alice \\ \hline 3 & Brian \\ \hline  \end{array}
						\textrm{ natural join }
						\begin{array} {|r|r|}\hline \textrm{StudentID} & \textrm{CourseID} \\ \hline 1 & 1 \\ \hline 1 & 2 \\ \hline 2 & 2  \\ \hline 3 & 1 \\ \hline 3 & 2 \\ \hline  \end{array} 					

						\]
						\[= \begin{array} {|r|r|}\hline \textrm{StudentID} & \textrm{Name} & \textrm{CourseID} \\ \hline 1 & Bob & 1 \\ \hline 1 & Bob & 2 \\ \hline 2 & Alice & 2 \\ \hline 3 & Brian & 1 \\ \hline 3 & Brian & 2 \\ \hline  \end{array}\]
					</p>
				</div>

				<div>
					<p>(Regular) Join</p>
				</div>
				<div>
					<p>
						Extension of natural join, has syntax <code class="lang-sql">R join S on &lt;cond&gt;</code> for some condition.
					</p>
					<p>
						If the operator in the cond (because you'll need one) is an =, this is an <b>equi-join</b>. The default join method is an <b>inner join</b>.
					</p>
				</div>

				<div>
					<p>Inner join</p>
				</div>
				<div>
					<p>
						An inner join between R and S is the same as 
						<pre><code class="lang-sql">select * from R, S where R.myID = S.theirID;</code></pre>
						i.e. it's like a natural join, except the two columns are <b>not merged</b>. 
					</p>
				</div>

				<div>
					<p>Theta join</p>
				</div>
				<div>
					<p>A theta join is simply <b>not an equi-join</b></p>
				</div>
				<div>
					<p>Nesting joins</p>
				</div>
				<div>
					<pre><code class="lang-sql">select *
from (
	(students S inner join studentCourses C on S.studentID = C.studentID) 
	inner join courses D on C.courseID = D.courseID 
);</code></pre>
				</div>

				<div>
					<p>Outer Joins</p>
				</div>
				<div>
					<p>
						Inner joins lose info -- an inner join between students and studentCourses will discard all students <i>without</i> courses. An outer join will <b>keep</b> one side's tuples and fill in the other side's with <code class="lang-sql">null</code>.
					</p>
					<p>
						<code class="lang-sql">left outer join</code> keeps the left side, <code class="lang-sql">right outer join</code> keeps the right side, and <code class="lang-sql">full outer join</code> keeps both.
					</p>
					<p>
						Outer joins <b>must</b> come with a <code class="lang-sql">natural</code> or <code class="lang-sql">on</code> clause.
					</p>
				</div>
			</div>

			<h3 id="sql-5">Query Nesting</h3>

			<div class="cornell">
				<div>
					<p>Subqueries</p>
				</div>
				<div>
					<p>
						Subqueries are queries within queries - you can select from the result of a select, basically. Internal queries can also be aliased for convenience.
					</p>
					<pre><code class="lang-sql">select tea
from likes, (
	select drinker from frequents where tearoom = 'Joe"s Tea Room'
) JD 
where likes.drinker = JD.drinker</code></pre>
				</div>

				<div>
					<p>Scalar Subqueries</p>
				</div>
				<div>
					<p>
						If a query produces a 1x1 table -- i.e a single value, it is <b>scalar</b>. Scalar subqueries can be used in calculations and where conditions.
					</p>
				</div>

				<div>
					<p>In</p>
				</div>
				<div>
					<p>
						The keyword <code class="lang-sql">in</code> asks if <code class="lang-sql">&lt;tuple&gt; in &lt;relation&gt;</code>. <code class="lang-sql">not in</code> is the opposite keyword. Used in where clauses.
					</p>
					<pre><code class="lang-sql">select A1, A2 from testTable where A1 in (select A2 from testTable);</code></pre>
				</div>

				<div>
					<p>Set comparisons</p>
				</div>
				<div>
					<p>
						<code class="lang-sql">in</code> is essentially \(\in\) in set algebra. What if we want something like \(x &lt; (\forall y \in Y)\)? Well we have the all, any, and some operators:
						<pre><code class="lang-sql">select ... from ... where &lt;attr&gt; &lt;operation&gt; all/any/some &lt;subquery&gt;</code></pre>
						Where the operation is a standard comparator operation. <code class="lang-sql">ALL</code> matches \(\forall\) and <code class="lang-sql">ANY, SOME</code> both match \(\exists\).
					</p>
					<pre><code class="lang-sql">SELECT ProductName FROM Products
WHERE ProductID = ANY
	(SELECT ProductID FROM OrderDetails
	WHERE Quantity = 10); </code></pre>
				</div>
			</div>

			<h3 id="sql-6">Correlated Subqueries</h3>

			<div class="cornell">
				<div></div>
				<div>
					<p>
						Subqueries which need to refer to values of the outer query - often subquery is run per tuple of main query.
					</p>
				</div>
				<div>
					<p>Exists</p>
				</div>
				<div>
					<p>
						We can <b>emptiness test</b> with <code class="lang-sql">select attr from tableName where EXISTS ( &lt;subq&gt; );</code>. Inner queries can use table aliases from outer queries, such as 
					</p>
					<pre><code class="lang-sql">select courseID, courseName from courses C
where exists (
	select * from studentCourses D where C.courseID = D.courseID
);</code></pre>
					<p>
						Inner queries which use outer query tuples are <b>correlated</b>. Nested query evaluated <b>once per row</b> of outer, and thus can use the scope of outer. 
					</p>
					<p>
						<code class="lang-sql">not exists</code> obviously exists (ironically enough).
					</p>
				</div>

				<div>
					<p>Correlated versus not</p>
				</div>
				<div>
					<p>
						If a subquery is independent from the outer one, the subquery is evaluated first. Otherwise it does the row thing.
					</p>
				</div>

				<div>
					<p>Inserting with queries</p>
				</div>
				<div>
					<p>
						Guess what, you can insert nested queries too.
					</p>
					<pre><code class="lang-sql">insert into backup (copy1, copy2)
select E.source1, E.source2 
from example E
where source1 > 2;</code></pre>
				</div>

				<div>
					<p>Set operations</p>
				</div>
				<div>
					<p>
						Relations are sets <span class="grey">(bags)</span> and of course we can do set operations, with keywords <code class="lang-sql">union, intersect, except</code> being \(\cup, \cap, \setminus\) respectively.
					</p>
					<p>
						The sets must be comparable, however, for it to work. You cant have tables with different columns.
					</p>
					<pre><code class="lang-sql">(select * from likes)
	intersect 
(select drinker, tea from sells join frequents on (tearoom))</code></pre>
				</div>

				<div>
					<p>Bags vs sets</p>
				</div>
				<div>
					<p>
						Yeah so you saw the grey "Bags" earlier? Well SQL "sets" aren't actually sets, they're "bags", or "multisets", or whatever word mathematicians make up to avoid saying <b>sets but with duplicate items</b>.
					</p>
					<p>
						<code class="lang-sql">select distinct</code> rids us of the duplicates, and the set operations will too, but say you <i>do</i> have two tables with duplicates, and <i>don't</i> want to remove them when unioning. Well that's where <code class="lang-sql">all</code> comes in: <code class="lang-sql">union all</code> will put all the columns together <b>without removing duplicates</b>.
					</p>

					<p>
						You also have <code class="lang-sql">intersect all</code> and <code class="lang-sql">except all</code>, but it starts to act a bit funny here.
					</p>

					<p>
						Say we have the code <code class="lang-sql">(select person from A) except all (select person from B)</code>, the first one has <code>joe, bob, joe, tim, fred</code> and the second has <code>fred fred tim tim joe</code>, as a result you'd get <code>joe, bob</code>. Since there's <b>two</b> Joes in the first one, and only <b>one</b> Joe <span class="grey">(Who's Joe?)</span> in the second one, \(2-1=1\) one Joe left over.
					</p>
					<p>
						It's a similar case with <code class="lang-sql">intersect all</code> where they match and discard left overs.
					</p>
				</div>
			</div>

			<h3 id="sql-7">Aggregation and Grouping</h3>

			<div class="cornell">
				<div>
					<p>Aggregation</p>
				</div>
				<div>
					<p>
						Many queries involve computing aggregates, using <code class="lang-sql">sum(), avg(), count(), min(), max(), percentile()</code>. These keywords apply to columns.
					</p>
					<p>
						<code class="lang-sql">count()</code> is special since it can take <code class="lang-sql">count(*)</code> which means count all rows, and is also extended to <code class="lang-sql">count(distinct ...)</code> which should be self explanatory.
					</p>
					<p>
						The rest of these <b>need an attribute</b>.
					</p>

					<pre><code class="lang-sql">select avg(price) from sells where tea = 'Earl Grey';</code></pre>

					<pre><code class="lang-sql">select studentID from studentCourseMarks
where courseID = 2 and mark > (
	select avg(mark) from studentCourseMarks where courseID = 2
);</code></pre>
				</div>

				<div>
					<p>Behaviour with nulls</p>
				</div>
				<div>
					<p>
						Nulls <b>never</b> contribute to a sum, average, and count, and can <b>never</b> be a max or a min.
					</p>
					<p>
						If the whole column is null, <code class="lang-sql">count()</code> is 0, and <i>then</i> <code class="lang-sql">min(), max(), sum()</code> etc become null.
					</p>
				</div>

				<div>
					<p>Group by</p>
				</div>
				<div>
					<p>
						Follows a select-from-where, results are grouped according to the values for the specified attribute, and (it must be present) aggregates are <b>applied per group</b>.
					</p>

					<pre><code class="lang-sql">select courseID, count(*) as students
from studentCourses group by courseID;</code></pre>

					<pre><code class="lang-sql">select tea, avg(price) from sells group by tea;</code></pre>
				</div>

				<div>
					<p>Limitations</p>
				</div>
				<div>
					<p>
						If an aggregate is used, <b>each</b> elem <b>must</b> be aggregated or grouped by. 
					</p>

					<pre><code class="lang-sql">-- selecting earl grey at cheapest price
select teaRoom from sells
where (tea, price) = (
	select tea, min(price) from sells 
	where tea = 'Earl Grey'
	group by tea
);</code></pre>
				</div>

				<div>
					<p>Having</p>
				</div>
				<div>
					<p>
						A having condition is a condition on the grouped by rows, all rows must pass said condition to be shown.
					</p>
					<pre><code class="lang-sql">-- selecting courses with &gt; 2 students
select sc.courseID, courseName, count(*) as students
from studentCourses sc, courses 
where sc.courseID = courses.courseID
group by sc.courseID, courseName
having count(*) > 2;</code></pre>

					<p>
						<code class="lang-sql">having</code> may refer to any tuple variable in <code class="lang-sql">from</code>, and may refer to an attribute, as long as that attribute makes sense (i.e. the attribute being grouped)
					</p>
				</div>
			</div>
		</div>

		<div class="colourband">
			<h2 id="algebra">Relational Algebra</h2>
		</div>

		<div class="cbox">
			<h3>Introduction</h3>

			<ol>
				<li><a href="#alg-1">Overview</a></li>
				<li><a href="#alg-2">Operators (Detailed)</a></li>
				<li><a href="#alg-3">Additional Operators</a></li>
			</ol>

			<p>
				SQL is based on relational algebra (RA): a formal mathematical model operating over relations, tuples, and attributes.
			</p>
			<p>
				Note that whilst SQL is declarative, RA is <b>procedural</b>, one line at a time.
			</p>
			<p>
				Since operators are formally defined, their properties are key to <b>optimising</b> execution on the back end.
			</p>

			<h3 id="alg-1">Overview</h3>

			<p>
				The operators are (the /1 and /2 are to show unary and binary operators)
			</p>
			<ul>
				<li>
					<b>Projection</b>/1: \(\pi_a(X)\) defines the attributes \(a\) of interest of X (like select from)
				</li>
				<li>
					<b>Selection</b>/1: \(\sigma_c(X)\) defines tuples of interest with w/r/t constraint \(c\) (like where)
				</li>
				<li>
					<b>Product</b>/2: \(X \times Y\) cartesian product 
				</li>
				<li>
					<b>Join</b>/2: \(X \bowtie Y\) joins on attributes or criteria (\(\bowtie_c\))
				</li>
				<li>
					<b>Set operators</b>: \(X \cup Y、X \cap Y、\overline{X} \).
				</li>
				<li>
					<b>Rename</b>/1: \(\rho(X)\) can rename the table (\(\rho_S(X)\)), rename attributes (\(\rho_{a_1 \dots a_n}(X)\)), or both (\(\rho_{S(a_1 \dots a_n)}(X)\)).
				</li>
			</ul>
			
			<div class="side">
				<p>
					<b><i>Example.</i></b> For every project in stafford, list the project number, controlling department number, department manager's last name, address, and birthdate:
				</p>
				<button class="collapsible">SQL...</button>
				<div class="ccontent">
					<pre><code class="lang-sql">select Pnumber, Dnum, Lname, Address, Bdate
from (
	(
		(
			select * from PROJECT
			where Plocation = 'Stafford'
		) join DEPARTMENT on Dnum = Dnumber
	) join EMPLOYEE on Mgr_ssn = Ssn
);</code></pre>
				</div>
				<p>
					In relational algebra, this is 
					\[\pi((\sigma(P) \bowtie D) \bowtie E)\]
					Or unabbreviated,
					\[\pi_{\textrm{P.Pnumber, P.Dnum, E.Lname, E.Address, E.Bdate}}((\sigma_{\textrm{P.Location = 'Stafford'}}(P) \bowtie_{\textrm{P.Dnum=D.Dnumber}} D) \bowtie_{\textrm{D.Mgr_ssn = E.Ssn}} E)\]
				</p>
			</div>

			<h3 id="alg-2">Operators (Detailed)</h3>

			<div class="cornell">
				<div>
					<p>Selection</p>
				</div>
				<div>
					<p>
						\[\sigma_{\textrm{condition}}(R)\]
						The condition consists of &lt;attrname&gt; &lt;comparator&gt; &lt;constant/other attr name&gt;. 
					</p>
					<p>
						This is applied independently to each tuple. 
					</p>
					<p>
						Select is commutative: \(\sigma_a(\sigma_b(R)) = \sigma_b(\sigma_a(R))\), and chaining them is just the same as using <b>logical and</b>: \(\sigma_a(\sigma_b(R) = \sigma_{a \land b}(R)\).
					</p>
				</div>
				<div>
					<p>Projection</p>
				</div>
				<div>
					<p>
						\[\pi_{\textrm{attr list}(R)\]
						Attribute list are the desired attributes (columns) of relation.
					</p>
					<p>
						If there are no keys in this list, in SQL you may get duplicates, but in RA <b>duplicates are illegal</b> since we're using set maths.
					</p>
					<p>
						If \(l_1 \supset l_2\) then \(\pi_{l_1}(\pi{l_2}(R))\) is illegal since you're projecting nonexistent columns.
					</p>
				</div>
				<div>
					<p>Renaming</p>
				</div>
				<div>
					<ul>
						<li>\(\rho_S(R)\) renames relation R to S</li>
						<li>\(\rho_{(b_1 \dots b_n)} (R)\) renames attributes of R (\(b_i\) renames attribute \(a_i\))</li>
						<li>\(\rho_{S(b_1 \dots b_n)} (R)\) does both!</li>
					</ul>
				</div>
				<div>
					<p>Expression order</p>
				</div>
				<div>
					<p>
						We've seen <b>single expressions</b>: \(\pi_{\textrm{Fname, Lname, Salary}}(\sigma_{Dno = 5}(\textrm{EMPLOYEE}))\)
					</p>
					<p>
						We can also chain expressions:
						\begin{align}
							& \textrm{DEPS_EMPS} \longleftarrow \sigma_{Dno = 5}(\textrm{EMPLOYEE}) \\
							& \textrm{RESULT} \longleftarrow \pi_{\textrm{Fname, Lname, Salary}}(\textrm{DEPS_EMPS})
						\end{align}
					</p>
				</div>
				<div>
					<p>Set operations</p>
				</div>
				<div>
					<p class="blue">
						Two relations \(R(a_1 \dots a_m)\) and \(S(b_1 \dots b_m)\) are <b>type compatible</b> if \(m = n\) and \(dom(a_i) = dom(b_i) \; \forall i \in [1..n] \).
					</p>
				</div>
				<div>
					<p>Cross join</p>
				</div>
				<div>
					<p>
						Cartesian product of sets.
					</p>
				</div>
				<div>
					<p>Join</p>
				</div>
				<div>
					<p>
						Instead of cross join and select, we can join on a condition \(R \bowtie_{\textrm{cond}} S\).
					</p>
					<p>
						An <b>equijoin</b> is a join where the condition has an =
					</p>
				</div>
				<div>
					<p>Natural Join</p>
				</div>
				<div>
					<p>
						An extension of join is natural join, represented by the star \(R \ast S\).
					</p>
				</div>
				<div>
					<p>Completeness</p>
				</div>
				<div>
					<p>
						Not all of these operators are needed to do everything, in fact the minimal complete set of operators is \(\{\sigma, \pi, \rho, \cup, -, \times\} \) (minus is set minus).
					</p>
				</div>

				<div>
					<p>Division</p>
				</div>
				<div>
					<p>
						If we have \(R \longleftarrow S \times T\), then we must have \(R \div S = T\)... right? 
					</p>
					<p>
						Yeah, but it's a bit weird. Suppose S is students, T is topics, and R is something like "researches". Then \(S \times T\) will pair each student with all topics, or each topic with all students. \(R \div S\) "extracts" those topics out that all students research.
					</p>
					<p>
						\(R \div S\) "extracts" those topics out that <b>all</b> students research. Even if we add more rows onto R to make \(R'\), then \(R' \div S\) would still <b>only</b> extract topics that <b>all</b> students research.
					</p>
					<p class="blue">
						We define this as <b>universal quantification</b>, and T is the universal quantifier of all values of S.
					</p>
					<p>
						Let \(R(Z)\) be the <b>fat relation</b> and \(S(X)\) be the <b>skinny relation</b>, such that \(X \subseteq Z\).
					</p>
					<p>
						\(R(Z) \div S(X)\) is a relation \(T(Y):\) tuple \(t \in T(Y)\) <b>iff</b> \(\forall t_S \in S \exists t_R \in R :\)
						<ul>
							<li>\(t_R[Y] = t\) (t comes from R but only contains attributes Y)</li>
							<li>\(t_R[X] = t_S\) (t must be present with all combinations of tuples from S <i>as a tuple in R</i></li>
						</ul>
					</p>
					<p>
						Alternatively, we can define \(T \longleftarrow R \div S\) as 
						\begin{align}
							T_1 &\longleftarrow \pi_Y(R) \\
							T_2 &\longleftarrow \pi_Y((S \times T_1) - R) \\
							T & \longleftarrow T_1 - T_2.
						\end{align}
					</p>
				</div>
			</div>

			<h3 id="alg-3">Additional Operators</h3>

			<div class="cornell">
				<div>
					<p>Generalised Projection</p>
				</div>
				<div>
					<p>
						\(\pi_{F_1 \dots F_n} (R)\) where \(F_1 \dots F_n\) are <b>functions</b> on R: can do maths, constants, etc. 
					</p>
				</div>
				<div>
					<p>Aggregate Functions</p>
				</div>
				<div>
					<p>
						\(_{\textrm{grouping attrs}} \mathfrak{I} _\textrm{function list} (R)\): The notation is fraktur I.
					</p>
					<p>
						Where the grouping attributes are attributes in R to <code class="lang-sql">group by</code>, and the function list is a list of (function, attribute) pairs, the functions are usually <code class="lang-sql">sum(), avg(), max(), min(), count()</code> etc.
					</p>
					<p>
						\[ _\textrm{Dno} \mathfrak{I} _\textrm{COUNT Ssn, AVERGAGE Salary} (\textrm{EMPLOYEE}) \]
					</p>
				</div>
				<div>
					<p>Outer joins</p>
				</div>
				<div>
					<p>
						Join bowties with what looks like equals coming out of one (or both) sides: left ⟕ right ⟖. (These are unavailable in base mathjax)
					</p>
				</div>
			</div>
		</div>

		<div class="colourband">
			<h2 id="calculus">Relational Calculus</h2>
		</div>

		<div class="cbox">
			<h3>Introduction</h3>

			<ol>
				<li><a href="#calc-1">Relational Calculus</a></li>
				<li><a href="#calc-2">Domain Relational Calculus</a></li>
			</ol>

			<p>
				As if one formal system wasn't enough, here's another.
			</p>
			<p class="small">yay...</p>

			<h3 id="calc-1">Relational Calculus</h3>

			<div class="cornell">
				<div>
					<p>Predicates and Propositions</p>
				</div>
				<div>
					<p>
						Relational Calculus is based on <b>predicates</b> and <b>propositions</b>.
					</p>
					<p>
						A <b>predicate</b> is a declarative sentence: a statement. Predicates must be <b>verifiably</b> true or false. They specifiy retrieval requests, but only what to retrieve, not how.
					</p>
					<p>
						True or false statements depend on presence within the database. 
					</p>
				</div>
				<div>
					<p>Variables in Predicates</p>
				</div>
				<div>
					<p>
						We can have a predicate with variables: "Person \(p\) plays intrument \(i\).", and these variables can be replaced: "Person <i>Megan</i> plays intrument \(i\)."
					</p>

					<p class="blue">
						A predicate is <b>instantiated</b> when all parameters are filled, this becomes a <b>proposition</b>
					</p>
					<p>
						"Person <i>Megan</i> plays instrument <i>cello</i>." is now a <b>proposition</b>.
					</p>
				</div>
				<div>
					<p>Intension and Extension</p>
				</div>
				<div>
					<p class="blue">
						The <b>intension</b> of a predicate is the predicate's "meaning": the properties and quantities associated with a statement. 
					</p>
					<p class="blue">
						The <b>extension</b> of a predicate is the set of all instantiations where the predicate is <b>true</b>.
					</p>
				</div>
				<div>
					<p>Operations</p>
				</div>
				<div>
					<p>
						Propositions can be composed with others with logical and first order operators \(\land, \lor, \lnot, \forall, \exists\).
					</p>
				</div>
				<div>
					<p>Sets</p>
				</div>
				<div>
					<p class="blue">
						Let \(P(x)\) be a predicate. If \(a\) is an instance of \(x\), and \(P(a) = \top\), \(a\) <b>satisfies</b> \(P\). <br><br>
						\(P(x)\) is the <b>membership predicate</b> for the set of all satisfactory objects \(a\).
					</p>
					<p>
						Suppose \(P(y) = y \in \mathbb{Z} \land 5 &lt; y &lt; 10\). The Set related is \(\{6,7,8,9\} \).
					</p>
					<p>
						These sets can also be composed with set operators.
					</p>
				</div>
				
				<div>
					<p>Relational Calculus -> Relational Model</p>
				</div>
				<div>
					<p>
						A predicate can be thought of as a <b>schema</b>. The predicate defines what's true, whilst the schema defines attributes and domains for valid data.
					</p>
					<p>
						A proposition can be thought of as a <b>tuple</b>. Propositions are set values substituted into parameters of a predicate; if they are satisfactory, they are valid in the schema.
					</p>
					<p>
						The extension is the set of all valid states of the schema (the set of all predicate instantiations)
					</p>
					<p>
						We work with a <b>closed world assumption</b>: a tuple is true <b>if and only if</b> it is in the database. 
					</p>
				</div>

				<div>
					<p>Queries</p>
				</div>
				<div>
					<p>
						RC can be used to express queries <b>declaratively</b>, and there are two types:
					</p>
					<p>
						<b>Tuple Relational Calculus (TRC)</b> and <b>Domain Relational Calculus (DRC)</b>.
					</p>
				</div>
			</div>

			<h3 id="calc-11">Tuple Relational Calculus</h3>

			<div class="cornell">
				<div>
					<p>TRC</p>
				</div>
				<div>
					<p>
						Statements in RC are declarative.
					</p>
					<p>
						To define queries, we need to define 3 more things:
					</p>
					<ul>
						<li>The <b>range relation</b>, over which all tuples operate</li>
						<li>The <b>condition</b> used to select tuples (aka formulas)</li>
						<li>The desired <b>attributes</b> to be retrieved</li>
					</ul>
				</div>
				<div>
					<p>DB Queries</p>
				</div>
				<div>
					<p>
						A standard TRC query looks like
						\[\{t_1\cdot A_1, t_2 \cdot A_2, \dots, t_n \cdot A_n | \textrm{cond}(t_1 \dots t_n)\}\]
						Where cond is a true/false formula, \(t_1 \dots t_n\) are free variables.
					</p>
					<p>
						The tuple variables range over all possible tuples, so must specify explicitly which relation they come from. 
					</p>
					<p>
						An <b>atomic formula</b> is of form 
						<ul>
							<li>\(R(t_i)\) where R is a relation and \(t_i\) is a tuple variable.</li>
							<li>\(t_i \cdot A \circ t_j \cdot B\) where \(\circ\) is \(=, &lt;, \leq, \geq, &gt;, \neq\)</li>
							<li>\(t_i \cdot A \circ c\) (or inverse) where \(c\) is a constant</li>
						</ul>
					</p>
					<p>
						<b>Compound Formulas</b> are of form 
						\begin{matrix}
							&\lnot F, &F_1 \lor F_2, &F_1 \land F_2, &(\forall t)F, &(\exists t)F
						\end{matrix}
					</p>
				</div>
				<div>
					<p>Examples</p>
				</div>
				<div>
					<p>Because the formal definition is kinda confusing.</p>
					<button class="collapsible active">Employees...</button>
					<div class="ccontent" style="display: block;">
						<p>
							<b><i>Example.</i></b> Names of employees who earn more than $50k annually.
							\[\{t.Fname, t.Lname | EMPLOYEE(t) \land t.salary > 50000\} \]
						</p>
					</div>
					<button class="collapsible">Employees (II)...</button>
					<div class="ccontent">
						<p>
							<b><i>Example.</i></b> Now we want the employees' full names and their supervisors.
							\[\{t.Fname, t.Lname, s.Fname, s.Lname | EMPLOYEE(t) \land EMPLOYEE(s) \land t.Superssn = s.Ssn\} \]
						</p>
					</div>
				</div>
				<div>
					<p>Quantification binds variables</p>
				</div>
				<div>
					<p>
						We can bind variables with first order logic quantifiers:

						\[(\forall t)((\exists u)(PROJECT(v) \lor EMPLOYEE(t) \lor v.Ssn = u.Ssn))\]
					</p>

					<button class="collapsible">Example... </button>
					<div class="ccontent">
						<p>
							<b><i>Example.</i></b> List names and addresses of all employees who work for research.

							\begin{align}
								\{t.Fname, &t.Lname, t.Address | \\
								&EMPLOYEE(t) \land \\
								 &(\exists d)(DEPARTMENT(d) \land d.Dname = 「Research」 \land d.Dnumber = t.Dno) \\
							\}
							\end{align}
						</p>
					</div>
				</div>
				<div>
					<p>Universal Quantification</p>
				</div>
				<div>
					<p>
						Note that implies doesn't exist, so \(a \implies b\) must become \(\lnot a \lor b\).
					</p>

					<button class="collapsible active">Example... </button>
					<div class="ccontent" style="display: block;">
						<p>
							<b><i>Example.</i></b> We want names of all employees who work on a project controlled by department 5.
						</p>
						<p>
							Start with \(\{e.Fname, e.Lname | EMPLOYEE(e) \land F(e)\} \) for some F. 
						</p>
						<p>
							Where F \(\implies\) "\(e\) works on all projects controlled by dept 5" <br>
							\(\implies\) "all projects in dept 5, and involves \(e\)" <br>
							\(\implies (\forall p)(PROJECT(p) \implies \dots)\), whcih we can't do since imply doesn't exist <br>
							\(\therefore (\forall p)(\lnot PROJECT(p) \lor (\lnot (p.Dnum = 5) \lor \dots))\) 
						</p>
						<p>
							The second round of dots wants "e works on p",
							\[(\exists w)(WORKS\_ON(w) \land w.Essn = e.Ssn \land w.Pno = p.Pnumber)\]
							Thus finally getting
						</p>
						<div class="codediv">{\(e.Lname, e.Fname | EMPLOYEE(e) \land\)(
	\((\forall p) (\lnot PROJECT(p) \lor \lnot (p.Pnum = 5) \lor\)(
		\((\exists w) (WORKS\_ON(w) \land w.Essn = e.Ssn \land w.Pno = p.Pnumber)\)
	)
)}</div>
					</div>
				</div>

				<div>
					<p>Safety first</p>
				</div>
				<div>
					<p class="blue">
						An RC expression is <b>safe</b> if it is guaranteed to return a <b>finite</b> number of tuples.
					</p>
					<p>
						Achieved when everything is explicitly mentioned. An unsafe expression would be like \(\{t | \lnot EMPLOYEE(t) \} \). Safe expressions are reducible to RA.
					</p>
				</div>
			</div>

			<h3 id="calc-2">Domain Relational Calculus</h3>

			<div class="cornell">
				<div>
					<p>Introduction</p>
				</div>
				<div>
					<p>
						Whereas in TRC vars range over tuples, in DRC <del>we have political instability</del> vars range over attribute domains. Again it's similar notation, like
						\[\{x_1 \dots x_n | \textrm{cond}(x_1 \dots x_n)\}\]
					</p>
				</div>
				<div>
					<p>Attributes</p>
				</div>
				<div>
					<p>
						<b>Atomic formulas</b> are like 
						<ul>
							<li>\(R(x_1, x_2 \dots x_k)\) is a relation over \(k\) attributes </li>
							<li>\(x_i \circ x_j\) where \(\circ\) is an operator</li>
							<li>\(x_i \circ c\) or vice-versa</li>
						</ul>
						
					</p>
				</div>
				<div>
					<p>Examples</p>
				</div>
				<div>
					<p></p>
					<button class="collapsible active">Example... </button>
					<div class="ccontent" style="display: block;">
						<p>
							<b><i>Example.</i></b> List birthdate and address of employee whose name is John Smith.
							\begin{align}
								\{u, v &| (\exists q)(\exists r)(\exists t)(\exists w)(\exists x)(\exists y)(\exists z)( \\
									&EMPLOYEE(qrstuvwxyz) \land q = 「John」 \land r = 「B」 \land s = 「smith」 \\
								)\}
							\end{align}
						</p>
					</div>
					<p>
						Now look at those ugly unnecessary quantifiers. For ease we say they're <b>implicitly mentioned</b>
					</p>
				</div>

				<div>
					<p>Codel's Theorem</p>
				</div>
				<div>
					<p class="side">
						<b><i>Theorem.</i></b> Relational algebra and relational calculus are equally expressive languages.
						<br><br>
						Languages that are equal in expressive power to relational algebra are <b>relationally complete</b>.
					</p>
				</div>
			</div>
		</div>

		<div class="colourbox">
			<h2 id="design">Database Design, Normalisation and Security</h2>
		</div>

		<footer>
			<div class="cbox">
                <div class="columncontainer ctwo" id="fc2">
                </div>
                <script type="text/javascript" src="../../js/footerGen.js"></script>
            </div>
		</footer>

	</div>

	<script type="text/javascript" src="../../js/collapsible.js"></script>  <!--This stays at the end-->
	<script type="text/javascript" src="../../js/toggle-darklight.js"></script>
	<script type="text/javascript" src="../../js/prism.js"></script>
</body>
</html>