<!DOCTYPE html>
<html>
<head>
	<title>CS412</title>
	<meta charset="utf-8">
	<link rel="stylesheet" type="text/css" href="../../style/style.css" media="all">  <!--TODO: CHANGE HREF-->
	<link rel="stylesheet" type="text/css" href="../../style/prism.css" media="all">
	<meta name="viewport" content="width=device-width" initial-scale=1.0>  <!--TODO: CHANGE LINKS ON BOTTOM OF SHEET FOR COLLAPSIBLE-->
	<link rel="icon" type="image/png" href="../../style/images/DragonIcon.png">

	<script async type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
	<script defer type="text/javascript" src="../../js/toggle-darklight.js"></script>
	<script defer type="text/javascript" src="../../js/collapsible.js"></script>  <!--This stays at the end-->
	<script defer type="text/javascript" src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
	<script defer type="text/javascript" src="../../js/arrange.js"></script>
	<script defer type="text/javascript" src="../../js/prism.js"></script>
</head>
<body>

	<div class="hidden">
		<header>
			<div class="parallax parsmaller">
				<div  style="display: grid; grid-template-columns: 1fr 1fr 1fr 8fr 1fr; grid-column-gap: 10px; padding: 5px; ">
					<div class="column tinycolumn">
						<a href="../../" class="nav">Home</a>
					</div>
					<div class="column tinycolumn">
						<a href="../../blog.html" class="nav">Blog</a>
					</div>
					<div class="column tinycolumn">
						
						<a href="../../about.html" class="nav">About</a>
					</div>
					<div></div>
					<div class="column">
						<button class="nav dark-light">Dark Mode</button>
					</div>
				</div>
				<div class="cbox"> 		
					<h1>CS412</h1>
					<p class="subheading">Formal Systems</p>
				</div>
			</div>
		</header>

		<header>
			<div class="cbox">
				<h1>Contents</h1>
			</div>
		</header>

		<style>
			r-r {
				float: right;
			}
		</style>


		<div class="cbox">
<div class="blue md-conv" style="text-align: center;">
**IMPORTANT NOTES**

This is not an exhaustive list of B syntax. This also does not explain Atelier B's syntax quirks in any thorough manner.

[Atelier] B mandates that no identifiers be one letter long, i.e. you can't have $x$, $y$, etc. and it has to be $xx$, $yy$, etc. But this is stupid in display maths and generally affects readability -- actually name your variables. Thus, for single letter variables:

**Variables may not have double letters.**

Fill them in yourself in your head, or use actual variable names in code.
</div>

<div class="md-conv">
### Contents

1. [Référence du système B](#reference)
2. [Verification](#proof)
3. [Machine Structuring](#structure)
4. [Refinement](#refinement)
</div>
		</div>

		
		<div class="colourband">
			<h2 id="reference">
				<img src="https://upload.wikimedia.org/wikipedia/commons/7/7a/Animated-Flag-First-French-Republic.gif" alt="" style="display: inline; max-height: 1em;"> 
				Référence du système B
				<img src="https://upload.wikimedia.org/wikipedia/commons/7/7a/Animated-Flag-First-French-Republic.gif" alt="" style="display: inline; max-height: 1em;"> 
			</h2>
		</div>
		
		<div class="cbox">
			<div class="md-conv">
## Contents 

1. [Layout](#ref-layout)
2. [Structures](#ref-structures)
3. [Notation](#ref-notation)
			</div>

			<div class="md-conv" id="ref-layout">
### Layout 

The general layout of B:

### Layout 

The general layout of B:

```haskell
MACHINE
	MachineName(params)  // machine name and params 

CONSTRAINTS
	params : NAT  //constraints of parameters

SETS
	ONES; TWOS;  // deferred sets 
	RESP = {yes, no}  // enumerated sets

CONSTANTS
	const  // declar names

PROPERTIES
	const : NAT1  // define properties about sets and constants 

VARIABLES
	vara, varb  // declare names

INVARIANT  // states constants about the machine that must always be true
			// includes types (what variable element of which)
	vara : NAT1 & varb : NAT &
	P & Q

INITIALISATION  // gives initial values to variables (must obey invariant)
	vara := 1 || varb := 0

OPERATIONS // defines the machine operations (the important bit)

	addOne = PRE // preconditions
		varb &lt; MAXINT
	THEN
		varb := varb + 1
	END;

	out &lt;-- read = out := varb  // note this one-liner without 
								preconditions doesn't need an END
END
```
</div>

<hr>

<div class="md-conv" id="ref-structures">
## Structures

Important structures to know. 
\\(
	\newcommand{\b}{\textbf}	
	\newcommand{\B}{\textbf}	
	\newcommand{\r}{\textrm}	
	\newcommand{\bb}{\mathbb}	
	\newcommand{\N}{\mathbb{N}}	
	\newcommand{\No}{\mathbb{N}_1}	
	\DeclareMathOperator*{\card}{card}
	\DeclareMathOperator*{\dom}{dom}
	\DeclareMathOperator*{\ran}{ran}
	\DeclareMathOperator*{\pow}{\mathbb{P}}
	\DeclareMathOperator*{\llra}{\longleftrightarrow}
	\DeclareMathOperator*{\skip}{skip}
	\DeclareMathOperator*{\seq}{seq}
	\DeclareMathOperator*{\seqo}{seq_1}
	\DeclareMathOperator*{\iseq}{iseq}
	\DeclareMathOperator*{\perm}{perm}
	\DeclareMathOperator*{\size}{size}
	\DeclareMathOperator*{\rev}{rev}
	\DeclareMathOperator*{\first}{first}
	\DeclareMathOperator*{\last}{last}
	\DeclareMathOperator*{\tail}{tail}
	\DeclareMathOperator*{\front}{front}
	\DeclareMathOperator*{\struct}{struct}
	\DeclareMathOperator*{\rec}{rec}
	\DeclareMathOperator*{\true}{true}
	\DeclareMathOperator*{\false}{false}
	\newcommand{\lessplus}{&lt;\kern-6pt +\;}
	\newcommand{\pfunc}{\kern3pt +\kern-12pt \longrightarrow}
	\newcommand{\pinj}{\kern3pt +\kern-12pt \rightarrowtail}
	\newcommand{\inj}{\rightarrowtail}
	\newcommand{\surj}{\twoheadrightarrow}
	\newcommand{\bij}{\kern3pt \rightarrowtail\kern-8pt \twoheadrightarrow}
\\)

\\(
	\DeclareMathOperator*{\bmachine}{\b{MACHINE}}
	\DeclareMathOperator*{\brefinement}{\b{REFINEMENT}}
	\DeclareMathOperator*{\bimplementation}{\b{IMPLEMENTATION}}
	\DeclareMathOperator*{\bimports}{\b{IMPORTS}}
	\DeclareMathOperator*{\brefines}{\b{REFINES}}
	\DeclareMathOperator*{\bincludes}{\b{INCLUDES}}
	\DeclareMathOperator*{\bsees}{\b{SEES}}
	\DeclareMathOperator*{\buses}{\b{USES}}
	\DeclareMathOperator*{\bpromotes}{\b{PROMOTES}}
	\DeclareMathOperator*{\bconstraints}{\b{CONSTRAINTS}}
	\DeclareMathOperator*{\bsets}{\b{SETS}}
	\DeclareMathOperator*{\bconstants}{\b{CONSTANTS}}
	\DeclareMathOperator*{\bproperties}{\b{PROPERTIES}}
	\DeclareMathOperator*{\bvariables}{\b{VARIABLES}}
	\DeclareMathOperator*{\bvalues}{\b{VALUES}}
	\DeclareMathOperator*{\bvariant}{\b{VARIANT}}
	\DeclareMathOperator*{\binvariant}{\b{INVARIANT}}
	\DeclareMathOperator*{\binitialisation}{\b{INITIALISATION}}
	\DeclareMathOperator*{\boperations}{\b{OPERATIONS}}
	\DeclareMathOperator*{\bbegin}{\b{BEGIN}}
	\DeclareMathOperator*{\bend}{\b{END}}
	\DeclareMathOperator*{\bpre}{\b{PRE}}
	\DeclareMathOperator*{\bif}{\b{IF}}
	\DeclareMathOperator*{\bcase}{\b{CASE}}
	\DeclareMathOperator*{\bany}{\b{ANY}}
	\DeclareMathOperator*{\blet}{\b{LET}}
	\DeclareMathOperator*{\bchoice}{\b{CHOICE}}
	\DeclareMathOperator*{\bselect}{\b{SELECT}}
	\DeclareMathOperator*{\bthen}{\b{THEN}}
	\DeclareMathOperator*{\belse}{\b{ELSE}}
	\DeclareMathOperator*{\beither}{\b{EITHER}}
	\DeclareMathOperator*{\bwhere}{\b{WHERE}}
	\DeclareMathOperator*{\bwhen}{\b{WHEN}}
	\DeclareMathOperator*{\bwhile}{\b{WHILE}}
	\DeclareMathOperator*{\bor}{\b{OR}}
	\DeclareMathOperator*{\bof}{\b{OF}}
	\DeclareMathOperator*{\bbe}{\b{BE}}
	\DeclareMathOperator*{\bin}{\b{IN}}
	\DeclareMathOperator*{\bdo}{\b{DO}}
	\DeclareMathOperator*{\bvar}{\b{VAR}}
\\)

***Preconditons.*** Usually around most operations with parameters. Parameters passed must match preconditions, else behaviour is undefined (this is useful when we deabstract everything). Written as

$$\bpre P \bthen B \bend$$ 

Where $P$ is the predicate condition and $B$ is the operation.

Operations are stateless and instantaneous (no doing one thing after another).

***Conditionals.*** If statements.

$$\bif E \bthen S \b{ ELSE } T \bend$$ 

The else block is optional.

***Conditionals.*** Switch cases. 

\begin{align}
	\bcase E \bof \;&\beither e_1 \bthen T_1 \\\\
	&\bor e_2 \bthen T_2 \\\\
	&\bor \dots \\\\
	&\b{ELSE } V \\\\
	&\bend
\end{align}

Often seen over finite sets. Works as you'd expect a switch statement to work.

***Block.*** A begin-end block. Used only for increasing readability.

$$ \bbegin S \bend $$

***Machine parameters.*** Values which can be passed in when a machine is instantiated. Write next to the machine in *brackets* like how you'd write a function signature.

$$ \bmachine Store(ITEM, capacity) $$

*Upper-case* parameters are treated as deferred sets, whilst *lower-case* parameters are treated as constants. Constants must have their type specified in the $\bconstraints$ clause, whilst sets can be left as-is.

$$\bconstraints capacity \in \No \land capacity \leq 4096$$

One should ensure that the constraints can actually be met.

***Let.*** Allows a variable to stand in place of a value in a block statement.

$$\blet x \bbe x = E \bin S \bend$$ 

This is the deterministic version of the $\bany$ structure that is below.


#### Nondeterministic structures

***Any.***  Allows an arbitrary choice of variable value in a statement.

$$ \bany x \bwhere Q \bthen T \bend $$ 

For example: $\bany n \bwhere n \in \No \bthen total := total \times n \bend$. This can be done over multiple variables:

\begin{align}
	&\bany dx, dy \bwhere dx \in \No \land dy \in \No \land dy \gt dx \\\\
	&\bthen x := x + dx || y := y + dy \\\\
	&\bend
\end{align}

***Choice.*** Choose any one of multiple outcomes to execute.

$$ \bchoice S \bor T \bor \dots \bor U \bend $$

This can be used to describe *allowable outcomes*. Each branch in a choice statement can also be non-deterministic, thus you can nest $\bany$s in $\bchoice$s.

***Select.*** The non-deterministic version of the switch statement. The conditions in a select can overlap, leading to multiple possible outputs.

\begin{align}
	&\bselect Q_1 \bthen T_1 \\\\
	&\bwhen Q_2 \bthen T_2 \\\\
	&\cdots \\\\
	&\bwhen Q_n \bthen T_n \\\\
	&\belse V \bend 
\end{align}

Where the $Q$s are predicates, the $T$s are statements, and the else clause is optional.

#### Refinement Structures

***Local variables.*** Introducing local variables to be used in a block.

$$ \bvar v \bin S \bend $$

An example of this is a swap operation:

$$ swap(x,y) = \bvar t \bin t := x; x := y; y := t \bend $$

***Loops.*** For more information see [Refinement>Loops](#r-4).

$$ \bwhile C \bdo L \binvariant LI \bvariant LV \bend $$

Where $C$ is the condition, $L$ is the actual loop operation, $LI$ is the loop invariant, $LV$ is the loop variant that strictly decreases.


</div>

<hr>

<div class="md-conv" id="ref-notation">
## Notation 

Display maths notation and code notation are both shown. If one is missing that means I forgot and cannot yet be bothered to look it up. 

Some B notation is difficult to display in mathjax -- I will be using the closest possible variants.

My code font also has ligatures, bear that in mind.

#### General B notation:

* assignment: $x := y$ <r-r>`x := y`</r-r>
* parallel operation: $x := y || y := z$ -- does NOT assign z to x since it is done in parallel. <r-r>`x := y || y := z`</r-r>
* parallel assign: $x, y := y, z$ <r-r>`x,y := y,z`</r-r>
* no operation: $\skip$ <r-r>`skip`</r-r>
* operation return: $o \longleftarrow operation = \cdots$ <r-r>`oo &lt;-- operation = ...`</r-r>

#### Set Notation

* empty set: $\{\}$ or $\varnothing$  <r-r>`{}`</r-r>
* member: $e \in S$  <r-r>`e : S`</r-r>
* not member: $e \not\in S$  <r-r>`e /: S`</r-r>
* subset: $S \subseteq T$ ; <r-r>`S &lt;: T`</r-r>
* union: $S \cup T$ <r-r>`S \/ T`</r-r>
* intersection: $S \cap T$ <r-r>`S /\ T`</r-r>
* subtraction: $S - T$ <r-r>`S - T`</r-r>
* big union: $\bigcup S$
* big intersect: $\bigcap S$
* powerset: $\pow S$ <r-r>`POW(S)`</r-r>
* cartesian product: $S \times T$ <r-r>`S * T`</r-r> 
* cardinality (size): $\card(s)$ <r-r>`card(S)`</r-r>
* naturals with 0: $\N$ <r-r>`NAT`</r-r>
* naturals without 0: $\No$ <r-r>`NAT1`</r-r>
* set comprehension: $\{ x | x \in T \land P\}$ <r-r>`{x|x : T & P}`</r-r>
* range between $m$ and $n$ inclusive: $m..n$ <r-r>`m..n`</r-r>

#### Logic Notation 

* and, or, not: $\land, \lor, \lnot$ <r-r>`&`,  `or`,  `not`</r-r>
* implies, equivalence: $\implies, \iff$ <r-r>`=>`, `&lt;=>`</r-r>
* universal (forall): $\forall x \cdot x \in T \implies P$ <r-r>`!(x).(x : T => P)`</r-r>
* existential (there exists): $\exists x \cdot x \in T \land P$ <r-r>`#(x).(x : T & P)`</r-r>

Remember to pay attention to which variables are *bound* in first order logic.

#### Arithmetic Notation 

* equals, less than, greater than: <r-r>`=`, `&lt;`, `&gt;`</r-r>
* less than equals, greater than equals: <r-r>`&lt;=`, `>=`</r-r>
* not equals: $\neq$ <r-r>`/=`</r-r>
* add, subtract, multiply, divide: <r-r>`+`, `-`, `*`, `/`</r-r>
* summation: $\sum x \cdot (x \in T | f(x))$ where $f(x)$ is the expression to sum. <r-r>`SIGMA (x) . (x:T | f(x))`</r-r>

#### Relation Notation

Relations between two sets describes mappings of elements from one set to another. Note that a relation $X \llra Y$ can be described as a set of pairs $(x,y) : x \in X \land y \in Y$.

* set (type) of all relations between X and Y: $X \llra Y$ <r-r>`X &lt;-&gt; Y`</r-r>
* element $x$ maps to $y$: $x \mapsto y$ <r-r>`x |-&gt; y`</r-r>
* domain of relation: $\dom(R)$ <r-r>`dom(R)`</r-r>
* range of relation: $\ran(R)$ <r-r>`ran(R)`</r-r>
* domain restriction: $U \triangleleft R$, all mappings $x \mapsto y$ in R where $x \in U$. <r-r>`U &lt;&lt;| R`</r-r>
* domain subtraction: $U \blacktriangleleft R$, all mappings $x \mapsto y$ in R where $x \not\in U$. <r-r>`U &lt;&lt;| R`</r-r>
* range restriction: $R \triangleright U$, all $x \mapsto y$ in R where $y \in U$. <r-r>`R |> U`</r-r>
* range subtraction: $R \blacktriangleright U$, all $x \mapsto y$ \in R where $y \not\in U$. <r-r>`R |>> U`</r-r>
* relational image: $R[U]$, all $y$ where $x \mapsto y \in R$ and $x \in U$. <r-r>`R[U]`</r-r>
* relational inverse: $R^{-1}$, the set $\{y \mapsto x | x \mapsto y \in R\}$. <r-r>`R'`</r-r>
* relation composition: $R;S$, given $R \in X \llra Y \land S \in Y \llra Z$, produces the relation $R;S \in X \llra Z$ where $x\mapsto z \in (R;S) \implies x \mapsto y \in R \land y \mapsto z \in S$. <r-r>`R ; S`</r-r>
* identity relation: $id(S)$, the relation of every element in S to itself.
* repeated composition: $R^n$ relation R composed to itself $n$ times.
* relation overriding: $R \lessplus S$, where R and S relate the same sets, substitutes all mappings $x \mapsto y \in R$ for corresponding $x \mapsto y' \in S$, if $x$ is present in both domains. <r-r>`R &lt;+ S`</r-r>


For the four triangle operations, pay special care as to what order it's in.

#### Function Notation

Functions are just relations where each input maps to only one output, that is for $f \in S \llra T$ to be a function, $x \mapsto y \in f \implies \forall y' \cdot (y' \in S \land y' \neq y \implies x \mapsto y' \not\in f)$.

The following are the notations for different types of functions -- they should be read as "the set of all X"

* partial functions: $S \pfunc T$, which maps some elems of S to some elems of T. <r-r>`S +-&gt; T`</r-r>
* total functions: $S \longrightarrow T$, which maps *all* elems of S to some elems of T. <r-r>`S --&gt; T`</r-r>
* partial injections: $S \pinj T$, partial functions which are injective (one-to-one) <r-r>`S >+> T`</r-r>
* total injections: $S \inj T$, injective total functions. <r-r>`S >-> T`</r-r>
* surjective functions: $S \surj T$, where all range elements are mapped "onto". <r-r>`S --&gt;> T`</r-r>
* bijective functions: $S \bij T$ which are both injective and surjective. <r-r>`S >->> T`</r-r>
* get function value: $f(x)$, which gets what $x$ maps to. <r-r>`f(x)`</r-r>
* replace function value: $f(x) := y'$ replaces $x \mapsto y$ with $x \mapsto y'$. <r-r>`f(x) := yy`</r-r>
* lambda function notation: $\lambda x \cdot (x \in S | f(x))$ where $f(x)$ is an expression over $x$. <r-r>`%x.(x : S | f(x))` </r-r>

For replacement of multiple mappings, i.e. relation overriding with more than one element, we must use the $\lessplus$ syntax.

**Arrays** are nothing but functions from a numerical range $1..n \longrightarrow S$ to some set of elements.


#### Sequence Notation 

Sequences, or lists, are written as functions $1..n \longrightarrow T$, relating a (1-)index to an element. They are syntax-sugared into conventional list format.

* empty sequence: $[]$ <r-r>`[]`</r-r>
* sequence of elements: $[e_1, \dots, e_n]$ <r-r>`[e1, ..., en]`</r-r>
* set of finite sequences: $\seq(S)$ <r-r>`seq(S)`</r-r>
* set of finite non-empty sequences: $\seqo(S)$ <r-r>`seq1(S)`</r-r>
* set of injective sequences (no repeats): $\iseq(S)$ <r-r>`iseq(S)`</r-r>
* set of permutations of the set: $\perm(S)$ <r-r>`perm(S)`</r-r>
* list concatenation: $s_1 \smallfrown s_2$ <r-r>`s1 ^ s2`</r-r>
* prepend element $e$: $e \rightarrow s$ <r-r>`e -> s`</r-r>
* append element $e$: $s \leftarrow e$ <r-r>`s &lt;- e`</r-r>
* length: $\size(s)$ <r-r>`size(s)`</r-r>
* reverse: $\rev(s)$ <r-r>`rev(s)`</r-r>
* take first $n$ elems: $s \uparrow n$ <r-r>`s /|\ n`</r-r>
* drop the first $n$ elems: $s \downarrow n$ <r-r>`s \|/ n`</r-r>
* get the first element of non-empty sequence: $\first(s)$ <r-r>`first(s)`</r-r>
* get last element: $\last(s)$ <r-r>`last(s)`</r-r>
* get all but the first element: $\tail(s)$ <r-r>`tail(s)`</r-r>
* get all but the last element: $\front(s)$ <r-r>`front(s)`</r-r>

#### Nondeterminism

* assign any element from set: $x :\in S$ <r-r>`x :: S`</r-r>

#### Record Types 

Records store named fields. The type of a record structure is written as 
$$ person \in \struct(p\\_name \in NAME, p\\_age \in \No) $$

And an initialisation can go as
$$ person := \rec(p\\_name : Bob, p\\_age : 21) $$

Retrieval: $person'p\\_name$

</div>
</div>

<div class="colourband">
<h2 id="proof">Verification</h2>
</div>

<div class="cbox">
<div class="md-conv">
## Introduction

Verification is an essential part of formal systems -- ensuring that the code we write is correct and mathematically sound. This is how we eventually generate safe systems.

During verification *bound variables* in first order logic must be dealt with very carefully, for example in
$$ x+y \gt 10 \land \forall x \cdot (x \in X \implies P(x)) $$ 
the first $x$ is not bound, but in the second expression $x$ is a *different* bound variable. In 
$$ \forall x \cdot (x \in X \implies P(x)) \land \forall x \cdot (x \in X \implies Q(X)) $$ 
the two $x$ variable are bound to different scopes and are *unrelated*. Especially, avoid cases such as 
$$ \forall x \cdot (x \in \N \implies \exists x \cdot (x \in \N \land x > x)) $$ 
... just don't do the last one. Rename your variables properly.

**Substitution** is the process of replacing an *unbound* variable in an expression with another expression, it is denoted (original)[var/new]:

$$ (x + y \gt 10)[3 / x] == 3 + y \gt 10 $$

Read this $[3/x]$ as "three replaces x".

### Contents

1. [The Weakest Precondition](#v-wp)
2. [Machine Consistency](#v-consistent)

<hr>

</div>

<div class="md-conv" id="v-wp">
## The Weakest Precondition

The *weakest precondition* of a statement is essentially the least restricted state space for which an operation produces a desired output -- the postcondition.
$
\newcommand{\lh}{\\;\\{}
\newcommand{\rh}{\\}\\;}
$

Just like in CS261 we can denote a precondition-operation-postcondition triple in *hoare triples*, that is for program $Q$ with precondition $P$ and postcondition $R$, write 
$$ \lh P \rh Q \lh R \rh $$

We are interested in the *weakest precondition* $P$, given a $Q, R$. This is written (perhaps confusingly) as
$$ [Q]R $$

#### Laws of Logic

The following hold for complex postconditions:

* $[S] (P \land Q) \iff [S]P \land [S]Q$ ;
* $[S]P \lor [S]Q \implies [S] (P \lor Q) $ but not the other way round;
* If $P \implies Q$ then $[S]P \implies [S]Q$. 
* $[S]\true$ is trivially true for any S which terminates.

#### Derivation Rules

***Assignment Rule***. The weakest precondition for an assignment is 
$$ [x := E]R == R[E/x] $$
Replace all occurrences of $x$ in $R$ with $E$.

***Multiple Assignment Rule***. The WP for multi-assignment is
$$ [x_1..x_n := E_1 .. E_n]R == R[E_1..E_n / x_1 .. x_n] $$ 

***Skip Rule***. over a skip operation:
$$ [skip]R == R $$

***Block Rule***. over a begin-end block:
$$ [\bbegin P \bend] R == [P]R$$ 

***Conditional Rule***. Over an if statement:
$$[\bif G \bthen P_1 \belse P_2 \bend] R$$ 

\begin{align}
&== (G \implies [P_1]R) \land (\lnot G \implies [P_2]R) \\\\
&== (G \land [P_1]R) \lor (\lnot G \land [P_2]R)
\end{align}

Also 
$$[\bif G \bthen P_1 \bend] R == (G \land [P_1]R) \lor (\lnot G \land R)$$ 

***Conditional Rule (II)***. Over a case statement:
$$[\bcase v \bof \beither v_1 \bthen p_1 \bor v_2 \bthen p_2 \cdots \belse p \bend] R $$

$$ == (v=v_1 \land [p_1]R) \lor (v=v_2 \land [p_2]R) \lor \cdots \lor (v \neq v_{1..n} \land p[R]) $$ 

***Precondition.*** 

$$ [ \bpre C \bthen P \bend ] R == C \land [ P ] R $$ 

***One-point rule.*** If we have one of the following forms:
$$
\begin{matrix}
\forall x \cdot (x = v \implies P) \\\\
\exists x \cdot (x = v \implies P) 
\end{matrix}
$$
Always replace by $P[v/x]$.

***Nondeterministic assignment.*** 
$$ [x :\in E] R == \forall s \cdot (s \in E \implies R[s/x]) $$

***Any block.*** 
$$ 
[\bany x \bwhere Q \bthen P \bend] R 
$$
$$ == \forall x \cdot (x \in E \implies [P]R ) $$

***Choice block.*** 
$$ [\bchoice P_1 \bor \dots \bor P_n \bend ] R$$ 
$$ == [P_1]R \land \cdots \land [P_n]R $$

***Select block.***
$$ [\bselect c_1 \bthen p_1 \bwhen c_2 \bthen p_2 \dots \belse p \bend] R $$ 
$$ == (c_1 \implies [p_1]R) \land (c_2 \implies [p_2]R) \land \cdots \land p[R] $$ 

***Sequencing.*** Used in refinement.
$$ [S; T]R == [S] ([T]R) $$ 
Note that I will usually omit the brackets and just define the application order as right-applicative.

***Local variables.*** Used in refinement.
$$ [\bvar v \bin S \bend] R == \forall v \cdot [S]R $$
</div>

<div class="md-conv" id="v-consistent">
## Machine Consistency

How do we make sure a machine is consistent? We need to check for several things, including 

* that the invariant is maintained.
* that the invariant is given by the initialisation.

<div class="blue">

***Initialisation consistency.***

$$ \lh \true \rh \binitialisation \lh I \rh $$

where $I$ is the invariant.
</div>

</div>

<button class="collapsible">Example.</button>
<div class="ccontent md-conv">
Given 
\begin{align}
\binvariant\\; &inside \subseteq PID \land \\\\
& maxin \in \No \land \\\\
&\card(inside) \leq maxin
\end{align}
$$ \binitialisation\; inside := \{\} || maxin := 500 $$

We can solve this as

\begin{align}
[\binitialisation] \binvariant &== [inside := \\{\\} || maxin := 500] \left(\begin{matrix}
inside \subseteq PID \land \\\\
maxin \in \No \land \\\\
\card(inside) \leq maxin
\end{matrix}\right) \\\\
&== \varnothing \subseteq PID \land 500 \in \No \land 0 \leq 500 \\\\ 
&== \true 
\end{align}

</div>

<div class="md-conv">
Operations come next, and we can assume invariants are true. 

<div class="blue">

***Operation consistency.*** 
$$ I \land \bpre \implies [S] I $$
Where $S$ is the operation body.

</div>
</div>

<button class="collapsible">Example.</button>
<div class="ccontent md-conv">
Given the above an operation
\begin{align}
enter(p) &= \bpre p \in PID \land p \not\in inside \land \card(inside) \lt maxin \\\\
&= \bthen inside := inside \cup \\{p\\} \\\\ 
&\bend 
\end{align}

We get 
$$
\begin{matrix}
inside \subseteq PID \land maxin \in \No \land \card(inside) \leq maxin \land \\\\
p \in PID \land p \not\in inside \land \card(inside) \lt maxin \\\\ 
\implies \\ 
[inside := inside \cup \\{p\\}] \left(\begin{matrix}
inside \subseteq PID \land maxin \in \No \land\\\\
	\card(inside) \leq maxin 
\end{matrix}\right)
\end{matrix}
$$
The latter resolves to
$$ == inside \cup \\{p\\} \subseteq PID \land maxin \in \No \land \card(inside \cup \\{p\\}) \leq maxin$$ 

Overall this resolves to $\true$ given our precondition and invariant.
</div>

<div class="md-conv">
***Assertions.*** An assertion is a fact we can make about the program that is always true -- i.e. it is an invariant. 

**However**, if we prove that this assertion follows from the invariant: $I \implies A$, then we do not need to include this assertion in any precondition.

That is, for properties $P$, constants $C$, invariant $I$, and assertions $J_1 .. J_n$, for every $J_i$:
$$ P \land C \land I \land J_{1..i-1} \implies J_i $$

You can also use properties and constants in operation proof: $P \land C \land I \land \bpre \implies [S]I$

<div class="side">

**Some notes:** AB does not detect if your constraints are *satisfiable*, just that they're true.

The natural numbers is a finite set from $0 .. 2^{32}-1$, and so often if AB fails to prove something it's because you've not checked that your input is less than `MAXINT`.

Don't ask me how the prover works. <img src="https://upload.wikimedia.org/wikipedia/commons/7/7a/Animated-Flag-First-French-Republic.gif" alt="" style="display: inline; max-height: 1em;"> 
</div>
</div>
</div>

		<div class="colourband">
			<h2 id="structure">Machine Structuring</h2>
		</div>

		<div class="cbox">

<div class="md-conv">
### Introduction

In large specifications modularity in design is essential -- B provides different machine structuring mechanisms that we can use, in order of permissiveness:

1. [$M_2$ SEES $M_1$](#s-sees)
1. [$M_2$ USES $M_1$](#s-uses)
1. [$M_2$ INCLUDES $M_1$](#s-includes)

Then:

1. [Proof obligations](#s-proof)
</div>

<div class="md-conv" id="s-sees">
#### Sees

The least permissive instruction. 

$M_2 \bsees M_1$ grants M2 **read-only** access to M1, which means:
* M2 can refer to sets and constants in M1,
* M2 can query its variable values directly,
* M2 can use **only** operations from M1 that do not change state, and only query.
* M2 **cannot** use any of M1's variables in its own invariant -- otherwise this would allow M2's invariant to be broken out of M2's control.

M2 cannot control M1's parameters, nor see any other machines that also see M1.

A machine can be seen by many other machines. 

This is denoted by a SEES clause under the MACHINE header:

\begin{align}
	\bmachine\\;& ClearanceDB \\\\ 
	\bsees\\;&  Classification, Person
\end{align}

Seeing is useful for sharing definitions and deferred sets, so that all machines can use the same data types. 

\begin{align}
	\bmachine\\; & Colours \\\\ 
	\bsets \\;& COLOURS = \{red, amber, green\} \\\\ 
	\bend \\;
\end{align}


</div>

<div class="md-conv" id="s-includes">
#### Includes 

The most permissive instruction. 

$M_2 \bincludes M_1$ grants M2 **full and total control** over M1 -- M1 is effectively put into M2's specification.

M2 can see all variables and use all operations, though it can *only* update M1's state through it's operations.

All variables of M1 are useable in M2's invariant.

The initialisation of M1 is done *before* the initialisation of M2. This is the only bit of sequential processing at the abstract level.

A machine can only be included by **one** other machine. We can similarly write:

\begin{align}
	\bmachine\\;& TrafficSystem \\\\ 
	\bsees\\;&  TrainGate, CarGate
\end{align}

The operations of M1 **cannot** be called externally from M2, we have to either define a different wrapper operation with a **different name**, or we use the $\bpromotes op_1, op_2$ clause.

This is because in reality the specification is treated as "flat" and not hierarchical. Thus we always need to be careful that the overall specification does make sense.

Visibility is **not** transitive, so if M3 sees M2 and M2 sees M1, M3 cannot see M1. In nested includes, this means that M3 can only manipulate M2.
</div>

<div class="md-conv" id="s-uses">
#### Uses 

Uses is the clause that one has to be most careful about, because it's the only one that can feasibly break an invariant through side effects (via another machine).

$M_2 \buses M_1$ is like $M_2 \bsees M_1$ in that M2 has read-only access to M1's variables.

However M2 **can** use M1's variables in its own invariant, but 
* this makes claims about variables that M2 has no control over
* which cannot guarantee the invariant always holds
* thus proof conditions for USES is always deferred to a later stage (refinement) where it is factored out.
</div>

<div class="md-conv" id="s-proof">
### Proof Obligations

For $M_2 \subset M_1$, the general idea is to 
* verify that $M_1$ is consistent 
* use the constraints, properties, etc. from $M_1$ in the conditions of $M_2$.

For INCLUDES, we need to also demonstrate that the instantiation of M1 in M2 satisfies M1, that is
$$ C_1 [values / p_1] $$ 
Where $C_1$ are the constraints of machine 1, $p_1$ are the parameters, and $values$ are the actual passed values. 

The initialisation is the only place where we have to use *sequencing* before concrete refinement. It is
$$ C_1 \land C_2 \land B_1 \land B_2 \implies [T_1 ; T_2] I_2 $$ 
Where $C_\cdot$ are the constraints, $B_\cdot$ are the properties, $T_\cdot$ are the initialisations, and $I_2$ is the invariant of machine 2. 

Since we prove M1 first, and also can only manipulate it through its own operations (thus maintaining its invariant), we do not need to consider $I_1$ at all.


</div>
</div>

		<div class="colourband">
			<h2 id="refinement">Refinement</h2>
		</div>

<div class="cbox">
<div class="md-conv">
## Contents 

1. [Introduction](#r-1)
2. [Basic Refinement](#r-2)
3. [Proof Obligations](#r-3)
4. [Loops](#r-4)
5. [Implementations](#r-5)

</div>

<div class="md-conv" id="r-1">
## Introduction 

So far we have been writing specifications -- *interfaces* for code, but we need to turn these abstract specifications into something concrete that can be implemented, or generated.

Refinement is the process of moving from abstract mathematical concepts to concrete machines, which are written using a restricted set of the B language. In refinements, you are permitted **sequencing** and **loops**.

This can be done stepwise too, to slowly move forwards to the concrete machine. 

Refinement machines are denoted using the $\brefinement$ keyword, and what they refine is written under $\brefines$

The final stage is an $\bimplementation$ machine.

There are two types of refinement:

***Data refinement.*** replaces abstract data structures with concrete ones.

e.g. replacing set addition $s := s \cup \{i\}$ with array append $idx := idx + 1; arr(idx) := i$

* refinements must be *at least as available* as the abstract operation -- must not restrict more than the precondition.
* the interface must be the same -- same inputs, outputs.

The most crucial part of data refinement is the **linking invariant**, a statement in the invariant which describes the relationship of the concrete data structure to the abstract one. 

e.g. $s = arr[1..pos]$


***Operation refinement.*** replaces an abstract operation with concrete ones. This could be something like replacing an $:\in$ with a defined assignment, or rewriting a summation as a loop.

Whatever you do though, you cannot introduce *more* non-determinism, though you can move it around.
</div>

			<div class="md-conv" id="r-2">
## Basic Refinement

Take the following machine:

```haskell
MACHINE 		Forms 
SETS 			CLASS; RESP = {yes, no}
CONSTANTS 		cmax 
PROPERTIES 		cmax : NAT1 & card(CLASS) &lt;= cmax
VARIABLES 		returns 
INVARIANT 		returns &lt;: CLASS 
INITIALISATION 	returns = {} 
OPERATIONS 
	ret_form(c) = 
		PRE c : CLASS & c /: returns 
		THEN returns := returns \/ {c} 
		END;
	o &lt;-- query(c) = 
		PRE c : CLASS 
		THEN IF c : returns THEN o := yes ELSE o := no END
		END
```

This details a class and records who has returned their homework.

To refine this we can define what the deferred CLASS set really is, as well as replace the returns set with an array that mapped members of the class to `yes` or `no` depending on whether that student has returned or not.

We also don't need to re-write anything which is predefined.

```haskell
REFINEMENT  Forms_r 
REFINES 	Forms 
VARIABLES 	retarr
INVARIANT 	retarr : CLASS  --&gt; RESP & 
			returns = dom(retarr |> {yes})  <span class="grey">//linking invariant</span>
INITIALISATION
	retarr := CLASS  * {no}
OPERATIONS 
	ret_form(c) = retarr(c) := yes;
	o &lt;-- query(c) = o := retarr(c)
```

Note that the preconditions don't need to be rewritten again. The old invariant is also included implicitly.

So in general:
* Structuring must repeat (must write USES, SEES, etc)
* Operation interfaces must match 1:1 -- though the internals can change.

> A refinement need only maintain enough information to perform its operations in accordance with its specification.

**USES is forbidden** in refinements.


Take another machine and refinement:	

```haskell 
MACHINE 		EntrySys 
SETS 			PID 
CONSTANTS 		maxin 
PROPERTIES 		maxin : NAT1
VARIABLES 		inside 
INVARIANT 		inside &lt;: PID & card(inside) &lt;= maxin 
INITIALISATION 	inside := {}
OPERATIONS
	enter(p) = 
		PRE p : PID & card(inside) &lt; maxin & p /: inside 
		THEN inside := inside \/ {p} 
		END;

	o &lt;-- whosin = o := inside;

	leave(p) =
		PRE p : PID & p : inside 
		THEN inside := inside - {p}
		END;
		
	p &lt;-- arbitrary_eject = 
		ANY a WHERE a : inside THEN 
			inside := inside - {a} || p := a 
		END 
```

We can refine this to:

```haskell
REFINEMENT 		EntrySys_r 
REFINES 		EntrySys 
PROPERTIES 		maxin = 500
VARIABLES 		ilist 
INVARIANT 		ilist : iseq(PID) & ran(ilist) = inside 
INITIALISATION 	ilist = []
OPERATIONS 
	enter(p) = ilist := ilist &lt;- p;

	o &lt;-- whosin = o := ran(ilist);

	leave(p) = VAR i IN
			i := ilist'(p);
			ilist := (ilist /|\ (i-1)) ^ (ilist \|/ i)
		END;
	
	p &lt;-- arbitrary_eject = 
		p := ilist(1);
		ilist := tail(ilist)
```

The linking invariant can be quite complex.

Whilst data refinement is usually the go-to, a refinement doesn't need to change the data structures at all. 
			</div>


<div class="md-conv" id="r-3">
## Proof Obligations

Informally, any refinement which
* matches the input/output interface of the machine 
* matches the effective behaviour of the machine
* has an appropriate linking invariant
* has an appropriate initialisation and logically valid operations 
can be a valid refinement. 

More formally, two properties need to be true: **applicability** and **correctness**. To define these we can consider our machines (abstract as $M$ and concrete as $R$) as *functions*.

**Applicability** states that each value mapped by the abstract machine, must be mapped by the concrete machine. "Everything it does we do"; $\dom(M) \subseteq \dom(R)$

**Correctness** states that each value mapped by the concrete machine, must agree with the abstract definitions. "Everything it says to do we do"; $\dom(M) \vartriangleright R \subseteq M$

To define the following proof obligations, note this fact:

* $[prog]P$ denotes states from which prog **must** establish P.
* $\lnot [prog] \lnot P$ denotes states from which prog **can** establish P.

The latter is gotten using de morgan's law. Whilst the former's precondition will be states $\land$ed together, the latter will have states $\lor$ed together. 
</div>

<div class="blue md-conv">
***Initialisation Condition.***

For the abstract machine with initialisation $T$, properties $B$, constants $C$,

For the concrete machine with initialisation $T_1$, properties $B_1$, linking invariant $J$:

$$ C \land B \land B_1 \implies [T_1] \lnot [T] \lnot J $$
</div>

<p></p>

<div class="blue md-conv">
	***Operation Condition.***

	Let the abstract operation be $S$, the concrete be $S_1$, and $J$ as the linking invariant.

	Then let $I$ be the abstract invariant, $P$ be the preconditions, we get

	$$ I \land J \land P \implies [S_1] \lnot [S] \lnot J $$
</div>

<p></p>

<div class="blue md-conv">
***Outputs and Preconditions.***

Outputs are not part of the state, but they are part of the interface. To ensure the output is what we expect ensures *correctness*. 

Say the abstract machine has output $o$ but the concrete has output $o'$ (rename them even though they are the same), we get for our modified operation condition:

$$ I \land J \land P \implies [S_1[o'/o]]\lnot[S]\lnot[J \land o' = o] $$ 

Preconditions must not be strengthened, ensuring that the concrete must accept anything the abstract would (or more). If the concrete operation has a precondition $P_1$, we must ensure:

$$ I \land J \land P \implies P_1 $$
</div>

<p></p>

<div class="md-conv" id="r-4">
## Loops

B gives you while loops of the form $\bwhile C \bdo L \bend$.

Whilst it would be nice to write just that, the weakest precondition for loops would be awful, since we'd then need to do recursive unravelling which may never end. 

Thus we need to define extra information to allow us to verify the two properties of a loop:
* **correctness**, that when execution ends it has the right postcondition.
* **termination**, that the loop does actually end.

For termination, we must identify the **loop variant** -- 
* a property of the loop that is **strictly decreasing**, 
* and provides an upper **bound** on the number of remaining executions. (Doesn't need to count exactly.)

For correctness, we must identify the **loop invariant** (pain), --
* a relationship which doesn't change during execution,
* which describes how the loop works,
* such as by demonstrating the process the loop has completed,
* that is chosen carefully enough to make the postcondition true.

Take the loop 
\begin{align}
	&x := 0; sum := 0; \\\\
	& \bwhile x \neq n \\\\
	& \bdo x := x + 1 ; sum := sum + arr(x) \\\\ 
	& \bend
\end{align}

We can pick the loop variant $n - x$. 

When the loop ends, the guard ($x \neq n$) becomes false. We need to pick a loop invariant such that it and not the guard imply the postcondition.

We can pick from several loop invariants, like $x \geq 0$ or $y = 3$, but the most helpful one to us right now would be $sum = \sum i \cdot (1 \leq i \land i \leq x | arr(i))$ 

The negated post condition is just $x = n$, so we may also want to state a bound $0 \leq x \leq n$ in our invariant.

Thus we would finally write:

\begin{align}
	&x := 0; sum := 0; \\\\
	\bwhile\;& x \neq n \\\\ 
	\bdo\;& x := x+1 ; sum += sum + arr(x) \\\\
	\binvariant\;& sum = \sum i \cdot (1 \leq i \land i \leq x | arr(i)) \land 0 \leq x \leq n \\\\ 
	\bvariant\;& x - n \\\\
	\bend\;
\end{align}
</div>

<div class="blue md-conv">
***Loop condition*** For the loop 
$$ \bwhile E \bdo S \binvariant I \bvariant v \bend $$ 

We have IF

\begin{align}
	& \forall vars \cdot (I \land E \implies [S]I) \land \\\\
	& \forall vars \cdot (I \land \lnot E \implies R) \land \\\\
	& \forall vars \cdot (I \land E \implies v \in \N) \land \\\\
	& \forall vars \cdot (I \land E \land v = v_0 \implies [S]v < v_0) \\\\
	& I 
\end{align}
THEN
$$ [\bwhile E \bdo S \binvariant I \bvariant v \bend] R$$
Where each condition in turn:
* ensures the invariant is maintained,
* ensures that the postcondition is implied from the invariant and the false guard,
* ensures that the variant is nonnegative ($\N$)
* ensures that the variant is always less than the previous $v_0$ -- strictly decreasing.
</div>

<div class="md-conv" id="r-5">
Often it is helpful to use the postcondition to inform you of the invariant.

## Implementations

The end goal of refinements is an implementation.

There are two ways to write the final implementation:
* ensure the machine itself is in a fully concrete implementable version of B - $B_0$.
* import known library machines to offload some work.

#### B0

$B_0$ is the **concrete** subset of B and is the code from which a toolkit can do automatic code generation.

The actual code generation and structures itself though are toolkit dependent.

B0 has `CONCRETE_VARIABLES` at the implementation level,
The types known are 
* $INT \in [MININT, MAXINT]$, 
* $BOOL \in \\{\true, \false\\}$, 
* enumerated sets, 
* and deferred sets when defined.

**Arrays** are total functions where the domain is $0..n \pod{n \in \N}$, and the range is concrete.
* e.g. $marks \in STUDENT \longrightarrow 0..100$, where STUDENT is also defined $STUDENT = 0..30$.

**Records** are known too, but all types in all fields must be concrete. 

B0 does **not** have sets, partial functions, relations, and sequences.

-----

Given the following machine

\begin{align}
	\bmachine\;& Membership \\\\
	\bsets\;& MID \\\\
	\bconstants\;& reserved \\\\
	\bproperties\; & card(MID) > 100 \land reserved \in MID
\end{align}

This can implement to 

\begin{align}
	\bimplementation\;& Membership_i \\\\
	\brefines\;& Membership \\\\
	\bvalues\;& MID = 0..500; reserved = 0
\end{align}

More examples are given below.

Example 1 shows what happens with variables, the $\bvariables$ clause describes *abstract* variables, any variables to be used again must be redefined again with the correct types in a `CONCRETE_VARIABLES` section.
</div>

<p></p>

<button class="collapsible">Example 1.</button>
<div class="ccontent md-conv">
***Example.*** Take the machine 

```haskell 
MACHINE 		Carpark
SETS 			Resp={yes, no}
CONSTANTS 		cap 
PROPERTIES 		cap : NAT1
VARIABLES 		inuse 
INVARIANT 		inuse : NAT & inuse &lt;= cap 
INITIALISATION 	inuse := 0
OPERATIONS 
	o &lt;-- spacequery = IF inuse = cap THEN o := no
						ELSE o := yes
						END;
	enter = PRE inuse &lt; cap THEN inuse := inuse + 1 END;
	leave = PRE inuse &gt; 0 THEN inuse := inuse - 1 END
END
```

This can implement to 

```haskell 

IMPLEMENTATION Carpark_i 
REFINES CarPark 
VALUES cap = 500
CONCRETE_VARIABLES inuse 
INITIALISATION inuse := 0
OPERATIONS 
	o &lt;-- spacequery = IF inuse = cap THEN o := no
						ELSE o := yes
						END;
    enter = inuse := inuse + 1;
	leave = IF inuse > 0 THEN inuse := inuse - 1 END 
END
```
</div>

<p></p>

<button class="collapsible">Example 2.</button>
<div class="ccontent md-conv">
***Example.*** Take the following machine 

```haskell
MACHINE 		Smallform
SETS 			CLASS, RESP = {yes, no}
CONSTANTS 		cmax 
PROPERTIES 		cmap : NAT1 & card(CLASS) = cmax 
VARIABLES 		returns 
INVARIANT 		returns &lt;: CLASS 
INITIALISATION 	returns := {}
OPERATIONS 
	retform(c) = 
		PRE c : CLASS - returns 
		THEN returns := returns \/ {c}
		END;
	o &lt;-- formquery(c) =
		PRE c : CLASS 
		THEN IF c : returns THEN o := yes ELSE o := no END 
		END 
END
```

It can implement to 

```haskell
IMPLEMENTATION		Smallform_i
REFINES 			Smallform 
VALUES 				cmax = 30; CLASS = 0..29
CONCRETE_VARIABLES 	rarr
INVARIANT 			rarr : 0..29 --&gt; RESP &
					returns = dom(rarr |> {yes})
INITIALISATION 		rarr := CLASS * {no} 
OPERATIONS
	retform(c) = rarr(c) := yes;
	o &lt;-- formquery(c) = o := rarr(c)
END
```

Of course if we had some seemingly innocent extra operation like 

$$ n \longleftarrow howmanyret = n := card(returns) $$

B0 can't do $card(rarr \vartriangleright \{yes\})$, and so we need to count it using a loop:

```haskell 
	n &lt;-- howmanyret = 
		VAR i, x, r IN 
			x := 0; 
			i := 0;
			WHILE i &lt; 30 DO 
				r := rarr(i);
				IF r = yes THEN x := x + 1 END;
				i := i + 1
			INVARIANT 
				x : NAT & x &lt;= i & i : NAT & i &lt;= 0 & i &lt;= 30 & 
				x = card(0..i-1 <| rarr |> {yes})
			VARIANT 
				30 - i
			END;
			n := x
		END
```

Not the best.
</div>

<div class="md-conv">

$\bpre$ only guarantees that the operation runs fine when the inputs agree, but says nothing if the inputs do not agree. 

If we are in a controlled situation where we know the inputs do agree, then ignoring preconditions is OK, but if we are not, then we would need to account for other cases.

Take the `Carpark` machine from example 1. Perhaps we want to implement error handling. We cannot just tack it on because the interface must be remain the same, so we write an **abstract machine wrapper**:

\begin{align}
	\bmachine\\;& TotCarpark \\\\
	\bsees\\;& RESP  \\\\
	\bsets\\;& ERR = \{ok, noroom, empty\} \\\\
	\boperations\\; 
	& e, o \longleftarrow tot\_spaceq = \bbegin e :\in ERR || o :\in RESP \bend; \\\\
	& e \longleftarrow tot\_enter = \bbegin e :\in ERR \bend; \\\\
	& e \longleftarrow tot\_leave = \bbegin e :\in ERR \bend
\end{align}

Note this TotCarpark's operations are fully abstract, all they say is that those variables must be assigned from those sets -- this gives us total freedom to control how to do the assignment. We also pull response into its own machine.

And now the way we can wrap over Carpark is to make an implementation of TotCarpark, and $\bimports$ Carpark.

```haskell 
IMPLEMENTATION 	TotCarpark_i 
REFINES 		TotCarpark
IMPORTS		 	Carpark 
SEES 			RESP
OPERATIONS
	e, o &lt;-- tot_spaceq = BEGIN o &lt;-- spacequery; e:= ok END;
	e &lt;-- tot_enter = 
		IF inuse < cap
		THEN BEGIN e := ok; enter END
		ELSE e := noroom
		END;
	e &lt;-- tot_leave = 
		IF inuse > 0 
		THEN BEGIN e := ok; leave END 
		ELSE e := empty 
		END
```

**Note** we only ever import an abstract machine, never a refinement or implementation. This is because the machine is the authoratative interface.

We can call operations of imported machines -- that's how we will use library machines.

</div>

<div class="md-conv">

### Library machines

AB can generate C code -- it can even generate a main function, if given a top level machine. 

The `BASIC_IO` machine is a pre-written library machine that can do basic text input output. Thus, finally, to write a hello world program in B we will need a generic top machine, and its implementation:

\begin{align}
	\bmachine \\;& Top \\\\
	\boperations \\;& main = skip \\\\
	\bend
\end{align}

And 

\begin{align}
	\bimplementation \\;& Top\_i \\\\
	\brefines \\;& Top \\\\
	\bimports \\;& \r{BASIC_IO} \\\\
	\boperations \\\; & main = \r{STRING_WRITE}(\r{"Hello world! \\n"})
\end{align}

Tada.

In general AB has a variety of library machines which deal with more complex structures, such as sets and sequences. 

With each machine, they have their "central" variable that you need to put in your linking invariant, and then it is merely just calling operations. Machine parameters are passed in just like function arguments in conventional programming languages.

* `BASIC_ARRAY_VAR(index, elem)` is a 1D array machine, with the benefit of using anything as the index, unlike B0's $0..n$ only index.

* `BASIC_ARRAY_RGE` is a 2D array machine.

For example an abstract variable $myarray \in 1..3 \longrightarrow \N$ can be implemented by doing the following:
$$ \bimports \r{BASIC_ARRAY_VAR}(1..3, \N) $$ 
$$ \binvariant arr\\_vrb = myarr $$ 
Where `arr_vrb` is the variable in `BASIC_ARRAY_VAR` that stores the array.

* `L_SET(maxcard, elemtype)` is a set machine. It stores a set as a **sequence** `set_vrb`, and so the linking invariant should go like $myset = \ran(set\\_vrb)$. 

Importing multiple copies of a machine is as simple as prepending an identifier onto them, so 
$$ \bimports s1.\r{LSET}(35, CLASS), s2.\r{LSET}(40, \N) $$ 
will import two sets, and expose their two variables as $s1.set\_vrb$ and $s2.set\_vrb$, with their operations accordingly.

The proofs of these machines can be assumed to have been done beforehand.

* `L_PFNC(p1, p2, p3)` is a partial function. It represents a partial function $0..p_3 \pfunc p_1..p_2$ over integers only. Its linking variable is `pfnc_vrb` and is used like $pfnc\_vrb = marr \pod{marr \in CLASS \pfunc MARK}$

And much, much more.

And that is roughly everything.
</div>
		</div>

		<footer>
			<div class="cbox">
                <div class="columncontainer ctwo" id="fc2">
                </div>
                <script type="text/javascript" src="../../js/footerGen.js"></script>
            </div>
		</footer>

	</div>
</body>
</html>