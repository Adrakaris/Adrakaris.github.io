<!DOCTYPE html>
<html>
<head>
	<title>CS412</title>
	<meta charset="utf-8">
	<link rel="stylesheet" type="text/css" href="../../style/style.css" media="all">  <!--TODO: CHANGE HREF-->
	<link rel="stylesheet" type="text/css" href="../../style/prism.css" media="all">
	<meta name="viewport" content="width=device-width" initial-scale=1.0>  <!--TODO: CHANGE LINKS ON BOTTOM OF SHEET FOR COLLAPSIBLE-->
	<link rel="icon" type="image/png" href="../../style/images/DragonIcon.png">
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>

	<div class="hidden">
		<header>
			<div class="parallax parsmaller">
				<div  style="display: grid; grid-template-columns: 1fr 1fr 1fr 8fr 1fr; grid-column-gap: 10px; padding: 5px; ">
					<div class="column tinycolumn">
						<a href="../../" class="nav">Home</a>
					</div>
					<div class="column tinycolumn">
						<a href="../../blog.html" class="nav">Blog</a>
					</div>
					<div class="column tinycolumn">
						
						<a href="../../about.html" class="nav">About</a>
					</div>
					<div></div>
					<div class="column">
						<button class="nav dark-light">Dark Mode</button>
					</div>
				</div>
				<div class="cbox"> 		
					<h1>CS412</h1>
					<p class="subheading">Formal Systems</p>
				</div>
			</div>
		</header>

		<header>
			<div class="cbox">
				<h1>Contents</h1>
			</div>
		</header>

		<style>
			r-r {
				float: right;
			}
		</style>


		<div class="cbox">
			<div class="blue md-conv" style="text-align: center;">
				**IMPORTANT NOTES**

				This is not an exhaustive list of B syntax. This also does not explain Atelier B's syntax quirks in any thorough manner.

				[Atelier] B mandates that no identifiers be one letter long, i.e. you can't have $x$, $y$, etc. and it has to be $xx$, $yy$, etc. But this is stupid in display maths and generally affects readability -- actually name your variables. Thus, for single letter variables:
				
				**Variables may not have double letters.**

				Fill them in yourself in your head, or use actual variable names in code.
			</div>

			<div class="md-conv">
				### Contents

				1. [Référence du système B](#reference)
				2. [Verification](#proof)
			</div>
		</div>

		
		<div class="colourband">
			<h2 id="reference">
				<img src="https://upload.wikimedia.org/wikipedia/commons/7/7a/Animated-Flag-First-French-Republic.gif" alt="" style="display: inline; max-height: 1em;"> 
				Référence du système B
				<img src="https://upload.wikimedia.org/wikipedia/commons/7/7a/Animated-Flag-First-French-Republic.gif" alt="" style="display: inline; max-height: 1em;"> 
			</h2>
		</div>
		
		<div class="cbox">
			<div class="md-conv">
				## Contents 

				1. [Layout](#ref-layout)
				2. [Structures](#ref-structures)
				3. [Notation](#ref-notation)
			</div>

			<div class="md-conv" id="ref-layout">
				### Layout 

				The general layout of B:
			</div>
			<div class="codediv">
MACHINE
	MachineName(params)  <span class="grey">// machine name and params </span>

CONSTRAINTS
	params : NAT  <span class="grey">//constraints of parameters</span>

SETS
	ONES; TWOS;  <span class="grey">// deferred sets </span>
	RESP = {yes, no}  <span class="grey">// enumerated sets</span>

CONSTANTS
	const  <span class="grey">// declar names</span>

PROPERTIES
	const : NAT1  <span class="grey">// define properties about sets and constants </span>

VARIABLES
	vara, varb  <span class="grey">// declare names</span>

INVARIANT  <span class="grey">// states constants about the machine that must always be true</span>
		   <span class="grey">// includes types (what variable element of which)</span>
	vara : NAT1 & varb : NAT &
	P & Q

INITIALISATION  <span class="grey">// gives initial values to variables (must obey invariant)</span>
	vara := 1 || varb := 0

OPERATIONS <span class="grey">// defines the machine operations (the important bit)</span>

	addOne = PRE <span class="grey">// preconditions</span>
		varb < MAXINT
	THEN
		varb := varb + 1
	END;

	out <-- read = out := varb  <span class="grey">// note this one-liner without </span>
								<span class="grey">preconditions doesn't need an END</span>
END</div>

			<hr>

			<div class="md-conv" id="ref-structures">
				## Structures

				Important structures to know. 
				\(
					\newcommand{\b}{\textbf}	
					\newcommand{\B}{\textbf}	
					\newcommand{\bb}{\mathbb}	
					\newcommand{\N}{\mathbb{N}}	
					\newcommand{\No}{\mathbb{N}_1}	
					\DeclareMathOperator*{\card}{card}
					\DeclareMathOperator*{\dom}{dom}
					\DeclareMathOperator*{\ran}{ran}
					\DeclareMathOperator*{\pow}{\mathbb{P}}
					\DeclareMathOperator*{\llra}{\longleftrightarrow}
					\DeclareMathOperator*{\skip}{skip}
					\DeclareMathOperator*{\seq}{seq}
					\DeclareMathOperator*{\seqo}{seq_1}
					\DeclareMathOperator*{\iseq}{iseq}
					\DeclareMathOperator*{\perm}{perm}
					\DeclareMathOperator*{\size}{size}
					\DeclareMathOperator*{\rev}{rev}
					\DeclareMathOperator*{\first}{first}
					\DeclareMathOperator*{\last}{last}
					\DeclareMathOperator*{\tail}{tail}
					\DeclareMathOperator*{\front}{front}
					\DeclareMathOperator*{\struct}{struct}
					\DeclareMathOperator*{\rec}{rec}
					\DeclareMathOperator*{\true}{true}
					\DeclareMathOperator*{\false}{false}
					\newcommand{\lessplus}{&lt;\kern-6pt +\;}
					\newcommand{\pfunc}{\kern3pt +\kern-12pt \longrightarrow}
					\newcommand{\pinj}{\kern3pt +\kern-12pt \rightarrowtail}
					\newcommand{\inj}{\rightarrowtail}
					\newcommand{\surj}{\twoheadrightarrow}
					\newcommand{\bij}{\kern3pt \rightarrowtail\kern-8pt \twoheadrightarrow}
				\)

				\(
					\DeclareMathOperator*{\bmachine}{\b{MACHINE}}
					\DeclareMathOperator*{\bconstraints}{\b{CONSTRAINTS}}
					\DeclareMathOperator*{\binitialisation}{\b{INITIALISATION}}
					\DeclareMathOperator*{\binvariant}{\b{INVARIANT}}
					\DeclareMathOperator*{\bbegin}{\b{BEGIN}}
					\DeclareMathOperator*{\bend}{\b{END}}
					\DeclareMathOperator*{\bpre}{\b{PRE}}
					\DeclareMathOperator*{\bif}{\b{IF}}
					\DeclareMathOperator*{\bcase}{\b{CASE}}
					\DeclareMathOperator*{\bany}{\b{ANY}}
					\DeclareMathOperator*{\blet}{\b{LET}}
					\DeclareMathOperator*{\bchoice}{\b{CHOICE}}
					\DeclareMathOperator*{\bselect}{\b{SELECT}}
					\DeclareMathOperator*{\bthen}{\b{THEN}}
					\DeclareMathOperator*{\belse}{\b{ELSE}}
					\DeclareMathOperator*{\beither}{\b{EITHER}}
					\DeclareMathOperator*{\bwhere}{\b{WHERE}}
					\DeclareMathOperator*{\bwhen}{\b{WHEN}}
					\DeclareMathOperator*{\bor}{\b{OR}}
					\DeclareMathOperator*{\bof}{\b{OF}}
					\DeclareMathOperator*{\bbe}{\b{BE}}
					\DeclareMathOperator*{\bin}{\b{IN}}
				\)

				***Preconditons.*** Usually around most operations with parameters. Parameters passed must match preconditions, else behaviour is undefined (this is useful when we deabstract everything). Written as

				$$\bpre P \bthen B \bend$$ 

				Where $P$ is the predicate condition and $B$ is the operation.

				Operations are stateless and instantaneous (no doing one thing after another).

				***Conditionals.*** If statements.

				$$\bif E \bthen S \b{ ELSE } T \bend$$ 

				The else block is optional.

				***Conditionals.*** Switch cases. 

				\begin{align}
					\bcase E \bof \;&\beither e_1 \bthen T_1 \\ 
					&\bor e_2 \bthen T_2 \\ 
					&\bor \dots \\
					&\b{ELSE } V \\
					&\bend
				\end{align}

				Often seen over finite sets. Works as you'd expect a switch statement to work.

				***Block.*** A begin-end block. Used only for increasing readability.

				$$ \bbegin S \bend $$

				***Machine parameters.*** Values which can be passed in when a machine is instantiated. Write next to the machine in *brackets* like how you'd write a function signature.

				$$ \bmachine Store(ITEM, capacity) $$

				*Upper-case* parameters are treated as deferred sets, whilst *lower-case* parameters are treated as constants. Constants must have their type specified in the $\bconstraints$ clause, whilst sets can be left as-is.

				$$\bconstraints capacity \in \No \land capacity \leq 4096$$

				One should ensure that the constraints can actually be met.

				***Let.*** Allows a variable to stand in place of a value in a block statement.

				$$\blet x \bbe x = E \bin S \bend$$ 

				This is the deterministic version of the $\bany$ structure that is below.


				#### Nondeterministic structures

				***Any.***  Allows an arbitrary choice of variable value in a statement.

				$$ \bany x \bwhere Q \bthen T \bend $$ 

				For example: $\bany n \bwhere n \in \No \bthen total := total \times n \bend$. This can be done over multiple variables:

				\begin{align}
					&\bany dx, dy \bwhere dx \in \No \land dy \in \No \land dy \gt dx \\
					&\bthen x := x + dx || y := y + dy \\ 
					&\bend
				\end{align}

				***Choice.*** Choose any one of multiple outcomes to execute.

				$$ \bchoice S \bor T \bor \dots \bor U \bend $$

				This can be used to describe *allowable outcomes*. Each branch in a choice statement can also be non-deterministic, thus you can nest $\bany$s in $\bchoice$s.

				***Select.*** The non-deterministic version of the switch statement. The conditions in a select can overlap, leading to multiple possible outputs.

				\begin{align}
					&\bselect Q_1 \bthen T_1 \\
					&\bwhen Q_2 \bthen T_2 \\ 
					&\cdots \\
					&\bwhen Q_n \bthen T_n \\
					&\belse V \bend 
				\end{align}

				Where the $Q$s are predicates, the $T$s are statements, and the else clause is optional.
				
			</div>

			<hr>

			<div class="md-conv" id="ref-notation">
				## Notation 

				Display maths notation and code notation are both shown. If one is missing that means I forgot and cannot yet be bothered to look it up. 

				Some B notation is difficult to display in mathjax -- I will be using the closest possible variants.

				My code font also has ligatures, bear that in mind.

				#### General B notation:

				* assignment: $x := y$ <r-r>`x := y`</r-r>
				* parallel operation: $x := y || y := z$ -- does NOT assign z to x since it is done in parallel. <r-r>`x := y || y := z`</r-r>
				* parallel assign: $x, y := y, z$ <r-r>`x,y := y,z`</r-r>
				* no operation: $\skip$ <r-r>`skip`</r-r>
				* operation return: $o \longleftarrow operation = \cdots$ <r-r>`oo &lt;-- operation = ...`</r-r>

				#### Set Notation

				* empty set: $\{\}$ or $\varnothing$  <r-r>`{}`</r-r>
				* member: $e \in S$  <r-r>`e : S`</r-r>
				* not member: $e \not\in S$  <r-r>`e /: S`</r-r>
				* subset: $S \subseteq T$ ; <r-r>`S &lt;: T`</r-r>
				* union: $S \cup T$ <r-r>`S \/ T`</r-r>
				* intersection: $S \cap T$ <r-r>`S /\ T`</r-r>
				* subtraction: $S - T$ <r-r>`S - T`</r-r>
				* big union: $\bigcup S$
				* big intersect: $\bigcap S$
				* powerset: $\pow S$ <r-r>`POW(S)`</r-r>
				* cartesian product: $S \times T$ <r-r>`S * T`</r-r> 
				* cardinality (size): $\card(s)$ <r-r>`card(S)`</r-r>
				* naturals with 0: $\N$ <r-r>`NAT`</r-r>
				* naturals without 0: $\No$ <r-r>`NAT1`</r-r>
				* set comprehension: $\{ x | x \in T \land P\}$ <r-r>`{x|x : T & P}`</r-r>
				* range between $m$ and $n$ inclusive: $m..n$ <r-r>`m..n`</r-r>

				#### Logic Notation 

				* and, or, not: $\land, \lor, \lnot$ <r-r>`&`,  `or`,  `not`</r-r>
				* implies, equivalence: $\implies, \iff$ <r-r>`=>`, `&lt;=>`</r-r>
				* universal (forall): $\forall x \cdot x \in T \implies P$ <r-r>`!(x).(x : T => P)`</r-r>
				* existential (there exists): $\exists x \cdot x \in T \land P$ <r-r>`#(x).(x : T & P)`</r-r>

				Remember to pay attention to which variables are *bound* in first order logic.

				#### Arithmetic Notation 

				* equals, less than, greater than: <r-r>`=`, `&lt;`, `&gt;`</r-r>
				* less than equals, greater than equals: <r-r>`&lt;=`, `>=`</r-r>
				* not equals: $\neq$ <r-r>`/=`</r-r>
				* add, subtract, multiply, divide: <r-r>`+`, `-`, `*`, `/`</r-r>
				* summation: $\sum x \cdot (x \in T | f(x))$ where $f(x)$ is the expression to sum. <r-r>`SIGMA (x) . (x:T | f(x))`</r-r>

				#### Relation Notation
				
				Relations between two sets describes mappings of elements from one set to another. Note that a relation $X \llra Y$ can be described as a set of pairs $(x,y) : x \in X \land y \in Y$.

				* set (type) of all relations between X and Y: $X \llra Y$ <r-r>`X &lt;-&gt; Y`</r-r>
				* element $x$ maps to $y$: $x \mapsto y$ <r-r>`x |-&gt; y`</r-r>
				* domain of relation: $\dom(R)$ <r-r>`dom(R)`</r-r>
				* range of relation: $\ran(R)$ <r-r>`ran(R)`</r-r>
				* domain restriction: $U \triangleleft R$, all mappings $x \mapsto y$ in R where $x \in U$. <r-r>`U &lt;| R`</r-r>
				* domain subtraction: $U \blacktriangleleft R$, all mappings $x \mapsto y$ in R where $x \not\in U$. <r-r>`U &lt;|| R`</r-r>
				* range restriction: $R \triangleright U$, all $x \mapsto y$ in R where $y \in U$. <r-r>`R |> U`</r-r>
				* range subtraction: $R \blacktriangleright U$, all $x \mapsto y$ \in R where $y \not\in U$. <r-r>`R ||> U`</r-r>
				* relational image: $R[U]$, all $y$ where $x \mapsto y \in R$ and $x \in U$. <r-r>`R[U]`</r-r>
				* relational inverse: $R^{-1}$, the set $\{y \mapsto x | x \mapsto y \in R\}$. <r-r>`R'`</r-r>
				* relation composition: $R;S$, given $R \in X \llra Y \land S \in Y \llra Z$, produces the relation $R;S \in X \llra Z$ where $x\mapsto z \in (R;S) \implies x \mapsto y \in R \land y \mapsto z \in S$. <r-r>`R ; S`</r-r>
				* identity relation: $id(S)$, the relation of every element in S to itself.
				* repeated composition: $R^n$ relation R composed to itself $n$ times.
				* relation overriding: $R \lessplus S$, where R and S relate the same sets, substitutes all mappings $x \mapsto y \in R$ for corresponding $x \mapsto y' \in S$, if $x$ is present in both domains. <r-r>`R &lt;+ S`</r-r>


				For the four triangle operations, pay special care as to what order it's in.

				#### Function Notation

				Functions are just relations where each input maps to only one output, that is for $f \in S \llra T$ to be a function, $x \mapsto y \in f \implies \forall y' \cdot (y' \in S \land y' \neq y \implies x \mapsto y' \not\in f)$.

				The following are the notations for different types of functions -- they should be read as "the set of all X"

				* partial functions: $S \pfunc T$, which maps some elems of S to some elems of T. <r-r>`S +-&gt; T`</r-r>
				* total functions: $S \longrightarrow T$, which maps *all* elems of S to some elems of T. <r-r>`S --&gt; T`</r-r>
				* partial injections: $S \pinj T$, partial functions which are injective (one-to-one) <r-r>`S >+> T`</r-r>
				* total injections: $S \inj T$, injective total functions. <r-r>`S >-> T`</r-r>
				* surjective functions: $S \surj T$, where all range elements are mapped "onto". <r-r>`S --&gt;> T`</r-r>
				* bijective functions: $S \bij T$ which are both injective and surjective. <r-r>`S >->> T`</r-r>
				* get function value: $f(x)$, which gets what $x$ maps to. <r-r>`f(x)`</r-r>
				* replace function value: $f(x) := y'$ replaces $x \mapsto y$ with $x \mapsto y'$. <r-r>`f(x) := yy`</r-r>
				* lambda function notation: $\lambda x \cdot (x \in S | f(x))$ where $f(x)$ is an expression over $x$. <r-r>`%x.(x : S | f(x))` </r-r>

				For replacement of multiple mappings, i.e. relation overriding with more than one element, we must use the $\lessplus$ syntax.

				**Arrays** are nothing but functions from a numerical range $1..n \longrightarrow S$ to some set of elements.


				#### Sequence Notation 

				Sequences, or lists, are written as functions $1..n \longrightarrow T$, relating a (1-)index to an element. They are syntax-sugared into conventional list format.

				* empty sequence: $[]$ <r-r>`[]`</r-r>
				* sequence of elements: $[e_1, \dots, e_n]$ <r-r>`[e1, ..., en]`</r-r>
				* set of finite sequences: $\seq(S)$ <r-r>`seq(S)`</r-r>
				* set of finite non-empty sequences: $\seqo(S)$ <r-r>`seq1(S)`</r-r>
				* set of injective sequences (no repeats): $\iseq(S)$ <r-r>`iseq(S)`</r-r>
				* set of permutations of the set: $\perm(S)$ <r-r>`perm(S)`</r-r>
				* list concatenation: $s_1 \smallfrown s_2$ <r-r>`s1 ^ s2`</r-r>
				* prepend element $e$: $e \rightarrow s$ <r-r>`e -> s`</r-r>
				* append element $e$: $s \leftarrow e$ <r-r>`s &lt;- e`</r-r>
				* length: $\size(s)$ <r-r>`size(s)`</r-r>
				* reverse: $\rev(s)$ <r-r>`rev(s)`</r-r>
				* take first $n$ elems: $s \uparrow n$ <r-r>`s /|\ n`</r-r>
				* drop the first $n$ elems: $s \downarrow n$ <r-r>`s \|/ n`</r-r>
				* get the first element of non-empty sequence: $\first(s)$ <r-r>`first(s)`</r-r>
				* get last element: $\last(s)$ <r-r>`last(s)`</r-r>
				* get all but the first element: $\tail(s)$ <r-r>`tail(s)`</r-r>
				* get all but the last element: $\front(s)$ <r-r>`front(s)`</r-r>

				#### Nondeterminism

				* assign any element from set: $x :\in S$ <r-r>`x :: S`</r-r>

				#### Record Types 

				Records store named fields. The type of a record structure is written as 
				$$ person \in \struct(p\_name \in NAME, p\_age \in \No) $$

				And an initialisation can go as
				$$ person := \rec(p\_name : Bob, p\_age : 21) $$

				Retrieval: $person'p\_name$

			</div>
		</div>

		<div class="colourband">
			<h2 id="proof">Verification</h2>
		</div>

		<div class="cbox">
			<div class="md-conv">
				## Introduction

				Verification is an essential part of formal systems -- ensuring that the code we write is correct and mathematically sound. This is how we eventually generate safe systems.

				During verification *bound variables* in first order logic must be dealt with very carefully, for example in
				$$ x+y \gt 10 \land \forall x \cdot (x \in X \implies P(x)) $$ 
				the first $x$ is not bound, but in the second expression $x$ is a *different* bound variable. In 
				$$ \forall x \cdot (x \in X \implies P(x)) \land \forall x \cdot (x \in X \implies Q(X)) $$ 
				the two $x$ variable are bound to different scopes and are *unrelated*. Especially, avoid cases such as 
				$$ \forall x \cdot (x \in \N \implies \exists x \cdot (x \in \N \land x > x)) $$ 
				... just don't do the last one. Rename your variables properly.

				**Substitution** is the process of replacing an *unbound* variable in an expression with another expression, it is denoted (original)[var/new]:

				$$ (x + y \gt 10)[3 / x] == 3 + y \gt 10 $$

				Read this $[3/x]$ as "three replaces x".

				### Contents
 
				1. [The Weakest Precondition](#v-wp)
				2. [Machine Consistency](#v-consistent)

				<hr>

			</div>

			<div class="md-conv" id="v-wp">
				## The Weakest Precondition

				The *weakest precondition* of a statement is essentially the least restricted state space for which an operation produces a desired output -- the postcondition.
				$
				\newcommand{\lh}{\;\{}
				\newcommand{\rh}{\}\;}
				$

				Just like in CS261 we can denote a precondition-operation-postcondition triple in *hoare triples*, that is for program $Q$ with precondition $P$ and postcondition $R$, write 
				$$ \lh P \rh Q \lh R \rh $$

				We are interested in the *weakest precondition* $P$, given a $Q, R$. This is written (perhaps confusingly) as
				$$ [Q]R $$

				#### Laws of Logic

				The following hold for complex postconditions:

				* $[S] (P \land Q) \iff [S]P \land [S]Q$ ;
				* $[S]P \lor [S]Q \implies [S] (P \lor Q) $ but not the other way round;
				* If $P \implies Q$ then $[S]P \implies [S]Q$. 
				* $[S]\true$ is trivially true for any S which terminates.

				#### Derivation Rules

				***Assignment Rule***. The weakest precondition for an assignment is 
				$$ [x := E]R == R[E/x] $$
				Replace all occurrences of $x$ in $R$ with $E$.

				***Multiple Assignment Rule***. The WP for multi-assignment is
				$$ [x_1..x_n := E_1 .. E_n]R == R[E_1..E_n / x_1 .. x_n] $$ 

				***Skip Rule***. over a skip operation:
				$$ [skip]R == R $$

				***Block Rule***. over a begin-end block:
				$$ [\bbegin P \bend] R == [P]R$$ 

				***Conditional Rule***. Over an if statement:
				$$[\bif G \bthen P_1 \belse P_2 \bend] R$$ 

				\begin{align}
					&== (G \implies [P_1]R) \land (\lnot G \implies [P_2]R) \\ 
					&== (G \land [P_1]R) \lor (\lnot G \land [P_2]R)
				\end{align}

				Also 
				$$[\bif G \bthen P_1 \bend] R == (G \land [P_1]R) \lor (\lnot G \land R)$$ 

				***Conditional Rule (II)***. Over a case statement:
				$$[\bcase v \bof \beither v_1 \bthen p_1 \bor v_2 \bthen p_2 \cdots \belse p \bend] R $$

				$$ == (v=v_1 \land [p_1]R) \lor (v=v_2 \land [p_2]R) \lor \cdots \lor (v \neq v_{1..n} \land p[R]) $$ 

				***Precondition.*** 

				$$ [ \bpre C \bthen P \bend ] R == C \land [ P ] R $$ 

				***One-point rule.*** If we have one of the following forms:
				$$
				\begin{matrix}
					\forall x \cdot (x = v \implies P) \\ 
					\exists x \cdot (x = v \implies P) 
				\end{matrix}
				$$
				Always replace by $P[v/x]$.

				***Nondeterministic assignment.*** 
				$$ [x :\in E] R == \forall s \cdot (s \in E \implies R[s/x]) $$
				
				***Any block.*** 
				$$ 
					[\bany x \bwhere Q \bthen P \bend] R \\
				$$
				$$ == \forall x \cdot (x \in E \implies [P]R ) $$

				***Choice block.*** 
				$$ [\bchoice P_1 \bor \dots \bor P_n \bend ] R$$ 
				$$ == [P_1]R \land \cdots \land [P_n]R $$

				***Select block.***
				$$ [\bselect c_1 \bthen p_1 \bwhen c_2 \bthen p_2 \dots \belse p \bend] R $$ 
				$$ == (c_1 \implies [p_1]R) \land (c_2 \implies [p_2]R) \land \cdots \land p[R] $$ 
			</div>

			<div class="md-conv" id="v-consistent">
				## Machine Consistency

				How do we make sure a machine is consistent? We need to check for several things, including 
				
				* that the invariant is maintained.
				* that the invariant is given by the initialisation.

				<div class="blue">
					***Initialisation consistency.***
					$$ \lh \true \rh \binitialisation \lh I \rh $$
					where $I$ is the invariant.
				</div>
			</div>
			<button class="collapsible">Example.</button>
			<div class="ccontent md-conv">
				Given 
				\begin{align}
					\binvariant\; &inside \subseteq PID \land \\
					& maxin \in \No \land \\
					&\card(inside) \leq maxin
				\end{align}
				$$ \binitialisation\; inside := \{\} || maxin := 500 $$

				We can solve this as

				\begin{align}
					[\binitialisation] \binvariant &== [inside := \{\} || maxin := 500] \left(\begin{matrix}
					inside \subseteq PID \land \\
					maxin \in \No \land \\
					\card(inside) \leq maxin
					\end{matrix}\right) \\ 
					&== \varnothing \subseteq PID \land 500 \in \No \land 0 \leq 500 \\ 
					&== \true 
				\end{align}

			</div>

			<div class="md-conv">
				Operations come next, and we can assume invariants are true. 

				<div class="blue">
					***Operation consistency.*** 
					\[I \land \bpre \implies [S] I \] $$
					Where $S$ is the operation body.
				</div>
			</div>

			<button class="collapsible">Example.</button>
			<div class="ccontent md-conv">
				Given the above an operation
				\begin{align}
					enter(p) &= \bpre p \in PID \land p \not\in inside \land \card(inside) \lt maxin \\
					&= \bthen inside := inside \cup \{p\} \\ 
					&\bend 
				\end{align}

				We get 
				$$
				\begin{matrix}
					inside \subseteq PID \land maxin \in \No \land \card(inside) \leq maxin \land \\
					p \in PID \land p \not\in inside \land \card(inside) \lt maxin \\ 
					\implies \\ 
					[inside := inside \cup \{p\}] \left(\begin{matrix}
					inside \subseteq PID \land maxin \in \No \land\\
					 \card(inside) \leq maxin 
					\end{matrix}\right)
				\end{matrix}
				$$
				The latter resolves to
				$$ == inside \cup \{p\} \subseteq PID \land maxin \in \No \land \card(inside \cup \{p\}) \leq maxin$$ 

				Overall this resolves to $\true$ given our precondition and invariant.
			</div>

			<div class="md-conv">
				***Assertions.*** An assertion is a fact we can make about the program that is always true -- i.e. it is an invariant. 

				**However**, if we prove that this assertion follows from the invariant: $I \implies A$, then we do not need to include this assertion in any precondition.

				That is, for properties $P$, constants $C$, invariant $I$, and assertions $J_1 .. J_n$, for every $J_i$:
				$$ P \land C \land I \land J_{1..i-1} \implies J_i $$

				You can also use properties and constants in operation proof: $P \land C \land I \land \bpre \implies [S]I$

				<div class="side">
					**Some notes:** AB does not detect if your constraints are *satisfiable*, just that they're true.

					The natural numbers is a finite set from $0 .. 2^{32}-1$, and so often if AB fails to prove something it's because you've not checked that your input is less than `MAXINT`.

					Don't ask me how the prover works. <img src="https://upload.wikimedia.org/wikipedia/commons/7/7a/Animated-Flag-First-French-Republic.gif" alt="" style="display: inline; max-height: 1em;"> 
				</div>
			</div>
		</div>

		

		<footer>
			<div class="cbox">
                <div class="columncontainer ctwo" id="fc2">
                </div>
                <script type="text/javascript" src="../../js/footerGen.js"></script>
            </div>
		</footer>

	</div>

	<script type="text/javascript" src="../../js/collapsible.js"></script>  <!--This stays at the end-->
	<script type="text/javascript" src="../../js/toggle-darklight.js"></script>
	<script type="text/javascript" src="../../js/prism.js"></script>
	<script type="text/javascript" src="../../js/markdown.js"></script>
</body>
</html>